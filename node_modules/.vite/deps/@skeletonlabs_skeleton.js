import {
  writable
} from "./chunk-DY7FSUYH.js";
import {
  fade,
  fly,
  slide
} from "./chunk-YCKTV2FB.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  action_destroyer,
  add_location,
  add_render_callback,
  afterUpdate,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  head_selector,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  setContext,
  set_attributes,
  set_custom_element_data_map,
  set_data_dev,
  set_input_value,
  set_store_value,
  set_style,
  space,
  src_url_equal,
  subscribe,
  svg_element,
  text,
  to_number,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_each_argument,
  validate_slots,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-K6MJRMI7.js";
import "./chunk-DFKQJ226.js";

// node_modules/@skeletonlabs/skeleton/utilities/CodeBlock/stores.js
var storeHighlightJs = writable(void 0);

// node_modules/@skeletonlabs/skeleton/utilities/Drawer/stores.js
function drawerService() {
  const { subscribe: subscribe2, set, update } = writable({});
  return {
    subscribe: subscribe2,
    set,
    update,
    /** Open the drawer. */
    open: (newSettings) => update(() => {
      return { open: true, ...newSettings };
    }),
    /** Close the drawer. */
    close: () => update((d) => {
      d.open = false;
      return d;
    })
  };
}
var drawerStore = drawerService();

// node_modules/@skeletonlabs/skeleton/utilities/Modal/stores.js
function modalService() {
  const { subscribe: subscribe2, set, update } = writable([]);
  return {
    subscribe: subscribe2,
    set,
    update,
    /** Append to end of queue. */
    trigger: (modal) => update((mStore) => {
      mStore.push(modal);
      return mStore;
    }),
    /**  Remove first item in queue. */
    close: () => update((mStore) => {
      if (mStore.length > 0)
        mStore.shift();
      return mStore;
    }),
    /** Remove all items from queue. */
    clear: () => set([])
  };
}
var modalStore = modalService();

// node_modules/@skeletonlabs/skeleton/utilities/Toast/stores.js
var toastDefaults = { message: "Missing Toast Message", autohide: true, timeout: 5e3 };
function randomUUID() {
  const random = Math.random();
  return Number(random).toString(32);
}
function handleAutoHide(toast) {
  if (toast.autohide === true) {
    setTimeout(() => {
      toastStore.close(toast.id);
    }, toast.timeout);
  }
}
function toastService() {
  const { subscribe: subscribe2, set, update } = writable([]);
  return {
    subscribe: subscribe2,
    /** Add a new toast to the queue. */
    trigger: (toast) => update((tStore) => {
      const id = randomUUID();
      let classes = toast.classes ?? "";
      switch (toast.preset) {
        case "primary":
          classes += "!bg-primary-500 text-on-primary-token";
          break;
        case "secondary":
          classes += "!bg-secondary-500 text-on-secondary-token";
          break;
        case "tertiary":
          classes += "!bg-tertiary-500 text-on-tertiary-token";
          break;
        case "success":
          classes += "!bg-success-500 text-on-success-token";
          break;
        case "warning":
          classes += "!bg-warning-500 text-on-warning-token";
          break;
        case "error":
          classes += "!bg-error-500 text-on-error-token";
          break;
      }
      const tMerged = { ...toastDefaults, ...toast, id, classes };
      tStore.push(tMerged);
      handleAutoHide(tMerged);
      return tStore;
    }),
    /** Remove first toast in queue */
    close: (id) => update((tStore) => {
      if (tStore.length > 0) {
        const index = tStore.findIndex((t) => t.id === id);
        tStore.splice(index, 1);
      }
      return tStore;
    }),
    /** Remove all toasts from queue */
    clear: () => set([])
  };
}
var toastStore = toastService();

// node_modules/@skeletonlabs/skeleton/utilities/LocalStorageStore/LocalStorageStore.js
var stores = {};
function getStorage(type) {
  return type === "local" ? localStorage : sessionStorage;
}
function localStorageStore(key, initialValue, options) {
  const serializer = (options == null ? void 0 : options.serializer) ?? JSON;
  const storageType = (options == null ? void 0 : options.storage) ?? "local";
  const browser = typeof window !== "undefined" && typeof document !== "undefined";
  function updateStorage(key2, value) {
    if (!browser)
      return;
    getStorage(storageType).setItem(key2, serializer.stringify(value));
  }
  if (!stores[key]) {
    const store = writable(initialValue, (set2) => {
      const json = browser ? getStorage(storageType).getItem(key) : null;
      if (json) {
        set2(serializer.parse(json));
      }
      if (browser) {
        const handleStorage = (event) => {
          if (event.key === key)
            set2(event.newValue ? serializer.parse(event.newValue) : null);
        };
        window.addEventListener("storage", handleStorage);
        return () => window.removeEventListener("storage", handleStorage);
      }
    });
    const { subscribe: subscribe2, set } = store;
    stores[key] = {
      set(value) {
        updateStorage(key, value);
        set(value);
      },
      update(updater) {
        const value = updater(get_store_value(store));
        updateStorage(key, value);
        set(value);
      },
      subscribe: subscribe2
    };
  }
  return stores[key];
}

// node_modules/@skeletonlabs/skeleton/utilities/LightSwitch/stores.js
var storePrefersDarkScheme = localStorageStore("storePrefersDarkScheme", false);
var storeLightSwitch = localStorageStore("storeLightSwitch", void 0);

// node_modules/@skeletonlabs/skeleton/utilities/DataTable/actions.js
function tableInteraction(node) {
  const classAsc = "table-sort-asc";
  const classDsc = "table-sort-dsc";
  const onClick = (e) => {
    if (!(e.target instanceof Element))
      return;
    const sortTarget = e.target;
    const targetAscSorted = sortTarget.classList.contains(classAsc);
    const sortTargetKey = sortTarget.getAttribute("data-sort");
    const elemAsc = node.querySelector(`.${classAsc}`);
    if (elemAsc)
      elemAsc.classList.remove(classAsc);
    const elemDsc = node.querySelector(`.${classDsc}`);
    if (elemDsc)
      elemDsc.classList.remove(classDsc);
    if (sortTargetKey) {
      const classToApply = targetAscSorted ? classDsc : classAsc;
      e.target.classList.add(classToApply);
    }
  };
  node.addEventListener("click", onClick);
  return {
    destroy() {
      node.removeEventListener("click", onClick);
    }
  };
}
function tableA11y(node) {
  const keyWhitelist = ["ArrowRight", "ArrowUp", "ArrowLeft", "ArrowDown", "Home", "End"];
  const onKeyDown = (event) => {
    if (keyWhitelist.includes(event.code)) {
      event.preventDefault();
      switch (event.code) {
        case "ArrowUp":
          a11ySetActiveCell(node, 0, -1);
          break;
        case "ArrowDown":
          a11ySetActiveCell(node, 0, 1);
          break;
        case "ArrowLeft":
          a11ySetActiveCell(node, -1, 0);
          break;
        case "ArrowRight":
          a11ySetActiveCell(node, 1, 0);
          break;
        case "Home":
          a11yJumpToOuterColumn(node, "first");
          break;
        case "End":
          a11yJumpToOuterColumn(node, "last");
          break;
        default:
          break;
      }
    }
  };
  node.addEventListener("keydown", onKeyDown);
  return {
    destroy() {
      node.removeEventListener("keydown", onKeyDown);
    }
  };
}
function a11ySetActiveCell(node, x, y) {
  const focusedElem = document.activeElement;
  if (!focusedElem || !focusedElem.parentElement || !focusedElem.parentElement.ariaRowIndex || !focusedElem.ariaColIndex)
    return;
  const focusedElemRowIndex = parseInt(focusedElem.parentElement.ariaRowIndex);
  const focusedElemColIndex = parseInt(focusedElem.ariaColIndex);
  const targetRowElement = node.querySelector(`[aria-rowindex="${focusedElemRowIndex + y}"]`);
  if (targetRowElement !== null) {
    const targetColElement = targetRowElement.querySelector(`[aria-colindex="${focusedElemColIndex + x}"]`);
    if (targetColElement !== null)
      targetColElement.focus();
  }
}
function a11yGetTargetElem(node) {
  const focusedElem = document.activeElement;
  if (!focusedElem || !focusedElem.parentElement || !focusedElem.parentElement.ariaRowIndex)
    return null;
  const focusedElemRowIndex = parseInt(focusedElem.parentElement.ariaRowIndex);
  return node.querySelector(`[aria-rowindex="${focusedElemRowIndex}"]`);
}
function a11yJumpToOuterColumn(node, type = "first") {
  const targetRowElement = a11yGetTargetElem(node);
  if (targetRowElement === null)
    return;
  const lastIndex = targetRowElement.children.length;
  const selected = type === "first" ? 1 : lastIndex;
  const targetColElement = targetRowElement.querySelector(`[aria-colindex="${selected}"]`);
  if (targetColElement === null)
    return;
  targetColElement.focus();
}

// node_modules/@skeletonlabs/skeleton/utilities/DataTable/DataTable.js
function createDataTableStore(source, options = {}) {
  const modifiedList = source.map((rowObj) => ({ ...rowObj, dataTableChecked: false }));
  const { subscribe: subscribe2, set, update } = writable({
    source,
    base: modifiedList,
    filtered: modifiedList,
    sortState: { lastKey: "", asc: true },
    selection: [],
    search: options.search ?? "",
    sort: options.sort ?? "",
    pagination: options.pagination
  });
  return {
    subscribe: subscribe2,
    set,
    /** Sets a new data source while maintaining the state of the original source */
    updateSource: (data) => update((model) => {
      model.source = data;
      model.base = data.map((row, i) => {
        var _a;
        return { ...row, dataTableChecked: ((_a = model.base[i]) == null ? void 0 : _a.dataTableChecked) ?? false };
      });
      return { ...model, filtered: model.base };
    }),
    /** Triggered by the "select all" checkbox to toggle all row selection. */
    selectAll: (checked) => {
      update((model) => {
        model.base.forEach((row) => {
          row.dataTableChecked = checked;
          return row;
        });
        return model;
      });
    },
    /** Allows you to dynamically pre-select rows on-demand. */
    select: (key, valuesArr) => {
      update((model) => {
        model.filtered.map((row) => {
          if (valuesArr.includes(row[key]))
            row.dataTableChecked = true;
          return row;
        });
        return model;
      });
    },
    /** Listens for clicks to a table heading with `data-sort` attribute. Updates `$dataTableModel.sort`. */
    sort: (event) => {
      update((model) => {
        if (!(event.target instanceof Element))
          return model;
        const newSortKey = event.target.getAttribute("data-sort");
        if (newSortKey !== "" && newSortKey === model.sortState.lastKey)
          model.sortState.asc = !model.sortState.asc;
        model.sortState.lastKey = newSortKey;
        model.sort = newSortKey ?? "";
        return model;
      });
    }
  };
}
function dataTableHandler(model) {
  searchHandler(model);
  selectionHandler(model);
  sortHandler(model);
  paginationHandler(model);
}
function searchHandler(store) {
  store.filtered = store.base.filter((rowObj) => {
    var _a;
    const formattedSearchTerm = ((_a = store.search) == null ? void 0 : _a.toLowerCase()) || "";
    return Object.values(rowObj).join(" ").toLowerCase().includes(formattedSearchTerm);
  });
}
function selectionHandler(store) {
  store.selection = store.base.filter((row) => row.dataTableChecked === true);
}
function sortHandler(store) {
  if (!store.sort)
    return;
  store.sortState.asc ? sortOrder("asc", store) : sortOrder("dsc", store);
}
function sortOrder(order, store) {
  const key = store.sort;
  store.filtered = store.base.sort((x, y) => {
    if (order === "dsc")
      [x, y] = [y, x];
    if (typeof x[key] === "string" && typeof y[key] === "string") {
      return String(x[key]).localeCompare(String(y[key]));
    } else {
      const a = x[key];
      const b = y[key];
      return a < b ? -1 : a > b ? 1 : 0;
    }
  });
}
function paginationHandler(store) {
  if (store.pagination) {
    const filtered = store.base.slice(
      store.pagination.offset * store.pagination.limit,
      // start
      store.pagination.offset * store.pagination.limit + store.pagination.limit
      // end
    );
    if (store.search !== "") {
      store.filtered = store.filtered.slice(0, store.pagination.limit);
      store.pagination.size = store.filtered.length;
      store.pagination.offset = 0;
    } else {
      store.filtered = filtered;
      store.pagination.size = store.base.length;
    }
  }
}

// node_modules/@skeletonlabs/skeleton/components/Table/utils.js
function tableSourceMapper(source, keys) {
  return source.map((row) => {
    const mappedRow = {};
    keys.forEach((key) => mappedRow[key] = row[key]);
    return mappedRow;
  });
}
function tableSourceValues(source) {
  return source.map((row) => Object.values(row));
}
function tableMapperValues(source, keys) {
  return tableSourceValues(tableSourceMapper(source, keys));
}

// node_modules/@skeletonlabs/skeleton/actions/Clipboard/clipboard.js
function clipboard(node, args) {
  const onClick = () => {
    if (typeof args === "object") {
      if (Object.prototype.hasOwnProperty.call(args, "element")) {
        const element2 = document.querySelector(`[data-clipboard="${args.element}"]`);
        copyToClipboard(element2 == null ? void 0 : element2.innerHTML);
        return;
      }
      if (Object.prototype.hasOwnProperty.call(args, "input")) {
        const input = document.querySelector(`[data-clipboard="${args.input}"]`);
        copyToClipboard(input == null ? void 0 : input.value);
        return;
      }
    }
    copyToClipboard(args);
  };
  node.addEventListener("click", onClick);
  return {
    update(newArgs) {
      args = newArgs;
    },
    destroy() {
      node.removeEventListener("click", onClick);
    }
  };
}
function copyToClipboard(data) {
  navigator.clipboard.writeText(String(data));
}

// node_modules/@skeletonlabs/skeleton/actions/Filters/filter.js
function filter(node, filterName) {
  if (filterName === void 0)
    return;
  const applyFilter = () => {
    const isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
    if (isFirefox) {
      return;
    }
    node.setAttribute("style", `filter: url("#${filterName}")`);
  };
  applyFilter();
  return {
    update(newArgs) {
      filterName = newArgs;
      applyFilter();
    }
  };
}

// node_modules/@skeletonlabs/skeleton/actions/FocusTrap/focusTrap.js
function focusTrap(node, enabled) {
  const elemWhitelist = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
  let elemFirst;
  let elemLast;
  function onFirstElemKeydown(e) {
    if (e.shiftKey && e.code === "Tab") {
      e.preventDefault();
      elemLast.focus();
    }
  }
  function onLastElemKeydown(e) {
    if (!e.shiftKey && e.code === "Tab") {
      e.preventDefault();
      elemFirst.focus();
    }
  }
  const onInit = () => {
    if (enabled === false)
      return;
    const focusableElems = Array.from(node.querySelectorAll(elemWhitelist));
    if (focusableElems.length) {
      elemFirst = focusableElems[0];
      elemLast = focusableElems[focusableElems.length - 1];
      elemFirst.focus();
      elemFirst.addEventListener("keydown", onFirstElemKeydown);
      elemLast.addEventListener("keydown", onLastElemKeydown);
    }
  };
  onInit();
  function onDestory() {
    if (elemFirst)
      elemFirst.removeEventListener("keydown", onFirstElemKeydown);
    if (elemLast)
      elemLast.removeEventListener("keydown", onLastElemKeydown);
  }
  return {
    update(newArgs) {
      enabled = newArgs;
      newArgs ? onInit() : onDestory();
    },
    destroy() {
      onDestory();
    }
  };
}

// node_modules/@skeletonlabs/skeleton/utilities/Menu/menu.js
function menu(node, args) {
  const elemMenu = document.querySelector(`[data-menu="${args.menu}"]`);
  if (!elemMenu)
    return;
  const elemWhitelist = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
  let activeFocusIdx;
  let focusableElems;
  const onInit = () => {
    autoUpdateOrigin();
    elemMenu.setAttribute("role", "menu");
  };
  const menuOpen = (openWithFocus = false) => {
    var _a;
    elemMenu.style.display = "block";
    stateEventHandler(true);
    focusableElems = Array.from(elemMenu.querySelectorAll(elemWhitelist));
    activeFocusIdx = -1;
    if (openWithFocus) {
      activeFocusIdx = 0;
      (_a = focusableElems[0]) == null ? void 0 : _a.focus();
    }
  };
  const menuClose = () => {
    elemMenu.style.display = "none";
    stateEventHandler(false);
  };
  const stateEventHandler = (state) => {
    if (args.state)
      args.state({ menu: args.menu, state });
  };
  const toggleMenu = () => {
    if (elemMenu.style.display != "block") {
      autoUpdateOrigin();
      menuOpen();
    } else {
      menuClose();
    }
  };
  const onWindowClick = (event) => {
    args.interactive === true ? interactiveClickHandler(event) : standardClickHandler(event);
  };
  const standardClickHandler = (event) => {
    const outsideNode = node && !node.contains(event.target);
    if (outsideNode) {
      menuClose();
    } else {
      toggleMenu();
    }
  };
  const interactiveClickHandler = (event) => {
    const outsideNode = node && !node.contains(event.target);
    const outsideMenu = elemMenu && !elemMenu.contains(event.target);
    if (!outsideNode) {
      toggleMenu();
    } else if (outsideNode && outsideMenu) {
      menuClose();
    }
  };
  const autoUpdateOrigin = () => {
    if (!args.fixed && !elemMenu.classList.contains("hidden")) {
      const elemTriggerBounds = node.getBoundingClientRect();
      const vert = elemTriggerBounds.y < window.innerHeight / 2 ? "t" : "b";
      const horz = elemTriggerBounds.x < window.innerWidth / 2 ? "l" : "r";
      elemMenu.classList.remove("menu-tl", "menu-tr", "menu-bl", "menu-br");
      elemMenu.classList.add(`menu-${vert}${horz}`);
    }
  };
  const onTriggerKeyDown = (event) => {
    const key = event.key;
    if (key === "Enter" || key === "Space") {
      event.preventDefault();
      toggleMenu();
    }
  };
  const onWindowKeyDown = (event) => {
    var _a, _b, _c;
    const key = event.key;
    if (elemMenu.style.display === "none")
      return;
    if (key === "Escape" || key === "Tab") {
      event.preventDefault();
      menuClose();
      node.focus();
    } else if (key === "ArrowDown") {
      event.preventDefault();
      if (activeFocusIdx < focusableElems.length - 1) {
        activeFocusIdx += 1;
        (_a = focusableElems[activeFocusIdx]) == null ? void 0 : _a.focus();
      }
    } else if (key === "ArrowUp") {
      event.preventDefault();
      if (activeFocusIdx > 0) {
        activeFocusIdx -= 1;
        (_b = focusableElems[activeFocusIdx]) == null ? void 0 : _b.focus();
      } else if (focusableElems.length && activeFocusIdx === -1) {
        event.preventDefault();
        activeFocusIdx = focusableElems.length - 1;
        (_c = focusableElems[activeFocusIdx]) == null ? void 0 : _c.focus();
      }
    }
  };
  onInit();
  window.addEventListener("resize", autoUpdateOrigin, true);
  window.addEventListener("click", onWindowClick, true);
  window.addEventListener("keydown", onWindowKeyDown, true);
  node.addEventListener("keydown", onTriggerKeyDown);
  node.addEventListener("change", (e) => {
    console.log(e);
  });
  return {
    update: (newArgs) => {
      args = newArgs;
    },
    destroy: () => {
      window.removeEventListener("resize", onWindowClick, true);
      window.removeEventListener("click", onWindowClick, true);
      window.removeEventListener("keydown", onWindowKeyDown, true);
      node.removeEventListener("keydown", onTriggerKeyDown);
    }
  };
}

// node_modules/@skeletonlabs/skeleton/utilities/Tooltip/tooltip.js
function tooltip(node, args) {
  const animDuration = 150;
  let elemTooltip;
  const {
    content = "(tooltip)",
    position = "top",
    inline = true,
    // Regions
    regionContainer = "regionContainer",
    regionTooltip = "regionTooltip",
    regionArrow = "regionArrow"
  } = args;
  const createElemContainer = () => {
    var _a;
    const elemContainer = document.createElement(inline ? "span" : "div");
    elemContainer.classList.add("tooltip-container", "relative", regionContainer);
    (_a = node.parentNode) == null ? void 0 : _a.insertBefore(elemContainer, node);
    elemContainer.appendChild(node);
  };
  createElemContainer();
  const createElemTooltip = () => {
    var _a;
    elemTooltip = document.createElement("div");
    elemTooltip.classList.add("tooltip", `tooltip-${position}`, "hidden", regionTooltip);
    if (args.background) {
      elemTooltip.classList.add(args.background);
    }
    if (args.color)
      elemTooltip.classList.add(args.color);
    if (args.width)
      elemTooltip.classList.add(args.width);
    if (args.padding)
      elemTooltip.classList.add(args.padding);
    if (args.shadow)
      elemTooltip.classList.add(args.shadow);
    if (args.rounded)
      elemTooltip.classList.add(args.rounded);
    elemTooltip.setAttribute("role", "tooltip");
    elemTooltip.setAttribute("data-testid", "tooltip");
    elemTooltip.innerHTML = content;
    (_a = node.parentNode) == null ? void 0 : _a.insertBefore(elemTooltip, node);
  };
  createElemTooltip();
  const createElemArrow = () => {
    const elemArrow = document.createElement("div");
    elemArrow.classList.add(`tooltip-arrow-${position}`, regionArrow);
    if (args.background)
      elemArrow.classList.add(args.background);
    elemTooltip.append(elemArrow);
  };
  createElemArrow();
  const onMouseEnter = () => {
    elemTooltip.classList.remove("hidden");
    setTimeout(() => {
      elemTooltip.classList.add("!opacity-100");
    }, animDuration);
    stateEventHandler(true);
  };
  const onMouseLeave = () => {
    elemTooltip.classList.remove("!opacity-100");
    setTimeout(() => {
      elemTooltip.classList.add("hidden");
    }, animDuration);
    stateEventHandler(false);
  };
  const stateEventHandler = (state) => {
    if (args.state)
      args.state({ trigger: node, state });
  };
  const onWindowKeyDown = (event) => {
    if (event.code === "Escape")
      onMouseLeave();
  };
  node.addEventListener("mouseenter", onMouseEnter);
  node.addEventListener("mouseleave", onMouseLeave);
  window.addEventListener("keydown", onWindowKeyDown);
  return {
    update(newArgs) {
      args = newArgs;
    },
    destroy() {
      node.removeEventListener("mouseenter", onMouseEnter);
      node.removeEventListener("mouseleave", onMouseLeave);
      window.removeEventListener("keydown", onWindowKeyDown);
    }
  };
}

// node_modules/@skeletonlabs/skeleton/components/Accordion/AccordionGroup.svelte
var file = "node_modules/@skeletonlabs/skeleton/components/Accordion/AccordionGroup.svelte";
function create_fragment(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "accordion-group " + /*classesBase*/
      ctx[1]);
      attr_dev(div, "data-testid", "accordion-group");
      add_location(div, file, 30, 0, 889);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[9](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesBase*/
      2 && div_class_value !== (div_class_value = "accordion-group " + /*classesBase*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase = "rounded-container-token";
function instance($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionGroup", slots, ["default"]);
  let { collapse = true } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { spacing = "space-y-4" } = $$props;
  let { padding = "px-4 py-2" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  setContext("hover", hover);
  setContext("spacing", spacing);
  setContext("padding", padding);
  setContext("rounded", rounded);
  let elemAccordian;
  onMount(() => {
    if (collapse) {
      const details = Array.from(elemAccordian.querySelectorAll("details"));
      details.forEach((detail) => {
        detail.addEventListener("click", (e) => {
          const active = details.find((d) => d.open);
          if (!e.currentTarget.open && active)
            active.open = false;
        });
      });
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemAccordian = $$value;
      $$invalidate(0, elemAccordian);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("collapse" in $$new_props)
      $$invalidate(2, collapse = $$new_props.collapse);
    if ("hover" in $$new_props)
      $$invalidate(3, hover = $$new_props.hover);
    if ("spacing" in $$new_props)
      $$invalidate(4, spacing = $$new_props.spacing);
    if ("padding" in $$new_props)
      $$invalidate(5, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(6, rounded = $$new_props.rounded);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    setContext,
    collapse,
    hover,
    spacing,
    padding,
    rounded,
    cBase,
    elemAccordian,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
    if ("collapse" in $$props)
      $$invalidate(2, collapse = $$new_props.collapse);
    if ("hover" in $$props)
      $$invalidate(3, hover = $$new_props.hover);
    if ("spacing" in $$props)
      $$invalidate(4, spacing = $$new_props.spacing);
    if ("padding" in $$props)
      $$invalidate(5, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(6, rounded = $$new_props.rounded);
    if ("elemAccordian" in $$props)
      $$invalidate(0, elemAccordian = $$new_props.elemAccordian);
    if ("classesBase" in $$props)
      $$invalidate(1, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classesBase = `${cBase} ${spacing} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    elemAccordian,
    classesBase,
    collapse,
    hover,
    spacing,
    padding,
    rounded,
    $$scope,
    slots,
    div_binding
  ];
}
var AccordionGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      collapse: 2,
      hover: 3,
      spacing: 4,
      padding: 5,
      rounded: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionGroup",
      options,
      id: create_fragment.name
    });
  }
  get collapse() {
    throw new Error("<AccordionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collapse(value) {
    throw new Error("<AccordionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AccordionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AccordionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AccordionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AccordionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<AccordionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<AccordionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<AccordionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<AccordionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionGroup_default = AccordionGroup;

// node_modules/@skeletonlabs/skeleton/components/Accordion/AccordionItem.svelte
var file2 = "node_modules/@skeletonlabs/skeleton/components/Accordion/AccordionItem.svelte";
function add_css(target) {
  append_styles(target, "svelte-kkbihn", "details.svelte-kkbihn summary.svelte-kkbihn::-webkit-details-marker{display:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWNjb3JkaW9uSXRlbS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBcURDLHFCQUFPLENBQUMscUJBQU8sd0JBQXdCLEFBQUMsQ0FBQSxBQUN2QyxPQUFPLENBQUUsSUFBSSxBQUNkLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQWNjb3JkaW9uSXRlbS5zdmVsdGUiXX0= */");
}
var get_content_slot_changes = (dirty) => ({});
var get_content_slot_context = (ctx) => ({});
var get_summary_slot_changes = (dirty) => ({});
var get_summary_slot_context = (ctx) => ({});
var get_lead_slot_changes = (dirty) => ({});
var get_lead_slot_context = (ctx) => ({});
function create_if_block(ctx) {
  let div;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[16].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_lead_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "accordion-summary-lead");
      add_location(div, file2, 31, 20, 1277);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_lead_slot_changes
            ),
            get_lead_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(32:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(summary)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(summary)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(34:83) (summary)",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(content)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(content)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(47:23) (content)",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let details;
  let summary;
  let t0;
  let div0;
  let t1;
  let div1;
  let svg;
  let path;
  let div1_class_value;
  let summary_class_value;
  let t2;
  let div2;
  let div2_class_value;
  let details_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    ctx[7].lead && create_if_block(ctx)
  );
  const summary_slot_template = (
    /*#slots*/
    ctx[16].summary
  );
  const summary_slot = create_slot(
    summary_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_summary_slot_context
  );
  const summary_slot_or_fallback = summary_slot || fallback_block_1(ctx);
  const content_slot_template = (
    /*#slots*/
    ctx[16].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_content_slot_context
  );
  const content_slot_or_fallback = content_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      details = element("details");
      summary = element("summary");
      if (if_block)
        if_block.c();
      t0 = space();
      div0 = element("div");
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.c();
      t1 = space();
      div1 = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      t2 = space();
      div2 = element("div");
      if (content_slot_or_fallback)
        content_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      details = claim_element(nodes, "DETAILS", { class: true, "data-testid": true });
      var details_nodes = children(details);
      summary = claim_element(details_nodes, "SUMMARY", {
        id: true,
        class: true,
        "aria-expanded": true,
        "aria-controls": true
      });
      var summary_nodes = children(summary);
      if (if_block)
        if_block.l(summary_nodes);
      t0 = claim_space(summary_nodes);
      div0 = claim_element(summary_nodes, "DIV", { class: true, role: true });
      var div0_nodes = children(div0);
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(summary_nodes);
      div1 = claim_element(summary_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      svg = claim_svg_element(div1_nodes, "svg", { xmlns: true, viewBox: true, class: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      summary_nodes.forEach(detach_dev);
      t2 = claim_space(details_nodes);
      div2 = claim_element(details_nodes, "DIV", {
        id: true,
        class: true,
        role: true,
        "aria-labelledby": true
      });
      var div2_nodes = children(div2);
      if (content_slot_or_fallback)
        content_slot_or_fallback.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      details_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "accordion-summary-text flex-auto");
      attr_dev(div0, "role", "button");
      add_location(div0, file2, 33, 2, 1369);
      attr_dev(path, "d", "M137.4 374.6c12.5 12.5 32.8 12.5 45.3 0l128-128c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8L32 192c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l128 128z");
      add_location(path, file2, 37, 4, 1633);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 320 512");
      attr_dev(svg, "class", "opacity-50");
      add_location(svg, file2, 36, 3, 1547);
      attr_dev(div1, "class", div1_class_value = "accordion-summary-caret " + /*classesIcon*/
      ctx[4]);
      add_location(div1, file2, 35, 2, 1492);
      attr_dev(
        summary,
        "id",
        /*summaryId*/
        ctx[1]
      );
      attr_dev(summary, "class", summary_class_value = "accordion-summary " + /*classesSummary*/
      ctx[5] + " svelte-kkbihn");
      attr_dev(
        summary,
        "aria-expanded",
        /*open*/
        ctx[0]
      );
      attr_dev(
        summary,
        "aria-controls",
        /*contentId*/
        ctx[2]
      );
      add_location(summary, file2, 29, 1, 1120);
      attr_dev(
        div2,
        "id",
        /*contentId*/
        ctx[2]
      );
      attr_dev(div2, "class", div2_class_value = "accordion-content " + /*classesContent*/
      ctx[3]);
      attr_dev(div2, "role", "region");
      attr_dev(
        div2,
        "aria-labelledby",
        /*summaryId*/
        ctx[1]
      );
      add_location(div2, file2, 45, 1, 1864);
      attr_dev(details, "class", details_class_value = "accordion-item " + /*classesDetails*/
      ctx[6] + " svelte-kkbihn");
      attr_dev(details, "data-testid", "accordion-item");
      add_location(details, file2, 27, 0, 961);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, details, anchor);
      append_hydration_dev(details, summary);
      if (if_block)
        if_block.m(summary, null);
      append_hydration_dev(summary, t0);
      append_hydration_dev(summary, div0);
      if (summary_slot_or_fallback) {
        summary_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(summary, t1);
      append_hydration_dev(summary, div1);
      append_hydration_dev(div1, svg);
      append_hydration_dev(svg, path);
      append_hydration_dev(details, t2);
      append_hydration_dev(details, div2);
      if (content_slot_or_fallback) {
        content_slot_or_fallback.m(div2, null);
      }
      details.open = /*open*/
      ctx[0];
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            details,
            "toggle",
            /*details_toggle_handler*/
            ctx[22]
          ),
          listen_dev(
            details,
            "click",
            /*click_handler*/
            ctx[17],
            false,
            false,
            false
          ),
          listen_dev(
            details,
            "keydown",
            /*keydown_handler*/
            ctx[18],
            false,
            false,
            false
          ),
          listen_dev(
            details,
            "keyup",
            /*keyup_handler*/
            ctx[19],
            false,
            false,
            false
          ),
          listen_dev(
            details,
            "keypress",
            /*keypress_handler*/
            ctx[20],
            false,
            false,
            false
          ),
          listen_dev(
            details,
            "toggle",
            /*toggle_handler*/
            ctx[21],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[7].lead
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(summary, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (summary_slot) {
        if (summary_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            summary_slot,
            summary_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              summary_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_summary_slot_changes
            ),
            get_summary_slot_context
          );
        }
      }
      if (!current || dirty & /*classesIcon*/
      16 && div1_class_value !== (div1_class_value = "accordion-summary-caret " + /*classesIcon*/
      ctx2[4])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*summaryId*/
      2) {
        attr_dev(
          summary,
          "id",
          /*summaryId*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*classesSummary*/
      32 && summary_class_value !== (summary_class_value = "accordion-summary " + /*classesSummary*/
      ctx2[5] + " svelte-kkbihn")) {
        attr_dev(summary, "class", summary_class_value);
      }
      if (!current || dirty & /*open*/
      1) {
        attr_dev(
          summary,
          "aria-expanded",
          /*open*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*contentId*/
      4) {
        attr_dev(
          summary,
          "aria-controls",
          /*contentId*/
          ctx2[2]
        );
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_content_slot_changes
            ),
            get_content_slot_context
          );
        }
      }
      if (!current || dirty & /*contentId*/
      4) {
        attr_dev(
          div2,
          "id",
          /*contentId*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*classesContent*/
      8 && div2_class_value !== (div2_class_value = "accordion-content " + /*classesContent*/
      ctx2[3])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*summaryId*/
      2) {
        attr_dev(
          div2,
          "aria-labelledby",
          /*summaryId*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*classesDetails*/
      64 && details_class_value !== (details_class_value = "accordion-item " + /*classesDetails*/
      ctx2[6] + " svelte-kkbihn")) {
        attr_dev(details, "class", details_class_value);
      }
      if (dirty & /*open*/
      1) {
        details.open = /*open*/
        ctx2[0];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(summary_slot_or_fallback, local);
      transition_in(content_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(summary_slot_or_fallback, local);
      transition_out(content_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(details);
      if (if_block)
        if_block.d();
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.d(detaching);
      if (content_slot_or_fallback)
        content_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBaseDetails = "";
var cBaseSummary = "list-none flex items-center space-x-4 cursor-pointer";
var cBaseIcon = "flex justify-center items-center w-3 fill-black dark:fill-white transition-all duration-[100ms]";
function instance2($$self, $$props, $$invalidate) {
  let classesDetails;
  let classesSummary;
  let classesIconState;
  let classesIcon;
  let classesContent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["lead", "summary", "content"]);
  const $$slots = compute_slots(slots);
  let { open = false } = $$props;
  let { summaryId = "" } = $$props;
  let { contentId = "" } = $$props;
  let { regionSummary = "" } = $$props;
  let { regionContent = "" } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { spacing = getContext("spacing") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function toggle_handler(event) {
    bubble.call(this, $$self, event);
  }
  function details_toggle_handler() {
    open = this.open;
    $$invalidate(0, open);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("summaryId" in $$new_props)
      $$invalidate(1, summaryId = $$new_props.summaryId);
    if ("contentId" in $$new_props)
      $$invalidate(2, contentId = $$new_props.contentId);
    if ("regionSummary" in $$new_props)
      $$invalidate(8, regionSummary = $$new_props.regionSummary);
    if ("regionContent" in $$new_props)
      $$invalidate(9, regionContent = $$new_props.regionContent);
    if ("hover" in $$new_props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("spacing" in $$new_props)
      $$invalidate(11, spacing = $$new_props.spacing);
    if ("padding" in $$new_props)
      $$invalidate(12, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    open,
    summaryId,
    contentId,
    regionSummary,
    regionContent,
    hover,
    spacing,
    padding,
    rounded,
    cBaseDetails,
    cBaseSummary,
    cBaseIcon,
    classesContent,
    classesIconState,
    classesIcon,
    classesSummary,
    classesDetails
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("summaryId" in $$props)
      $$invalidate(1, summaryId = $$new_props.summaryId);
    if ("contentId" in $$props)
      $$invalidate(2, contentId = $$new_props.contentId);
    if ("regionSummary" in $$props)
      $$invalidate(8, regionSummary = $$new_props.regionSummary);
    if ("regionContent" in $$props)
      $$invalidate(9, regionContent = $$new_props.regionContent);
    if ("hover" in $$props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("spacing" in $$props)
      $$invalidate(11, spacing = $$new_props.spacing);
    if ("padding" in $$props)
      $$invalidate(12, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("classesContent" in $$props)
      $$invalidate(3, classesContent = $$new_props.classesContent);
    if ("classesIconState" in $$props)
      $$invalidate(14, classesIconState = $$new_props.classesIconState);
    if ("classesIcon" in $$props)
      $$invalidate(4, classesIcon = $$new_props.classesIcon);
    if ("classesSummary" in $$props)
      $$invalidate(5, classesSummary = $$new_props.classesSummary);
    if ("classesDetails" in $$props)
      $$invalidate(6, classesDetails = $$new_props.classesDetails);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesDetails = `${cBaseDetails} ${spacing} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*padding, rounded, hover, regionSummary*/
    13568) {
      $:
        $$invalidate(5, classesSummary = `${cBaseSummary} ${padding} ${rounded} ${hover} ${regionSummary}`);
    }
    if ($$self.$$.dirty & /*open*/
    1) {
      $:
        $$invalidate(14, classesIconState = open ? "-rotate-180" : "");
    }
    if ($$self.$$.dirty & /*classesIconState*/
    16384) {
      $:
        $$invalidate(4, classesIcon = `${cBaseIcon} ${classesIconState}`);
    }
    if ($$self.$$.dirty & /*padding, regionContent*/
    4608) {
      $:
        $$invalidate(3, classesContent = `${padding} ${regionContent}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    open,
    summaryId,
    contentId,
    classesContent,
    classesIcon,
    classesSummary,
    classesDetails,
    $$slots,
    regionSummary,
    regionContent,
    hover,
    spacing,
    padding,
    rounded,
    classesIconState,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    toggle_handler,
    details_toggle_handler
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        open: 0,
        summaryId: 1,
        contentId: 2,
        regionSummary: 8,
        regionContent: 9,
        hover: 10,
        spacing: 11,
        padding: 12,
        rounded: 13
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment2.name
    });
  }
  get open() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get summaryId() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set summaryId(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentId() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentId(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionSummary() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionSummary(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionContent() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionContent(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// node_modules/@skeletonlabs/skeleton/components/AppBar/AppBar.svelte
var file3 = "node_modules/@skeletonlabs/skeleton/components/AppBar/AppBar.svelte";
var get_trail_slot_changes = (dirty) => ({});
var get_trail_slot_context = (ctx) => ({});
var get_lead_slot_changes2 = (dirty) => ({});
var get_lead_slot_context2 = (ctx) => ({});
function create_if_block_1(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[16].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_lead_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-bar-lead " + /*classesLead*/
      ctx[4]);
      add_location(div, file3, 27, 2, 913);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_lead_slot_changes2
            ),
            get_lead_slot_context2
          );
        }
      }
      if (!current || dirty & /*classesLead*/
      16 && div_class_value !== (div_class_value = "app-bar-lead " + /*classesLead*/
      ctx2[4])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(27:1) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let div_class_value;
  let current;
  const trail_slot_template = (
    /*#slots*/
    ctx[16].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_trail_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (trail_slot)
        trail_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-bar-trail " + /*classesTrail*/
      ctx[2]);
      add_location(div, file3, 35, 2, 1117);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (trail_slot) {
        trail_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_trail_slot_changes
            ),
            get_trail_slot_context
          );
        }
      }
      if (!current || dirty & /*classesTrail*/
      4 && div_class_value !== (div_class_value = "app-bar-trail " + /*classesTrail*/
      ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(35:1) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div1;
  let t0;
  let div0;
  let div0_class_value;
  let t1;
  let div1_class_value;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[6].lead && create_if_block_1(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  let if_block1 = (
    /*$$slots*/
    ctx[6].trail && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-labelledby": true
      });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "app-bar-center " + /*classesCenter*/
      ctx[3]);
      add_location(div0, file3, 31, 1, 1012);
      attr_dev(div1, "class", div1_class_value = "app-bar " + /*classesBase*/
      ctx[5]);
      attr_dev(div1, "data-testid", "app-bar");
      attr_dev(div1, "role", "toolbar");
      attr_dev(
        div1,
        "aria-label",
        /*label*/
        ctx[0]
      );
      attr_dev(
        div1,
        "aria-labelledby",
        /*labelledby*/
        ctx[1]
      );
      add_location(div1, file3, 24, 0, 749);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[6].lead
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesCenter*/
      8 && div0_class_value !== (div0_class_value = "app-bar-center " + /*classesCenter*/
      ctx2[3])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*$$slots*/
        ctx2[6].trail
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      32 && div1_class_value !== (div1_class_value = "app-bar " + /*classesBase*/
      ctx2[5])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*label*/
      1) {
        attr_dev(
          div1,
          "aria-label",
          /*label*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*labelledby*/
      2) {
        attr_dev(
          div1,
          "aria-labelledby",
          /*labelledby*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase2 = "flex items-center";
var cLead = "flex-none flex justify-between items-center";
var cCenter = "flex-auto";
var cTrail = "flex-none flex items-center space-x-4";
function instance3($$self, $$props, $$invalidate) {
  let classesBase;
  let classesLead;
  let classesCenter;
  let classesTrail;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppBar", slots, ["lead", "default", "trail"]);
  const $$slots = compute_slots(slots);
  let { background = "bg-surface-100-800-token" } = $$props;
  let { border = "" } = $$props;
  let { padding = "p-4" } = $$props;
  let { shadow = "shadow-lg" } = $$props;
  let { space: space2 = "space-x-4" } = $$props;
  let { slotLead = "" } = $$props;
  let { slotDefault = "" } = $$props;
  let { slotTrail = "" } = $$props;
  let { label = "" } = $$props;
  let { labelledby = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("background" in $$new_props)
      $$invalidate(7, background = $$new_props.background);
    if ("border" in $$new_props)
      $$invalidate(8, border = $$new_props.border);
    if ("padding" in $$new_props)
      $$invalidate(9, padding = $$new_props.padding);
    if ("shadow" in $$new_props)
      $$invalidate(10, shadow = $$new_props.shadow);
    if ("space" in $$new_props)
      $$invalidate(11, space2 = $$new_props.space);
    if ("slotLead" in $$new_props)
      $$invalidate(12, slotLead = $$new_props.slotLead);
    if ("slotDefault" in $$new_props)
      $$invalidate(13, slotDefault = $$new_props.slotDefault);
    if ("slotTrail" in $$new_props)
      $$invalidate(14, slotTrail = $$new_props.slotTrail);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("labelledby" in $$new_props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    background,
    border,
    padding,
    shadow,
    space: space2,
    slotLead,
    slotDefault,
    slotTrail,
    label,
    labelledby,
    cBase: cBase2,
    cLead,
    cCenter,
    cTrail,
    classesTrail,
    classesCenter,
    classesLead,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
    if ("background" in $$props)
      $$invalidate(7, background = $$new_props.background);
    if ("border" in $$props)
      $$invalidate(8, border = $$new_props.border);
    if ("padding" in $$props)
      $$invalidate(9, padding = $$new_props.padding);
    if ("shadow" in $$props)
      $$invalidate(10, shadow = $$new_props.shadow);
    if ("space" in $$props)
      $$invalidate(11, space2 = $$new_props.space);
    if ("slotLead" in $$props)
      $$invalidate(12, slotLead = $$new_props.slotLead);
    if ("slotDefault" in $$props)
      $$invalidate(13, slotDefault = $$new_props.slotDefault);
    if ("slotTrail" in $$props)
      $$invalidate(14, slotTrail = $$new_props.slotTrail);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("labelledby" in $$props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("classesTrail" in $$props)
      $$invalidate(2, classesTrail = $$new_props.classesTrail);
    if ("classesCenter" in $$props)
      $$invalidate(3, classesCenter = $$new_props.classesCenter);
    if ("classesLead" in $$props)
      $$invalidate(4, classesLead = $$new_props.classesLead);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, classesBase = `${cBase2} ${background} ${border} ${padding} ${shadow} ${space2} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*slotLead*/
    4096) {
      $:
        $$invalidate(4, classesLead = `${cLead} ${slotLead}`);
    }
    if ($$self.$$.dirty & /*slotDefault*/
    8192) {
      $:
        $$invalidate(3, classesCenter = `${cCenter} ${slotDefault}`);
    }
    if ($$self.$$.dirty & /*slotTrail*/
    16384) {
      $:
        $$invalidate(2, classesTrail = `${cTrail} ${slotTrail}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    label,
    labelledby,
    classesTrail,
    classesCenter,
    classesLead,
    classesBase,
    $$slots,
    background,
    border,
    padding,
    shadow,
    space2,
    slotLead,
    slotDefault,
    slotTrail,
    $$scope,
    slots
  ];
}
var AppBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      background: 7,
      border: 8,
      padding: 9,
      shadow: 10,
      space: 11,
      slotLead: 12,
      slotDefault: 13,
      slotTrail: 14,
      label: 0,
      labelledby: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppBar",
      options,
      id: create_fragment3.name
    });
  }
  get background() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get space() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set space(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotLead() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotLead(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotDefault() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotDefault(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotTrail() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotTrail(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppBar_default = AppBar;

// node_modules/@skeletonlabs/skeleton/components/AppRail/AppRail.svelte
var file4 = "node_modules/@skeletonlabs/skeleton/components/AppRail/AppRail.svelte";
var get_trail_slot_changes2 = (dirty) => ({});
var get_trail_slot_context2 = (ctx) => ({});
var get_lead_slot_changes3 = (dirty) => ({});
var get_lead_slot_context3 = (ctx) => ({});
function create_fragment4(ctx) {
  let div3;
  let div0;
  let div0_class_value;
  let t0;
  let div1;
  let div1_class_value;
  let t1;
  let div2;
  let div2_class_value;
  let div3_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[12].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_lead_slot_context3
  );
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const trail_slot_template = (
    /*#slots*/
    ctx[12].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_trail_slot_context2
  );
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      if (lead_slot)
        lead_slot.c();
      t0 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      div2 = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (lead_slot)
        lead_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (trail_slot)
        trail_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "app-bar-lead " + /*regionLead*/
      ctx[0]);
      add_location(div0, file4, 24, 1, 828);
      attr_dev(div1, "class", div1_class_value = "app-bar-default " + /*regionDefault*/
      ctx[1]);
      add_location(div1, file4, 26, 1, 919);
      attr_dev(div2, "class", div2_class_value = "app-bar-trail " + /*regionTrail*/
      ctx[2]);
      add_location(div2, file4, 28, 1, 1001);
      attr_dev(div3, "class", div3_class_value = "app-rail " + /*classesBase*/
      ctx[3]);
      add_location(div3, file4, 22, 0, 769);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      if (lead_slot) {
        lead_slot.m(div0, null);
      }
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      if (trail_slot) {
        trail_slot.m(div2, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_lead_slot_changes3
            ),
            get_lead_slot_context3
          );
        }
      }
      if (!current || dirty & /*regionLead*/
      1 && div0_class_value !== (div0_class_value = "app-bar-lead " + /*regionLead*/
      ctx2[0])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*regionDefault*/
      2 && div1_class_value !== (div1_class_value = "app-bar-default " + /*regionDefault*/
      ctx2[1])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_trail_slot_changes2
            ),
            get_trail_slot_context2
          );
        }
      }
      if (!current || dirty & /*regionTrail*/
      4 && div2_class_value !== (div2_class_value = "app-bar-trail " + /*regionTrail*/
      ctx2[2])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*classesBase*/
      8 && div3_class_value !== (div3_class_value = "app-rail " + /*classesBase*/
      ctx2[3])) {
        attr_dev(div3, "class", div3_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      transition_in(default_slot, local);
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      transition_out(default_slot, local);
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (lead_slot)
        lead_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase3 = "grid grid-rows-[auto_1fr_auto] overflow-y-auto";
function instance4($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppRail", slots, ["lead", "default", "trail"]);
  let { selected = writable(void 0) } = $$props;
  let { background = "bg-surface-100-800-token" } = $$props;
  let { active = "bg-primary-active-token" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { width = "w-[70px] sm:w-20" } = $$props;
  let { height = "h-full" } = $$props;
  let { gap = "gap-0" } = $$props;
  let { regionLead = "" } = $$props;
  let { regionDefault = "" } = $$props;
  let { regionTrail = "" } = $$props;
  setContext("selected", selected);
  setContext("active", active);
  setContext("hover", hover);
  $$self.$$set = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selected" in $$new_props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("background" in $$new_props)
      $$invalidate(5, background = $$new_props.background);
    if ("active" in $$new_props)
      $$invalidate(6, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(7, hover = $$new_props.hover);
    if ("width" in $$new_props)
      $$invalidate(8, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(9, height = $$new_props.height);
    if ("gap" in $$new_props)
      $$invalidate(10, gap = $$new_props.gap);
    if ("regionLead" in $$new_props)
      $$invalidate(0, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$new_props)
      $$invalidate(1, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$new_props)
      $$invalidate(2, regionTrail = $$new_props.regionTrail);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    writable,
    selected,
    background,
    active,
    hover,
    width,
    height,
    gap,
    regionLead,
    regionDefault,
    regionTrail,
    cBase: cBase3,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("background" in $$props)
      $$invalidate(5, background = $$new_props.background);
    if ("active" in $$props)
      $$invalidate(6, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(7, hover = $$new_props.hover);
    if ("width" in $$props)
      $$invalidate(8, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(9, height = $$new_props.height);
    if ("gap" in $$props)
      $$invalidate(10, gap = $$new_props.gap);
    if ("regionLead" in $$props)
      $$invalidate(0, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$props)
      $$invalidate(1, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$props)
      $$invalidate(2, regionTrail = $$new_props.regionTrail);
    if ("classesBase" in $$props)
      $$invalidate(3, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classesBase = `${cBase3} ${background} ${width} ${height} ${gap} ${$$props.class || ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    regionLead,
    regionDefault,
    regionTrail,
    classesBase,
    selected,
    background,
    active,
    hover,
    width,
    height,
    gap,
    $$scope,
    slots
  ];
}
var AppRail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      selected: 4,
      background: 5,
      active: 6,
      hover: 7,
      width: 8,
      height: 9,
      gap: 10,
      regionLead: 0,
      regionDefault: 1,
      regionTrail: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppRail",
      options,
      id: create_fragment4.name
    });
  }
  get selected() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLead() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLead(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionDefault() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionDefault(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionTrail() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionTrail(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppRail_default = AppRail;

// node_modules/@skeletonlabs/skeleton/components/AppRail/AppRailTile.svelte
var file5 = "node_modules/@skeletonlabs/skeleton/components/AppRail/AppRailTile.svelte";
function create_if_block3(ctx) {
  let div;
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*label*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*label*/
        ctx[1]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-rail-tile-label " + /*classesLabel*/
      ctx[4]);
      add_location(div, file5, 40, 13, 1525);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label*/
      2)
        set_data_dev(
          t,
          /*label*/
          ctx2[1]
        );
      if (dirty & /*classesLabel*/
      16 && div_class_value !== (div_class_value = "app-rail-tile-label " + /*classesLabel*/
      ctx2[4])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(41:2) {#if label}",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let div;
  let div_class_value;
  let t;
  let svelte_element_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let if_block = (
    /*label*/
    ctx[1] && create_if_block3(ctx)
  );
  let svelte_element_levels = [
    /*prunedRestProps*/
    ctx[7](),
    {
      class: svelte_element_class_value = "app-rail-tile " + /*classesBase*/
      ctx[5]
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*tag*/
        ctx[0]
      );
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*tag*/
        (ctx[0] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      div = claim_element(svelte_element_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t = claim_space(svelte_element_nodes);
      if (if_block)
        if_block.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-rail-tile-icon " + /*regionIcon*/
      ctx[2]);
      add_location(div, file5, 38, 2, 1435);
      if (/-/.test(
        /*tag*/
        ctx[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file5, 36, 1, 1314);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(svelte_element, t);
      if (if_block)
        if_block.m(svelte_element, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*regionIcon*/
      4 && div_class_value !== (div_class_value = "app-rail-tile-icon " + /*regionIcon*/
      ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
      if (
        /*label*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(svelte_element, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        /*prunedRestProps*/
        ctx2[7](),
        (!current || dirty & /*classesBase*/
        32 && svelte_element_class_value !== (svelte_element_class_value = "app-rail-tile " + /*classesBase*/
        ctx2[5])) && { class: svelte_element_class_value }
      ]);
      if (/-/.test(
        /*tag*/
        ctx2[0]
      )) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: '(37:1) <svelte:element this={tag} {...prunedRestProps()} class=\\"app-rail-tile {classesBase}\\">',
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let div;
  let previous_tag = (
    /*tag*/
    ctx[0]
  );
  let current;
  let mounted;
  let dispose;
  validate_dynamic_element(
    /*tag*/
    ctx[0]
  );
  validate_void_dynamic_element(
    /*tag*/
    ctx[0]
  );
  let svelte_element = (
    /*tag*/
    ctx[0] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (svelte_element)
        svelte_element.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (svelte_element)
        svelte_element.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file5, 34, 0, 1162);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (svelte_element)
        svelte_element.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*onClickHandler*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown_handler*/
            ctx[16],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keyup",
            /*keyup_handler*/
            ctx[17],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keypress",
            /*keypress_handler*/
            ctx[18],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*tag*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(div, null);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*tag*/
            ctx2[0]
          );
          validate_void_dynamic_element(
            /*tag*/
            ctx2[0]
          );
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(div, null);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = /*tag*/
      ctx2[0];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (svelte_element)
        svelte_element.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase4 = "unstyled grid place-content-center place-items-center w-full aspect-square space-y-1.5 cursor-pointer";
var cLabel = "text-xs text-center";
function instance5($$self, $$props, $$invalidate) {
  let classesActive;
  let classesBase;
  let classesLabel;
  const omit_props_names = ["value", "tag", "label", "regionIcon", "regionLabel", "selected", "active", "hover"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selected, $$unsubscribe_selected = noop, $$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, ($$value) => $$invalidate(13, $selected = $$value)), selected);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selected());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppRailTile", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { value = void 0 } = $$props;
  let { tag = "button" } = $$props;
  let { label = "" } = $$props;
  let { regionIcon = "" } = $$props;
  let { regionLabel = "" } = $$props;
  let { selected = getContext("selected") } = $$props;
  validate_store(selected, "selected");
  $$subscribe_selected();
  let { active = getContext("active") } = $$props;
  let { hover = getContext("hover") } = $$props;
  function onClickHandler(event) {
    if (!$selected || !value)
      return;
    set_store_value(selected, $selected = value, $selected);
    dispatch("click", event);
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(8, value = $$new_props.value);
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("regionIcon" in $$new_props)
      $$invalidate(2, regionIcon = $$new_props.regionIcon);
    if ("regionLabel" in $$new_props)
      $$invalidate(9, regionLabel = $$new_props.regionLabel);
    if ("selected" in $$new_props)
      $$subscribe_selected($$invalidate(3, selected = $$new_props.selected));
    if ("active" in $$new_props)
      $$invalidate(10, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(11, hover = $$new_props.hover);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    dispatch,
    value,
    tag,
    label,
    regionIcon,
    regionLabel,
    selected,
    active,
    hover,
    cBase: cBase4,
    cLabel,
    onClickHandler,
    prunedRestProps,
    classesLabel,
    classesActive,
    classesBase,
    $selected
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(8, value = $$new_props.value);
    if ("tag" in $$props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("regionIcon" in $$props)
      $$invalidate(2, regionIcon = $$new_props.regionIcon);
    if ("regionLabel" in $$props)
      $$invalidate(9, regionLabel = $$new_props.regionLabel);
    if ("selected" in $$props)
      $$subscribe_selected($$invalidate(3, selected = $$new_props.selected));
    if ("active" in $$props)
      $$invalidate(10, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(11, hover = $$new_props.hover);
    if ("classesLabel" in $$props)
      $$invalidate(4, classesLabel = $$new_props.classesLabel);
    if ("classesActive" in $$props)
      $$invalidate(12, classesActive = $$new_props.classesActive);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selected, value, active*/
    9472) {
      $:
        $$invalidate(12, classesActive = $selected && value && $selected === value ? `${active}` : "");
    }
    $:
      $$invalidate(5, classesBase = `${cBase4} ${hover} ${classesActive} ${$$props.class || ""}`);
    if ($$self.$$.dirty & /*regionLabel*/
    512) {
      $:
        $$invalidate(4, classesLabel = `${cLabel} ${regionLabel}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    tag,
    label,
    regionIcon,
    selected,
    classesLabel,
    classesBase,
    onClickHandler,
    prunedRestProps,
    value,
    regionLabel,
    active,
    hover,
    classesActive,
    $selected,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var AppRailTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      value: 8,
      tag: 0,
      label: 1,
      regionIcon: 2,
      regionLabel: 9,
      selected: 3,
      active: 10,
      hover: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppRailTile",
      options,
      id: create_fragment5.name
    });
  }
  get value() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionIcon() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionIcon(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppRailTile_default = AppRailTile;

// node_modules/@skeletonlabs/skeleton/components/AppShell/AppShell.svelte
var file6 = "node_modules/@skeletonlabs/skeleton/components/AppShell/AppShell.svelte";
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
var get_sidebarRight_slot_changes = (dirty) => ({});
var get_sidebarRight_slot_context = (ctx) => ({});
var get_pageFooter_slot_changes = (dirty) => ({});
var get_pageFooter_slot_context = (ctx) => ({});
var get_pageHeader_slot_changes = (dirty) => ({});
var get_pageHeader_slot_context = (ctx) => ({});
var get_sidebarLeft_slot_changes = (dirty) => ({});
var get_sidebarLeft_slot_context = (ctx) => ({});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_if_block_5(ctx) {
  let header;
  let header_class_value;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[17].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_header_slot_context
  );
  const block = {
    c: function create() {
      header = element("header");
      if (header_slot)
        header_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { id: true, class: true });
      var header_nodes = children(header);
      if (header_slot)
        header_slot.l(header_nodes);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "id", "shell-header");
      attr_dev(header, "class", header_class_value = "flex-none " + /*classesheader*/
      ctx[6]);
      add_location(header, file6, 33, 2, 1112);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      if (header_slot) {
        header_slot.m(header, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      if (!current || dirty & /*classesheader*/
      64 && header_class_value !== (header_class_value = "flex-none " + /*classesheader*/
      ctx2[6])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(33:1) {#if $$slots.header}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let aside;
  let current;
  const sidebarLeft_slot_template = (
    /*#slots*/
    ctx[17].sidebarLeft
  );
  const sidebarLeft_slot = create_slot(
    sidebarLeft_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_sidebarLeft_slot_context
  );
  const block = {
    c: function create() {
      aside = element("aside");
      if (sidebarLeft_slot)
        sidebarLeft_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { id: true, class: true });
      var aside_nodes = children(aside);
      if (sidebarLeft_slot)
        sidebarLeft_slot.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "id", "sidebar-left");
      attr_dev(
        aside,
        "class",
        /*classesSidebarLeft*/
        ctx[5]
      );
      add_location(aside, file6, 40, 3, 1338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (sidebarLeft_slot) {
        sidebarLeft_slot.m(aside, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (sidebarLeft_slot) {
        if (sidebarLeft_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            sidebarLeft_slot,
            sidebarLeft_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              sidebarLeft_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_sidebarLeft_slot_changes
            ),
            get_sidebarLeft_slot_context
          );
        }
      }
      if (!current || dirty & /*classesSidebarLeft*/
      32) {
        attr_dev(
          aside,
          "class",
          /*classesSidebarLeft*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarLeft_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarLeft_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside);
      if (sidebarLeft_slot)
        sidebarLeft_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(40:2) {#if $$slots.sidebarLeft}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let header;
  let header_class_value;
  let current;
  const pageHeader_slot_template = (
    /*#slots*/
    ctx[17].pageHeader
  );
  const pageHeader_slot = create_slot(
    pageHeader_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_pageHeader_slot_context
  );
  const pageHeader_slot_or_fallback = pageHeader_slot || fallback_block_12(ctx);
  const block = {
    c: function create() {
      header = element("header");
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { id: true, class: true });
      var header_nodes = children(header);
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.l(header_nodes);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "id", "page-header");
      attr_dev(header, "class", header_class_value = "flex-none " + /*classesPageHeader*/
      ctx[3]);
      add_location(header, file6, 47, 4, 1545);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      if (pageHeader_slot_or_fallback) {
        pageHeader_slot_or_fallback.m(header, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (pageHeader_slot) {
        if (pageHeader_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            pageHeader_slot,
            pageHeader_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              pageHeader_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_pageHeader_slot_changes
            ),
            get_pageHeader_slot_context
          );
        }
      }
      if (!current || dirty & /*classesPageHeader*/
      8 && header_class_value !== (header_class_value = "flex-none " + /*classesPageHeader*/
      ctx2[3])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pageHeader_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pageHeader_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(47:3) {#if $$slots.pageHeader}",
    ctx
  });
  return block;
}
function fallback_block_12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(slot:header)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(slot:header)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_12.name,
    type: "fallback",
    source: "(48:91) (slot:header)",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let footer;
  let footer_class_value;
  let current;
  const pageFooter_slot_template = (
    /*#slots*/
    ctx[17].pageFooter
  );
  const pageFooter_slot = create_slot(
    pageFooter_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_pageFooter_slot_context
  );
  const pageFooter_slot_or_fallback = pageFooter_slot || fallback_block2(ctx);
  const block = {
    c: function create() {
      footer = element("footer");
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { id: true, class: true });
      var footer_nodes = children(footer);
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(footer, "id", "page-footer");
      attr_dev(footer, "class", footer_class_value = "flex-none " + /*classesPageFooter*/
      ctx[1]);
      add_location(footer, file6, 55, 4, 1858);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      if (pageFooter_slot_or_fallback) {
        pageFooter_slot_or_fallback.m(footer, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (pageFooter_slot) {
        if (pageFooter_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            pageFooter_slot,
            pageFooter_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              pageFooter_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_pageFooter_slot_changes
            ),
            get_pageFooter_slot_context
          );
        }
      }
      if (!current || dirty & /*classesPageFooter*/
      2 && footer_class_value !== (footer_class_value = "flex-none " + /*classesPageFooter*/
      ctx2[1])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pageFooter_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pageFooter_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(55:3) {#if $$slots.pageFooter}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(slot:footer)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(slot:footer)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(56:91) (slot:footer)",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let aside;
  let current;
  const sidebarRight_slot_template = (
    /*#slots*/
    ctx[17].sidebarRight
  );
  const sidebarRight_slot = create_slot(
    sidebarRight_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_sidebarRight_slot_context
  );
  const block = {
    c: function create() {
      aside = element("aside");
      if (sidebarRight_slot)
        sidebarRight_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { id: true, class: true });
      var aside_nodes = children(aside);
      if (sidebarRight_slot)
        sidebarRight_slot.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "id", "sidebar-right");
      attr_dev(
        aside,
        "class",
        /*classesSidebarRight*/
        ctx[4]
      );
      add_location(aside, file6, 61, 3, 2059);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (sidebarRight_slot) {
        sidebarRight_slot.m(aside, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (sidebarRight_slot) {
        if (sidebarRight_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            sidebarRight_slot,
            sidebarRight_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              sidebarRight_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_sidebarRight_slot_changes
            ),
            get_sidebarRight_slot_context
          );
        }
      }
      if (!current || dirty & /*classesSidebarRight*/
      16) {
        attr_dev(
          aside,
          "class",
          /*classesSidebarRight*/
          ctx2[4]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarRight_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarRight_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside);
      if (sidebarRight_slot)
        sidebarRight_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(61:2) {#if $$slots.sidebarRight}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let footer;
  let footer_class_value;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[17].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_footer_slot_context
  );
  const block = {
    c: function create() {
      footer = element("footer");
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { id: true, class: true });
      var footer_nodes = children(footer);
      if (footer_slot)
        footer_slot.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(footer, "id", "shell-footer");
      attr_dev(footer, "class", footer_class_value = "flex-none " + /*classesFooter*/
      ctx[0]);
      add_location(footer, file6, 67, 2, 2214);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      if (footer_slot) {
        footer_slot.m(footer, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
      if (!current || dirty & /*classesFooter*/
      1 && footer_class_value !== (footer_class_value = "flex-none " + /*classesFooter*/
      ctx2[0])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(67:1) {#if $$slots.footer}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let div2;
  let t0;
  let div1;
  let t1;
  let div0;
  let t2;
  let main;
  let main_class_value;
  let t3;
  let t4;
  let div1_class_value;
  let t5;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[8].header && create_if_block_5(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[8].sidebarLeft && create_if_block_4(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[8].pageHeader && create_if_block_3(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let if_block3 = (
    /*$$slots*/
    ctx[8].pageFooter && create_if_block_2(ctx)
  );
  let if_block4 = (
    /*$$slots*/
    ctx[8].sidebarRight && create_if_block_12(ctx)
  );
  let if_block5 = (
    /*$$slots*/
    ctx[8].footer && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      if (if_block2)
        if_block2.c();
      t2 = space();
      main = element("main");
      if (default_slot)
        default_slot.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        id: true,
        class: true,
        "data-testid": true
      });
      var div2_nodes = children(div2);
      if (if_block0)
        if_block0.l(div2_nodes);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block1)
        if_block1.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
      var div0_nodes = children(div0);
      if (if_block2)
        if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      main = claim_element(div0_nodes, "MAIN", { id: true, class: true });
      var main_nodes = children(main);
      if (default_slot)
        default_slot.l(main_nodes);
      main_nodes.forEach(detach_dev);
      t3 = claim_space(div0_nodes);
      if (if_block3)
        if_block3.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      if (if_block4)
        if_block4.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t5 = claim_space(div2_nodes);
      if (if_block5)
        if_block5.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(main, "id", "page-content");
      attr_dev(main, "class", main_class_value = "flex-auto " + /*classesPageContent*/
      ctx[2]);
      add_location(main, file6, 51, 3, 1716);
      attr_dev(div0, "id", "page");
      attr_dev(div0, "class", cPage);
      add_location(div0, file6, 44, 2, 1453);
      attr_dev(div1, "class", div1_class_value = "flex-auto " + cContentArea);
      add_location(div1, file6, 37, 1, 1236);
      attr_dev(div2, "id", "appShell");
      attr_dev(
        div2,
        "class",
        /*classesBase*/
        ctx[7]
      );
      attr_dev(div2, "data-testid", "app-shell");
      add_location(div2, file6, 30, 0, 1001);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration_dev(div0, t2);
      append_hydration_dev(div0, main);
      if (default_slot) {
        default_slot.m(main, null);
      }
      append_hydration_dev(div0, t3);
      if (if_block3)
        if_block3.m(div0, null);
      append_hydration_dev(div1, t4);
      if (if_block4)
        if_block4.m(div1, null);
      append_hydration_dev(div2, t5);
      if (if_block5)
        if_block5.m(div2, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[8].header
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[8].sidebarLeft
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[8].pageHeader
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_3(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesPageContent*/
      4 && main_class_value !== (main_class_value = "flex-auto " + /*classesPageContent*/
      ctx2[2])) {
        attr_dev(main, "class", main_class_value);
      }
      if (
        /*$$slots*/
        ctx2[8].pageFooter
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[8].sidebarRight
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_12(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div1, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[8].footer
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block4(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div2, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      128) {
        attr_dev(
          div2,
          "class",
          /*classesBase*/
          ctx2[7]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(default_slot, local);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(default_slot, local);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBaseAppShell = "w-full h-full flex flex-col overflow-hidden";
var cContentArea = "w-full h-full flex overflow-hidden";
var cPage = "flex-1 overflow-x-hidden overflow-y-auto flex flex-col";
var cSidebarLeft = "flex-none overflow-x-hidden overflow-y-auto";
var cSidebarRight = "flex-none overflow-x-hidden overflow-y-auto";
function instance6($$self, $$props, $$invalidate) {
  let classesBase;
  let classesheader;
  let classesSidebarLeft;
  let classesSidebarRight;
  let classesPageHeader;
  let classesPageContent;
  let classesPageFooter;
  let classesFooter;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppShell", slots, [
    "header",
    "sidebarLeft",
    "pageHeader",
    "default",
    "pageFooter",
    "sidebarRight",
    "footer"
  ]);
  const $$slots = compute_slots(slots);
  let { slotHeader = "z-10" } = $$props;
  let { slotSidebarLeft = "w-auto" } = $$props;
  let { slotSidebarRight = "w-auto" } = $$props;
  let { slotPageHeader = "" } = $$props;
  let { slotPageContent = "" } = $$props;
  let { slotPageFooter = "" } = $$props;
  let { slotFooter = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("slotHeader" in $$new_props)
      $$invalidate(9, slotHeader = $$new_props.slotHeader);
    if ("slotSidebarLeft" in $$new_props)
      $$invalidate(10, slotSidebarLeft = $$new_props.slotSidebarLeft);
    if ("slotSidebarRight" in $$new_props)
      $$invalidate(11, slotSidebarRight = $$new_props.slotSidebarRight);
    if ("slotPageHeader" in $$new_props)
      $$invalidate(12, slotPageHeader = $$new_props.slotPageHeader);
    if ("slotPageContent" in $$new_props)
      $$invalidate(13, slotPageContent = $$new_props.slotPageContent);
    if ("slotPageFooter" in $$new_props)
      $$invalidate(14, slotPageFooter = $$new_props.slotPageFooter);
    if ("slotFooter" in $$new_props)
      $$invalidate(15, slotFooter = $$new_props.slotFooter);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    slotHeader,
    slotSidebarLeft,
    slotSidebarRight,
    slotPageHeader,
    slotPageContent,
    slotPageFooter,
    slotFooter,
    cBaseAppShell,
    cContentArea,
    cPage,
    cSidebarLeft,
    cSidebarRight,
    classesFooter,
    classesPageFooter,
    classesPageContent,
    classesPageHeader,
    classesSidebarRight,
    classesSidebarLeft,
    classesheader,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("slotHeader" in $$props)
      $$invalidate(9, slotHeader = $$new_props.slotHeader);
    if ("slotSidebarLeft" in $$props)
      $$invalidate(10, slotSidebarLeft = $$new_props.slotSidebarLeft);
    if ("slotSidebarRight" in $$props)
      $$invalidate(11, slotSidebarRight = $$new_props.slotSidebarRight);
    if ("slotPageHeader" in $$props)
      $$invalidate(12, slotPageHeader = $$new_props.slotPageHeader);
    if ("slotPageContent" in $$props)
      $$invalidate(13, slotPageContent = $$new_props.slotPageContent);
    if ("slotPageFooter" in $$props)
      $$invalidate(14, slotPageFooter = $$new_props.slotPageFooter);
    if ("slotFooter" in $$props)
      $$invalidate(15, slotFooter = $$new_props.slotFooter);
    if ("classesFooter" in $$props)
      $$invalidate(0, classesFooter = $$new_props.classesFooter);
    if ("classesPageFooter" in $$props)
      $$invalidate(1, classesPageFooter = $$new_props.classesPageFooter);
    if ("classesPageContent" in $$props)
      $$invalidate(2, classesPageContent = $$new_props.classesPageContent);
    if ("classesPageHeader" in $$props)
      $$invalidate(3, classesPageHeader = $$new_props.classesPageHeader);
    if ("classesSidebarRight" in $$props)
      $$invalidate(4, classesSidebarRight = $$new_props.classesSidebarRight);
    if ("classesSidebarLeft" in $$props)
      $$invalidate(5, classesSidebarLeft = $$new_props.classesSidebarLeft);
    if ("classesheader" in $$props)
      $$invalidate(6, classesheader = $$new_props.classesheader);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, classesBase = `${cBaseAppShell} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*slotHeader*/
    512) {
      $:
        $$invalidate(6, classesheader = `${slotHeader}`);
    }
    if ($$self.$$.dirty & /*slotSidebarLeft*/
    1024) {
      $:
        $$invalidate(5, classesSidebarLeft = `${cSidebarLeft} ${slotSidebarLeft}`);
    }
    if ($$self.$$.dirty & /*slotSidebarRight*/
    2048) {
      $:
        $$invalidate(4, classesSidebarRight = `${cSidebarRight} ${slotSidebarRight}`);
    }
    if ($$self.$$.dirty & /*slotPageHeader*/
    4096) {
      $:
        $$invalidate(3, classesPageHeader = `${slotPageHeader}`);
    }
    if ($$self.$$.dirty & /*slotPageContent*/
    8192) {
      $:
        $$invalidate(2, classesPageContent = `${slotPageContent}`);
    }
    if ($$self.$$.dirty & /*slotPageFooter*/
    16384) {
      $:
        $$invalidate(1, classesPageFooter = `${slotPageFooter}`);
    }
    if ($$self.$$.dirty & /*slotFooter*/
    32768) {
      $:
        $$invalidate(0, classesFooter = `${slotFooter}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    classesFooter,
    classesPageFooter,
    classesPageContent,
    classesPageHeader,
    classesSidebarRight,
    classesSidebarLeft,
    classesheader,
    classesBase,
    $$slots,
    slotHeader,
    slotSidebarLeft,
    slotSidebarRight,
    slotPageHeader,
    slotPageContent,
    slotPageFooter,
    slotFooter,
    $$scope,
    slots
  ];
}
var AppShell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      slotHeader: 9,
      slotSidebarLeft: 10,
      slotSidebarRight: 11,
      slotPageHeader: 12,
      slotPageContent: 13,
      slotPageFooter: 14,
      slotFooter: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppShell",
      options,
      id: create_fragment6.name
    });
  }
  get slotHeader() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotHeader(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotSidebarLeft() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotSidebarLeft(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotSidebarRight() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotSidebarRight(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageHeader() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageHeader(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageContent() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageContent(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageFooter() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageFooter(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotFooter() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotFooter(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppShell_default = AppShell;

// node_modules/@skeletonlabs/skeleton/components/Avatar/Avatar.svelte
var file7 = "node_modules/@skeletonlabs/skeleton/components/Avatar/Avatar.svelte";
function create_else_block(ctx) {
  let svg;
  let text_1;
  let t_value = String(
    /*initials*/
    ctx[0]
  ).substring(0, 2).toUpperCase() + "";
  let t;
  let text_1_font_size_value;
  let text_1_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      text_1 = svg_element("text");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, viewBox: true });
      var svg_nodes = children(svg);
      text_1 = claim_svg_element(svg_nodes, "text", {
        x: true,
        y: true,
        "text-anchor": true,
        "dominant-baseline": true,
        "font-weight": true,
        "font-size": true,
        class: true
      });
      var text_1_nodes = children(text_1);
      t = claim_text(text_1_nodes, t_value);
      text_1_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "x", "50%");
      attr_dev(text_1, "y", "50%");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "dominant-baseline", "middle");
      attr_dev(text_1, "font-weight", "bold");
      attr_dev(text_1, "font-size", text_1_font_size_value = 150);
      attr_dev(text_1, "class", text_1_class_value = "avatar-text " + /*fill*/
      ctx[1]);
      add_location(text_1, file7, 23, 3, 913);
      attr_dev(svg, "class", "avatar-initials w-full h-full");
      attr_dev(svg, "viewBox", "0 0 512 512");
      add_location(svg, file7, 22, 2, 844);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, text_1);
      append_hydration_dev(text_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*initials*/
      1 && t_value !== (t_value = String(
        /*initials*/
        ctx2[0]
      ).substring(0, 2).toUpperCase() + ""))
        set_data_dev(t, t_value);
      if (dirty & /*fill*/
      2 && text_1_class_value !== (text_1_class_value = "avatar-text " + /*fill*/
      ctx2[1])) {
        attr_dev(text_1, "class", text_1_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(22:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let img;
  let img_class_value;
  let img_src_value;
  let img_alt_value;
  let action_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(img, "class", img_class_value = "avatar-image " + /*cImage*/
      ctx[6]);
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[2]))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", img_alt_value = /*$$props*/
      ctx[7].alt || "");
      add_location(img, file7, 20, 2, 739);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      if (!mounted) {
        dispose = action_destroyer(action_action = /*action*/
        ctx[3].call(
          null,
          img,
          /*actionParams*/
          ctx[4]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*src*/
      4 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[2])) {
        attr_dev(img, "src", img_src_value);
      }
      if (dirty & /*$$props*/
      128 && img_alt_value !== (img_alt_value = /*$$props*/
      ctx2[7].alt || "")) {
        attr_dev(img, "alt", img_alt_value);
      }
      if (action_action && is_function(action_action.update) && dirty & /*actionParams*/
      16)
        action_action.update.call(
          null,
          /*actionParams*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(20:1) {#if src}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let figure;
  let figure_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*src*/
      ctx2[2]
    )
      return create_if_block5;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      figure = element("figure");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", { class: true, "data-testid": true });
      var figure_nodes = children(figure);
      if_block.l(figure_nodes);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figure, "class", figure_class_value = "avatar " + /*classesBase*/
      ctx[5]);
      attr_dev(figure, "data-testid", "avatar");
      add_location(figure, file7, 18, 0, 626);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      if_block.m(figure, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            figure,
            "click",
            /*click_handler*/
            ctx[14],
            false,
            false,
            false
          ),
          listen_dev(
            figure,
            "keydown",
            /*keydown_handler*/
            ctx[15],
            false,
            false,
            false
          ),
          listen_dev(
            figure,
            "keyup",
            /*keyup_handler*/
            ctx[16],
            false,
            false,
            false
          ),
          listen_dev(
            figure,
            "keypress",
            /*keypress_handler*/
            ctx[17],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(figure, null);
        }
      }
      if (dirty & /*classesBase*/
      32 && figure_class_value !== (figure_class_value = "avatar " + /*classesBase*/
      ctx2[5])) {
        attr_dev(figure, "class", figure_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figure);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Avatar", slots, []);
  let { background = "bg-surface-400-500-token" } = $$props;
  let { width = "w-12" } = $$props;
  let { border = "" } = $$props;
  let { rounded = "rounded-full" } = $$props;
  let { shadow = "" } = $$props;
  let { cursor = "" } = $$props;
  let { initials = "AB" } = $$props;
  let { fill = "fill-token" } = $$props;
  let { src = "" } = $$props;
  let { action = () => {
  } } = $$props;
  let { actionParams = "" } = $$props;
  let cBase20 = "flex aspect-square text-surface-50 font-semibold justify-center items-center overflow-hidden isolate";
  let cImage = "w-full h-full object-cover";
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("background" in $$new_props)
      $$invalidate(8, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(9, width = $$new_props.width);
    if ("border" in $$new_props)
      $$invalidate(10, border = $$new_props.border);
    if ("rounded" in $$new_props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(12, shadow = $$new_props.shadow);
    if ("cursor" in $$new_props)
      $$invalidate(13, cursor = $$new_props.cursor);
    if ("initials" in $$new_props)
      $$invalidate(0, initials = $$new_props.initials);
    if ("fill" in $$new_props)
      $$invalidate(1, fill = $$new_props.fill);
    if ("src" in $$new_props)
      $$invalidate(2, src = $$new_props.src);
    if ("action" in $$new_props)
      $$invalidate(3, action = $$new_props.action);
    if ("actionParams" in $$new_props)
      $$invalidate(4, actionParams = $$new_props.actionParams);
  };
  $$self.$capture_state = () => ({
    background,
    width,
    border,
    rounded,
    shadow,
    cursor,
    initials,
    fill,
    src,
    action,
    actionParams,
    cBase: cBase20,
    cImage,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    if ("background" in $$props)
      $$invalidate(8, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(9, width = $$new_props.width);
    if ("border" in $$props)
      $$invalidate(10, border = $$new_props.border);
    if ("rounded" in $$props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(12, shadow = $$new_props.shadow);
    if ("cursor" in $$props)
      $$invalidate(13, cursor = $$new_props.cursor);
    if ("initials" in $$props)
      $$invalidate(0, initials = $$new_props.initials);
    if ("fill" in $$props)
      $$invalidate(1, fill = $$new_props.fill);
    if ("src" in $$props)
      $$invalidate(2, src = $$new_props.src);
    if ("action" in $$props)
      $$invalidate(3, action = $$new_props.action);
    if ("actionParams" in $$props)
      $$invalidate(4, actionParams = $$new_props.actionParams);
    if ("cBase" in $$props)
      $$invalidate(18, cBase20 = $$new_props.cBase);
    if ("cImage" in $$props)
      $$invalidate(6, cImage = $$new_props.cImage);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, classesBase = `${cBase20} ${background} ${width} ${border} ${rounded} ${shadow} ${cursor} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    initials,
    fill,
    src,
    action,
    actionParams,
    classesBase,
    cImage,
    $$props,
    background,
    width,
    border,
    rounded,
    shadow,
    cursor,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var Avatar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      background: 8,
      width: 9,
      border: 10,
      rounded: 11,
      shadow: 12,
      cursor: 13,
      initials: 0,
      fill: 1,
      src: 2,
      action: 3,
      actionParams: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Avatar",
      options,
      id: create_fragment7.name
    });
  }
  get background() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cursor() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cursor(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initials() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initials(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get action() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set action(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actionParams() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actionParams(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Avatar_default = Avatar;

// node_modules/@skeletonlabs/skeleton/components/ConicGradient/settings.js
var tailwindDefaultColors = [
  {
    label: "slate",
    shades: {
      "50": { hex: "#f8fafc", rgb: "248 250 252" },
      "100": { hex: "#f1f5f9", rgb: "241 245 249" },
      "200": { hex: "#e2e8f0", rgb: "226 232 240" },
      "300": { hex: "#cbd5e1", rgb: "203 213 225" },
      "400": { hex: "#94a3b8", rgb: "148 163 184" },
      "500": { hex: "#64748b", rgb: "100 116 139" },
      "600": { hex: "#475569", rgb: "71 85 105" },
      "700": { hex: "#334155", rgb: "51 65 85" },
      "800": { hex: "#1e293b", rgb: "30 41 59" },
      "900": { hex: "#0f172a", rgb: "15 23 42" }
    }
  },
  {
    label: "gray",
    shades: {
      "50": { hex: "#f9fafb", rgb: "249 250 251" },
      "100": { hex: "#f3f4f6", rgb: "243 244 246" },
      "200": { hex: "#e5e7eb", rgb: "229 231 235" },
      "300": { hex: "#d1d5db", rgb: "209 213 219" },
      "400": { hex: "#9ca3af", rgb: "156 163 175" },
      "500": { hex: "#6b7280", rgb: "107 114 128" },
      "600": { hex: "#4b5563", rgb: "75 85 99" },
      "700": { hex: "#374151", rgb: "55 65 81" },
      "800": { hex: "#1f2937", rgb: "31 41 55" },
      "900": { hex: "#111827", rgb: "17 24 39" }
    }
  },
  {
    label: "zinc",
    shades: {
      "50": { hex: "#fafafa", rgb: "250 250 250" },
      "100": { hex: "#f4f4f5", rgb: "244 244 245" },
      "200": { hex: "#e4e4e7", rgb: "228 228 231" },
      "300": { hex: "#d4d4d8", rgb: "212 212 216" },
      "400": { hex: "#a1a1aa", rgb: "161 161 170" },
      "500": { hex: "#71717a", rgb: "113 113 122" },
      "600": { hex: "#52525b", rgb: "82 82 91" },
      "700": { hex: "#3f3f46", rgb: "63 63 70" },
      "800": { hex: "#27272a", rgb: "39 39 42" },
      "900": { hex: "#18181b", rgb: "24 24 27" }
    }
  },
  {
    label: "neutral",
    shades: {
      "50": { hex: "#fafafa", rgb: "250 250 250" },
      "100": { hex: "#f5f5f5", rgb: "245 245 245" },
      "200": { hex: "#e5e5e5", rgb: "229 229 229" },
      "300": { hex: "#d4d4d4", rgb: "212 212 212" },
      "400": { hex: "#a3a3a3", rgb: "163 163 163" },
      "500": { hex: "#737373", rgb: "115 115 115" },
      "600": { hex: "#525252", rgb: "82 82 82" },
      "700": { hex: "#404040", rgb: "64 64 64" },
      "800": { hex: "#262626", rgb: "38 38 38" },
      "900": { hex: "#171717", rgb: "23 23 23" }
    }
  },
  {
    label: "stone",
    shades: {
      "50": { hex: "#fafaf9", rgb: "250 250 249" },
      "100": { hex: "#f5f5f4", rgb: "245 245 244" },
      "200": { hex: "#e7e5e4", rgb: "231 229 228" },
      "300": { hex: "#d6d3d1", rgb: "214 211 209" },
      "400": { hex: "#a8a29e", rgb: "168 162 158" },
      "500": { hex: "#78716c", rgb: "120 113 108" },
      "600": { hex: "#57534e", rgb: "87 83 78" },
      "700": { hex: "#44403c", rgb: "68 64 60" },
      "800": { hex: "#292524", rgb: "41 37 36" },
      "900": { hex: "#1c1917", rgb: "28 25 23" }
    }
  },
  {
    label: "red",
    shades: {
      "50": { hex: "#fef2f2", rgb: "254 242 242" },
      "100": { hex: "#fee2e2", rgb: "254 226 226" },
      "200": { hex: "#fecaca", rgb: "254 202 202" },
      "300": { hex: "#fca5a5", rgb: "252 165 165" },
      "400": { hex: "#f87171", rgb: "248 113 113" },
      "500": { hex: "#ef4444", rgb: "239 68 68" },
      "600": { hex: "#dc2626", rgb: "220 38 38" },
      "700": { hex: "#b91c1c", rgb: "185 28 28" },
      "800": { hex: "#991b1b", rgb: "153 27 27" },
      "900": { hex: "#7f1d1d", rgb: "127 29 29" }
    }
  },
  {
    label: "orange",
    shades: {
      "50": { hex: "#fff7ed", rgb: "255 247 237" },
      "100": { hex: "#ffedd5", rgb: "255 237 213" },
      "200": { hex: "#fed7aa", rgb: "254 215 170" },
      "300": { hex: "#fdba74", rgb: "253 186 116" },
      "400": { hex: "#fb923c", rgb: "251 146 60" },
      "500": { hex: "#f97316", rgb: "249 115 22" },
      "600": { hex: "#ea580c", rgb: "234 88 12" },
      "700": { hex: "#c2410c", rgb: "194 65 12" },
      "800": { hex: "#9a3412", rgb: "154 52 18" },
      "900": { hex: "#7c2d12", rgb: "124 45 18" }
    }
  },
  {
    label: "amber",
    shades: {
      "50": { hex: "#fffbeb", rgb: "255 251 235" },
      "100": { hex: "#fef3c7", rgb: "254 243 199" },
      "200": { hex: "#fde68a", rgb: "253 230 138" },
      "300": { hex: "#fcd34d", rgb: "252 211 77" },
      "400": { hex: "#fbbf24", rgb: "251 191 36" },
      "500": { hex: "#f59e0b", rgb: "245 158 11" },
      "600": { hex: "#d97706", rgb: "217 119 6" },
      "700": { hex: "#b45309", rgb: "180 83 9" },
      "800": { hex: "#92400e", rgb: "146 64 14" },
      "900": { hex: "#78350f", rgb: "120 53 15" }
    }
  },
  {
    label: "yellow",
    shades: {
      "50": { hex: "#fefce8", rgb: "254 252 232" },
      "100": { hex: "#fef9c3", rgb: "254 249 195" },
      "200": { hex: "#fef08a", rgb: "254 240 138" },
      "300": { hex: "#fde047", rgb: "253 224 71" },
      "400": { hex: "#facc15", rgb: "250 204 21" },
      "500": { hex: "#eab308", rgb: "234 179 8" },
      "600": { hex: "#ca8a04", rgb: "202 138 4" },
      "700": { hex: "#a16207", rgb: "161 98 7" },
      "800": { hex: "#854d0e", rgb: "133 77 14" },
      "900": { hex: "#713f12", rgb: "113 63 18" }
    }
  },
  {
    label: "lime",
    shades: {
      "50": { hex: "#f7fee7", rgb: "247 254 231" },
      "100": { hex: "#ecfccb", rgb: "236 252 203" },
      "200": { hex: "#d9f99d", rgb: "217 249 157" },
      "300": { hex: "#bef264", rgb: "190 242 100" },
      "400": { hex: "#a3e635", rgb: "163 230 53" },
      "500": { hex: "#84cc16", rgb: "132 204 22" },
      "600": { hex: "#65a30d", rgb: "101 163 13" },
      "700": { hex: "#4d7c0f", rgb: "77 124 15" },
      "800": { hex: "#3f6212", rgb: "63 98 18" },
      "900": { hex: "#365314", rgb: "54 83 20" }
    }
  },
  {
    label: "green",
    shades: {
      "50": { hex: "#f0fdf4", rgb: "240 253 244" },
      "100": { hex: "#dcfce7", rgb: "220 252 231" },
      "200": { hex: "#bbf7d0", rgb: "187 247 208" },
      "300": { hex: "#86efac", rgb: "134 239 172" },
      "400": { hex: "#4ade80", rgb: "74 222 128" },
      "500": { hex: "#22c55e", rgb: "34 197 94" },
      "600": { hex: "#16a34a", rgb: "22 163 74" },
      "700": { hex: "#15803d", rgb: "21 128 61" },
      "800": { hex: "#166534", rgb: "22 101 52" },
      "900": { hex: "#14532d", rgb: "20 83 45" }
    }
  },
  {
    label: "emerald",
    shades: {
      "50": { hex: "#ecfdf5", rgb: "236 253 245" },
      "100": { hex: "#d1fae5", rgb: "209 250 229" },
      "200": { hex: "#a7f3d0", rgb: "167 243 208" },
      "300": { hex: "#6ee7b7", rgb: "110 231 183" },
      "400": { hex: "#34d399", rgb: "52 211 153" },
      "500": { hex: "#10b981", rgb: "16 185 129" },
      "600": { hex: "#059669", rgb: "5 150 105" },
      "700": { hex: "#047857", rgb: "4 120 87" },
      "800": { hex: "#065f46", rgb: "6 95 70" },
      "900": { hex: "#064e3b", rgb: "6 78 59" }
    }
  },
  {
    label: "teal",
    shades: {
      "50": { hex: "#f0fdfa", rgb: "240 253 250" },
      "100": { hex: "#ccfbf1", rgb: "204 251 241" },
      "200": { hex: "#99f6e4", rgb: "153 246 228" },
      "300": { hex: "#5eead4", rgb: "94 234 212" },
      "400": { hex: "#2dd4bf", rgb: "45 212 191" },
      "500": { hex: "#14b8a6", rgb: "20 184 166" },
      "600": { hex: "#0d9488", rgb: "13 148 136" },
      "700": { hex: "#0f766e", rgb: "15 118 110" },
      "800": { hex: "#115e59", rgb: "17 94 89" },
      "900": { hex: "#134e4a", rgb: "19 78 74" }
    }
  },
  {
    label: "cyan",
    shades: {
      "50": { hex: "#ecfeff", rgb: "236 254 255" },
      "100": { hex: "#cffafe", rgb: "207 250 254" },
      "200": { hex: "#a5f3fc", rgb: "165 243 252" },
      "300": { hex: "#67e8f9", rgb: "103 232 249" },
      "400": { hex: "#22d3ee", rgb: "34 211 238" },
      "500": { hex: "#06b6d4", rgb: "6 182 212" },
      "600": { hex: "#0891b2", rgb: "8 145 178" },
      "700": { hex: "#0e7490", rgb: "14 116 144" },
      "800": { hex: "#155e75", rgb: "21 94 117" },
      "900": { hex: "#164e63", rgb: "22 78 99" }
    }
  },
  {
    label: "sky",
    shades: {
      "50": { hex: "#f0f9ff", rgb: "240 249 255" },
      "100": { hex: "#e0f2fe", rgb: "224 242 254" },
      "200": { hex: "#bae6fd", rgb: "186 230 253" },
      "300": { hex: "#7dd3fc", rgb: "125 211 252" },
      "400": { hex: "#38bdf8", rgb: "56 189 248" },
      "500": { hex: "#0ea5e9", rgb: "14 165 233" },
      "600": { hex: "#0284c7", rgb: "2 132 199" },
      "700": { hex: "#0369a1", rgb: "3 105 161" },
      "800": { hex: "#075985", rgb: "7 89 133" },
      "900": { hex: "#0c4a6e", rgb: "12 74 110" }
    }
  },
  {
    label: "blue",
    shades: {
      "50": { hex: "#eff6ff", rgb: "239 246 255" },
      "100": { hex: "#dbeafe", rgb: "219 234 254" },
      "200": { hex: "#bfdbfe", rgb: "191 219 254" },
      "300": { hex: "#93c5fd", rgb: "147 197 253" },
      "400": { hex: "#60a5fa", rgb: "96 165 250" },
      "500": { hex: "#3b82f6", rgb: "59 130 246" },
      "600": { hex: "#2563eb", rgb: "37 99 235" },
      "700": { hex: "#1d4ed8", rgb: "29 78 216" },
      "800": { hex: "#1e40af", rgb: "30 64 175" },
      "900": { hex: "#1e3a8a", rgb: "30 58 138" }
    }
  },
  {
    label: "indigo",
    shades: {
      "50": { hex: "#eef2ff", rgb: "238 242 255" },
      "100": { hex: "#e0e7ff", rgb: "224 231 255" },
      "200": { hex: "#c7d2fe", rgb: "199 210 254" },
      "300": { hex: "#a5b4fc", rgb: "165 180 252" },
      "400": { hex: "#818cf8", rgb: "129 140 248" },
      "500": { hex: "#6366f1", rgb: "99 102 241" },
      "600": { hex: "#4f46e5", rgb: "79 70 229" },
      "700": { hex: "#4338ca", rgb: "67 56 202" },
      "800": { hex: "#3730a3", rgb: "55 48 163" },
      "900": { hex: "#312e81", rgb: "49 46 129" }
    }
  },
  {
    label: "violet",
    shades: {
      "50": { hex: "#f5f3ff", rgb: "245 243 255" },
      "100": { hex: "#ede9fe", rgb: "237 233 254" },
      "200": { hex: "#ddd6fe", rgb: "221 214 254" },
      "300": { hex: "#c4b5fd", rgb: "196 181 253" },
      "400": { hex: "#a78bfa", rgb: "167 139 250" },
      "500": { hex: "#8b5cf6", rgb: "139 92 246" },
      "600": { hex: "#7c3aed", rgb: "124 58 237" },
      "700": { hex: "#6d28d9", rgb: "109 40 217" },
      "800": { hex: "#5b21b6", rgb: "91 33 182" },
      "900": { hex: "#4c1d95", rgb: "76 29 149" }
    }
  },
  {
    label: "purple",
    shades: {
      "50": { hex: "#faf5ff", rgb: "250 245 255" },
      "100": { hex: "#f3e8ff", rgb: "243 232 255" },
      "200": { hex: "#e9d5ff", rgb: "233 213 255" },
      "300": { hex: "#d8b4fe", rgb: "216 180 254" },
      "400": { hex: "#c084fc", rgb: "192 132 252" },
      "500": { hex: "#a855f7", rgb: "168 85 247" },
      "600": { hex: "#9333ea", rgb: "147 51 234" },
      "700": { hex: "#7e22ce", rgb: "126 34 206" },
      "800": { hex: "#6b21a8", rgb: "107 33 168" },
      "900": { hex: "#581c87", rgb: "88 28 135" }
    }
  },
  {
    label: "fuchsia",
    shades: {
      "50": { hex: "#fdf4ff", rgb: "253 244 255" },
      "100": { hex: "#fae8ff", rgb: "250 232 255" },
      "200": { hex: "#f5d0fe", rgb: "245 208 254" },
      "300": { hex: "#f0abfc", rgb: "240 171 252" },
      "400": { hex: "#e879f9", rgb: "232 121 249" },
      "500": { hex: "#d946ef", rgb: "217 70 239" },
      "600": { hex: "#c026d3", rgb: "192 38 211" },
      "700": { hex: "#a21caf", rgb: "162 28 175" },
      "800": { hex: "#86198f", rgb: "134 25 143" },
      "900": { hex: "#701a75", rgb: "112 26 117" }
    }
  },
  {
    label: "pink",
    shades: {
      "50": { hex: "#fdf2f8", rgb: "253 242 248" },
      "100": { hex: "#fce7f3", rgb: "252 231 243" },
      "200": { hex: "#fbcfe8", rgb: "251 207 232" },
      "300": { hex: "#f9a8d4", rgb: "249 168 212" },
      "400": { hex: "#f472b6", rgb: "244 114 182" },
      "500": { hex: "#ec4899", rgb: "236 72 153" },
      "600": { hex: "#db2777", rgb: "219 39 119" },
      "700": { hex: "#be185d", rgb: "190 24 93" },
      "800": { hex: "#9d174d", rgb: "157 23 77" },
      "900": { hex: "#831843", rgb: "131 24 67" }
    }
  },
  {
    label: "rose",
    shades: {
      "50": { hex: "#fff1f2", rgb: "255 241 242" },
      "100": { hex: "#ffe4e6", rgb: "255 228 230" },
      "200": { hex: "#fecdd3", rgb: "254 205 211" },
      "300": { hex: "#fda4af", rgb: "253 164 175" },
      "400": { hex: "#fb7185", rgb: "251 113 133" },
      "500": { hex: "#f43f5e", rgb: "244 63 94" },
      "600": { hex: "#e11d48", rgb: "225 29 72" },
      "700": { hex: "#be123c", rgb: "190 18 60" },
      "800": { hex: "#9f1239", rgb: "159 18 57" },
      "900": { hex: "#881337", rgb: "136 19 55" }
    }
  }
];

// node_modules/@skeletonlabs/skeleton/components/ConicGradient/ConicGradient.svelte
var file8 = "node_modules/@skeletonlabs/skeleton/components/ConicGradient/ConicGradient.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i].color;
  child_ctx[21] = list[i].label;
  child_ctx[22] = list[i].value;
  return child_ctx;
}
function create_if_block_22(ctx) {
  let figcaption;
  let figcaption_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      figcaption = element("figcaption");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      figcaption = claim_element(nodes, "FIGCAPTION", { class: true });
      var figcaption_nodes = children(figcaption);
      if (default_slot)
        default_slot.l(figcaption_nodes);
      figcaption_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figcaption, "class", figcaption_class_value = "conic-caption " + cCaption);
      add_location(figcaption, file8, 45, 2, 1350);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figcaption, anchor);
      if (default_slot) {
        default_slot.m(figcaption, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figcaption);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(45:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "concic-cone " + /*classesCone*/
      ctx[5]);
      toggle_class(
        div,
        "animate-spin",
        /*spin*/
        ctx[1]
      );
      set_style(
        div,
        "background",
        /*cone*/
        ctx[3]
      );
      add_location(div, file8, 49, 2, 1463);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*classesCone*/
      32 && div_class_value !== (div_class_value = "concic-cone " + /*classesCone*/
      ctx2[5])) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & /*classesCone, spin*/
      34) {
        toggle_class(
          div,
          "animate-spin",
          /*spin*/
          ctx2[1]
        );
      }
      if (dirty & /*cone*/
      8) {
        set_style(
          div,
          "background",
          /*cone*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(49:1) {#if cone}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let ul;
  let ul_class_value;
  let each_value = (
    /*generatedLegendList*/
    ctx[4]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", ul_class_value = "conic-list list " + cLabel2);
      add_location(ul, file8, 53, 2, 1618);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*hover, generatedLegendList, cSwatch*/
      20) {
        each_value = /*generatedLegendList*/
        ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(53:1) {#if legend && generatedLegendList}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let li;
  let span0;
  let span0_class_value;
  let t0;
  let span1;
  let t1_value = (
    /*label*/
    ctx[21] + ""
  );
  let t1;
  let t2;
  let strong;
  let t3_value = (
    /*value*/
    ctx[22] + ""
  );
  let t3;
  let t4;
  let t5;
  let li_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      strong = element("strong");
      t3 = text(t3_value);
      t4 = text("%");
      t5 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      span0 = claim_element(li_nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      t0 = claim_space(li_nodes);
      span1 = claim_element(li_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      span1_nodes.forEach(detach_dev);
      t2 = claim_space(li_nodes);
      strong = claim_element(li_nodes, "STRONG", { class: true });
      var strong_nodes = children(strong);
      t3 = claim_text(strong_nodes, t3_value);
      t4 = claim_text(strong_nodes, "%");
      strong_nodes.forEach(detach_dev);
      t5 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = "conic-swatch " + cSwatch);
      set_style(
        span0,
        "background",
        /*color*/
        ctx[20]
      );
      add_location(span0, file8, 56, 5, 1796);
      attr_dev(span1, "class", "conic-label flex-auto");
      add_location(span1, file8, 57, 5, 1866);
      attr_dev(strong, "class", "conic-value");
      add_location(strong, file8, 58, 5, 1922);
      attr_dev(li, "class", li_class_value = "conic-item " + /*hover*/
      ctx[2]);
      add_location(li, file8, 55, 4, 1718);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, span0);
      append_hydration_dev(li, t0);
      append_hydration_dev(li, span1);
      append_hydration_dev(span1, t1);
      append_hydration_dev(li, t2);
      append_hydration_dev(li, strong);
      append_hydration_dev(strong, t3);
      append_hydration_dev(strong, t4);
      append_hydration_dev(li, t5);
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "click",
            /*click_handler*/
            ctx[12],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keydown",
            /*keydown_handler*/
            ctx[13],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keyup",
            /*keyup_handler*/
            ctx[14],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keypress",
            /*keypress_handler*/
            ctx[15],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*generatedLegendList*/
      16) {
        set_style(
          span0,
          "background",
          /*color*/
          ctx2[20]
        );
      }
      if (dirty & /*generatedLegendList*/
      16 && t1_value !== (t1_value = /*label*/
      ctx2[21] + ""))
        set_data_dev(t1, t1_value);
      if (dirty & /*generatedLegendList*/
      16 && t3_value !== (t3_value = /*value*/
      ctx2[22] + ""))
        set_data_dev(t3, t3_value);
      if (dirty & /*hover*/
      4 && li_class_value !== (li_class_value = "conic-item " + /*hover*/
      ctx2[2])) {
        attr_dev(li, "class", li_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(55:3) {#each generatedLegendList as { color, label, value }}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let figure;
  let t0;
  let t1;
  let figure_class_value;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[7].default && create_if_block_22(ctx)
  );
  let if_block1 = (
    /*cone*/
    ctx[3] && create_if_block_13(ctx)
  );
  let if_block2 = (
    /*legend*/
    ctx[0] && /*generatedLegendList*/
    ctx[4] && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      figure = element("figure");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", { class: true, "data-testid": true });
      var figure_nodes = children(figure);
      if (if_block0)
        if_block0.l(figure_nodes);
      t0 = claim_space(figure_nodes);
      if (if_block1)
        if_block1.l(figure_nodes);
      t1 = claim_space(figure_nodes);
      if (if_block2)
        if_block2.l(figure_nodes);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figure, "class", figure_class_value = "conic-gradient " + /*classesBase*/
      ctx[6]);
      attr_dev(figure, "data-testid", "conic-gradient");
      add_location(figure, file8, 42, 0, 1234);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      if (if_block0)
        if_block0.m(figure, null);
      append_hydration_dev(figure, t0);
      if (if_block1)
        if_block1.m(figure, null);
      append_hydration_dev(figure, t1);
      if (if_block2)
        if_block2.m(figure, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[7].default
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_22(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(figure, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*cone*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_13(ctx2);
          if_block1.c();
          if_block1.m(figure, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*legend*/
        ctx2[0] && /*generatedLegendList*/
        ctx2[4]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block6(ctx2);
          if_block2.c();
          if_block2.m(figure, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & /*classesBase*/
      64 && figure_class_value !== (figure_class_value = "conic-gradient " + /*classesBase*/
      ctx2[6])) {
        attr_dev(figure, "class", figure_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figure);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase5 = "flex flex-col items-center space-y-4";
var cCaption = "text-center";
var cCone = "block aspect-square rounded-full";
var cLabel2 = "text-sm w-full";
var cSwatch = "block aspect-square bg-black w-5 rounded-full mr-2";
function instance8($$self, $$props, $$invalidate) {
  let classesBase;
  let classesCone;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ConicGradient", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { stops = [
    {
      color: ["neutral", 500],
      start: 0,
      end: 100
    }
  ] } = $$props;
  let { legend = false } = $$props;
  let { spin = false } = $$props;
  let { width = "w-full" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let cone;
  let generatedLegendList;
  function setColorValue(color) {
    if (typeof color === "string")
      return color;
    const colorSet = tailwindDefaultColors.find((c) => c.label === color[0]);
    return colorSet == null ? void 0 : colorSet.shades[color[1]].hex;
  }
  function genConicGradient() {
    let d = stops.map((v) => `${setColorValue(v.color)} ${v.start}% ${v.end}%`);
    $$invalidate(3, cone = `conic-gradient(${d.join(", ")})`);
  }
  function genLegend() {
    if (!legend)
      return;
    $$invalidate(4, generatedLegendList = stops.map((v) => {
      return {
        label: v.label,
        color: setColorValue(v.color),
        value: v.end - v.start
      };
    }));
  }
  genConicGradient();
  genLegend();
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("stops" in $$new_props)
      $$invalidate(8, stops = $$new_props.stops);
    if ("legend" in $$new_props)
      $$invalidate(0, legend = $$new_props.legend);
    if ("spin" in $$new_props)
      $$invalidate(1, spin = $$new_props.spin);
    if ("width" in $$new_props)
      $$invalidate(9, width = $$new_props.width);
    if ("hover" in $$new_props)
      $$invalidate(2, hover = $$new_props.hover);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tailwindDefaultColors,
    stops,
    legend,
    spin,
    width,
    hover,
    cone,
    generatedLegendList,
    cBase: cBase5,
    cCaption,
    cCone,
    cLabel: cLabel2,
    cSwatch,
    setColorValue,
    genConicGradient,
    genLegend,
    classesCone,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(19, $$props = assign(assign({}, $$props), $$new_props));
    if ("stops" in $$props)
      $$invalidate(8, stops = $$new_props.stops);
    if ("legend" in $$props)
      $$invalidate(0, legend = $$new_props.legend);
    if ("spin" in $$props)
      $$invalidate(1, spin = $$new_props.spin);
    if ("width" in $$props)
      $$invalidate(9, width = $$new_props.width);
    if ("hover" in $$props)
      $$invalidate(2, hover = $$new_props.hover);
    if ("cone" in $$props)
      $$invalidate(3, cone = $$new_props.cone);
    if ("generatedLegendList" in $$props)
      $$invalidate(4, generatedLegendList = $$new_props.generatedLegendList);
    if ("classesCone" in $$props)
      $$invalidate(5, classesCone = $$new_props.classesCone);
    if ("classesBase" in $$props)
      $$invalidate(6, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesBase = `${cBase5} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*width*/
    512) {
      $:
        $$invalidate(5, classesCone = `${cCone} ${width}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    legend,
    spin,
    hover,
    cone,
    generatedLegendList,
    classesCone,
    classesBase,
    $$slots,
    stops,
    width,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var ConicGradient = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      stops: 8,
      legend: 0,
      spin: 1,
      width: 9,
      hover: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ConicGradient",
      options,
      id: create_fragment8.name
    });
  }
  get stops() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stops(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ConicGradient_default = ConicGradient;

// node_modules/@skeletonlabs/skeleton/components/FileButton/FileButton.svelte
var file9 = "node_modules/@skeletonlabs/skeleton/components/FileButton/FileButton.svelte";
function create_fragment9(ctx) {
  let div;
  let input;
  let t;
  let button_1;
  let button_1_class_value;
  let button_1_disabled_value;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "file" },
    /*prunedRestProps*/
    ctx[4](),
    { class: "file-button-input hidden" }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      button_1 = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", { type: true, class: true });
      t = claim_space(div_nodes);
      button_1 = claim_element(div_nodes, "BUTTON", { class: true, type: true });
      var button_1_nodes = children(button_1);
      if (default_slot)
        default_slot.l(button_1_nodes);
      button_1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file9, 14, 1, 336);
      attr_dev(button_1, "class", button_1_class_value = "file-button-btn btn " + /*button*/
      ctx[1]);
      attr_dev(button_1, "type", "button");
      button_1.disabled = button_1_disabled_value = /*$$restProps*/
      ctx[5].disabled;
      add_location(button_1, file9, 16, 1, 479);
      attr_dev(div, "class", div_class_value = "file-button " + /*$$props*/
      (ctx[6].class ?? ""));
      attr_dev(div, "data-testid", "file-button");
      add_location(div, file9, 12, 0, 239);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      if (input.autofocus)
        input.focus();
      ctx[13](input);
      append_hydration_dev(div, t);
      append_hydration_dev(div, button_1);
      if (default_slot) {
        default_slot.m(button_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[14]
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[12],
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "click",
            /*onButtonClick*/
            ctx[3],
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "keydown",
            /*keydown_handler*/
            ctx[9],
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "keyup",
            /*keyup_handler*/
            ctx[10],
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "keypress",
            /*keypress_handler*/
            ctx[11],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "file" },
        /*prunedRestProps*/
        ctx2[4](),
        { class: "file-button-input hidden" }
      ]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*button*/
      2 && button_1_class_value !== (button_1_class_value = "file-button-btn btn " + /*button*/
      ctx2[1])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (!current || dirty & /*$$restProps*/
      32 && button_1_disabled_value !== (button_1_disabled_value = /*$$restProps*/
      ctx2[5].disabled)) {
        prop_dev(button_1, "disabled", button_1_disabled_value);
      }
      if (!current || dirty & /*$$props*/
      64 && div_class_value !== (div_class_value = "file-button " + /*$$props*/
      (ctx2[6].class ?? ""))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[13](null);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  const omit_props_names = ["files", "button"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileButton", slots, ["default"]);
  let { files } = $$props;
  let { button = "variant-filled-secondary" } = $$props;
  let elemFileInput;
  function onButtonClick() {
    elemFileInput.click();
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (files === void 0 && !("files" in $$props || $$self.$$.bound[$$self.$$.props["files"]])) {
      console.warn("<FileButton> was created without expected prop 'files'");
    }
  });
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemFileInput = $$value;
      $$invalidate(2, elemFileInput);
    });
  }
  function input_change_handler() {
    files = this.files;
    $$invalidate(0, files);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("files" in $$new_props)
      $$invalidate(0, files = $$new_props.files);
    if ("button" in $$new_props)
      $$invalidate(1, button = $$new_props.button);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    files,
    button,
    elemFileInput,
    onButtonClick,
    prunedRestProps
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("files" in $$props)
      $$invalidate(0, files = $$new_props.files);
    if ("button" in $$props)
      $$invalidate(1, button = $$new_props.button);
    if ("elemFileInput" in $$props)
      $$invalidate(2, elemFileInput = $$new_props.elemFileInput);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    files,
    button,
    elemFileInput,
    onButtonClick,
    prunedRestProps,
    $$restProps,
    $$props,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    change_handler,
    input_binding,
    input_change_handler
  ];
}
var FileButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { files: 0, button: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileButton",
      options,
      id: create_fragment9.name
    });
  }
  get files() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get button() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set button(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileButton_default = FileButton;

// node_modules/@skeletonlabs/skeleton/components/FileDropzone/FileDropzone.svelte
var file10 = "node_modules/@skeletonlabs/skeleton/components/FileDropzone/FileDropzone.svelte";
function add_css2(target) {
  append_styles(target, "svelte-12i0tjl", ".svelte-12i0tjl::file-selector-button{display:none\n}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmlsZURyb3B6b25lLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiZUF1RUMsc0JBQXNCLEFBQUMsQ0FBQSxBQUNwQixPQUFPLENBQUUsSUFBQTtBQUNiLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRmlsZURyb3B6b25lLnN2ZWx0ZSJdfQ== */");
}
function create_if_block7(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "text-sm opacity-70 svelte-12i0tjl");
      add_location(div, file10, 60, 16, 1846);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      div.innerHTML = /*notes*/
      ctx[2];
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*notes*/
      4)
        div.innerHTML = /*notes*/
        ctx2[2];
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(61:5) {#if notes}",
    ctx
  });
  return block;
}
function fallback_block3(ctx) {
  let div3;
  let div0;
  let t0;
  let t1;
  let div2;
  let div1;
  let t2;
  let if_block = (
    /*notes*/
    ctx[2] && create_if_block7(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      t0 = text("");
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      t2 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "");
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      if (if_block)
        if_block.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "text-4xl flex justify-center items-center svelte-12i0tjl");
      add_location(div0, file10, 56, 4, 1596);
      attr_dev(div1, "class", "text-base font-bold svelte-12i0tjl");
      add_location(div1, file10, 59, 5, 1777);
      attr_dev(div2, "class", "flex flex-col justify-center items-start space-y-0 svelte-12i0tjl");
      add_location(div2, file10, 58, 4, 1707);
      attr_dev(div3, "class", "grid grid-cols-[auto_1fr] gap-4 svelte-12i0tjl");
      add_location(div3, file10, 54, 3, 1528);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, t0);
      ctx[23](div0);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div1);
      div1.innerHTML = /*title*/
      ctx[1];
      append_hydration_dev(div2, t2);
      if (if_block)
        if_block.m(div2, null);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2)
        div1.innerHTML = /*title*/
        ctx2[1];
      ;
      if (
        /*notes*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          if_block.m(div2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      ctx[23](null);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(53:8)     ",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let t;
  let input;
  let input_class_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block3(ctx);
  let input_levels = [
    { type: "file" },
    /*prunedRestProps*/
    ctx[10](),
    {
      class: input_class_value = "file-dropzone-input " + /*classesInput*/
      ctx[4]
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      input = claim_element(div1_nodes, "INPUT", { type: true, class: true });
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "file-dropzone-message " + /*classesMessage*/
      ctx[5] + " svelte-12i0tjl");
      add_location(div0, file10, 50, 1, 1410);
      set_attributes(input, input_data);
      toggle_class(input, "svelte-12i0tjl", true);
      add_location(input, file10, 66, 1, 1965);
      attr_dev(div1, "class", div1_class_value = "file-dropzone " + /*classesBase*/
      ctx[6] + " svelte-12i0tjl");
      attr_dev(div1, "data-testid", "file-dropzone");
      add_location(div1, file10, 37, 0, 1187);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, input);
      if (input.autofocus)
        input.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[24]
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[22],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "dragenter",
            /*dragenter_handler*/
            ctx[17],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "dragover",
            /*onDragOver*/
            ctx[7],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "dragleave",
            /*onDragLeave*/
            ctx[8],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "drop",
            /*onDrop*/
            ctx[9],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*keydown_handler*/
            ctx[19],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keyup",
            /*keyup_handler*/
            ctx[20],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[21],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*notes, title, elemIcon*/
        14)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*classesMessage*/
      32 && div0_class_value !== (div0_class_value = "file-dropzone-message " + /*classesMessage*/
      ctx2[5] + " svelte-12i0tjl")) {
        attr_dev(div0, "class", div0_class_value);
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "file" },
        /*prunedRestProps*/
        ctx2[10](),
        (!current || dirty & /*classesInput*/
        16 && input_class_value !== (input_class_value = "file-dropzone-input " + /*classesInput*/
        ctx2[4])) && { class: input_class_value }
      ]));
      toggle_class(input, "svelte-12i0tjl", true);
      if (!current || dirty & /*classesBase*/
      64 && div1_class_value !== (div1_class_value = "file-dropzone " + /*classesBase*/
      ctx2[6] + " svelte-12i0tjl")) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase6 = "relative";
var cMessage = "absolute top-0 left-0 right-0 bottom-0 z-[1] max-w-[480px] mx-auto flex justify-center items-center !pointer-events-none";
var cInput = "!border-2 border-dashed cursor-pointer !text-transparent !rounded-container-token";
function instance10($$self, $$props, $$invalidate) {
  let classesBase;
  let classesMessage;
  let classesInput;
  const omit_props_names = ["files", "title", "notes", "width", "height", "padding", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileDropzone", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { files } = $$props;
  let { title = "Drop files or click to select." } = $$props;
  let { notes = "" } = $$props;
  let { width = "w-full" } = $$props;
  let { height = "h-24" } = $$props;
  let { padding = "p-4" } = $$props;
  let { color = "" } = $$props;
  let elemIcon;
  function onDragOver(event) {
    dispatch("dragover", event);
    elemIcon == null ? void 0 : elemIcon.classList.add("animate-bounce");
  }
  function onDragLeave(event) {
    dispatch("dragleave", event);
    elemIcon == null ? void 0 : elemIcon.classList.remove("animate-bounce");
  }
  function onDrop(event) {
    dispatch("drop", event);
    elemIcon == null ? void 0 : elemIcon.classList.remove("animate-bounce");
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (files === void 0 && !("files" in $$props || $$self.$$.bound[$$self.$$.props["files"]])) {
      console.warn("<FileDropzone> was created without expected prop 'files'");
    }
  });
  function dragenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemIcon = $$value;
      $$invalidate(3, elemIcon);
    });
  }
  function input_change_handler() {
    files = this.files;
    $$invalidate(0, files);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("files" in $$new_props)
      $$invalidate(0, files = $$new_props.files);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
    if ("notes" in $$new_props)
      $$invalidate(2, notes = $$new_props.notes);
    if ("width" in $$new_props)
      $$invalidate(11, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(12, height = $$new_props.height);
    if ("padding" in $$new_props)
      $$invalidate(13, padding = $$new_props.padding);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    files,
    title,
    notes,
    width,
    height,
    padding,
    color,
    cBase: cBase6,
    cMessage,
    cInput,
    elemIcon,
    onDragOver,
    onDragLeave,
    onDrop,
    prunedRestProps,
    classesInput,
    classesMessage,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
    if ("files" in $$props)
      $$invalidate(0, files = $$new_props.files);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("notes" in $$props)
      $$invalidate(2, notes = $$new_props.notes);
    if ("width" in $$props)
      $$invalidate(11, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(12, height = $$new_props.height);
    if ("padding" in $$props)
      $$invalidate(13, padding = $$new_props.padding);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("elemIcon" in $$props)
      $$invalidate(3, elemIcon = $$new_props.elemIcon);
    if ("classesInput" in $$props)
      $$invalidate(4, classesInput = $$new_props.classesInput);
    if ("classesMessage" in $$props)
      $$invalidate(5, classesMessage = $$new_props.classesMessage);
    if ("classesBase" in $$props)
      $$invalidate(6, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesBase = `${cBase6} ${width} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*color, height, padding*/
    28672) {
      $:
        $$invalidate(5, classesMessage = `${cMessage} ${color} ${height} ${padding}`);
    }
    if ($$self.$$.dirty & /*height, padding*/
    12288) {
      $:
        $$invalidate(4, classesInput = `${cInput} ${height} ${padding}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    files,
    title,
    notes,
    elemIcon,
    classesInput,
    classesMessage,
    classesBase,
    onDragOver,
    onDragLeave,
    onDrop,
    prunedRestProps,
    width,
    height,
    padding,
    color,
    $$scope,
    slots,
    dragenter_handler,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    change_handler,
    div0_binding,
    input_change_handler
  ];
}
var FileDropzone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance10,
      create_fragment10,
      safe_not_equal,
      {
        files: 0,
        title: 1,
        notes: 2,
        width: 11,
        height: 12,
        padding: 13,
        color: 14
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileDropzone",
      options,
      id: create_fragment10.name
    });
  }
  get files() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notes() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notes(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileDropzone_default = FileDropzone;

// node_modules/@skeletonlabs/skeleton/components/InputChip/InputChip.svelte
var file11 = "node_modules/@skeletonlabs/skeleton/components/InputChip/InputChip.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  child_ctx[25] = i;
  return child_ctx;
}
function create_if_block8(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*label*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*label*/
        ctx[1]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", cLabel3);
      add_location(span, file11, 57, 12, 1772);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label*/
      2)
        set_data_dev(
          t,
          /*label*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(58:1) {#if label}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let span2;
  let span0;
  let t0_value = (
    /*chip*/
    ctx[2] + ""
  );
  let t0;
  let t1;
  let span1;
  let t2;
  let span2_class_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[20](
        /*i*/
        ctx[25]
      )
    );
  }
  const block = {
    c: function create() {
      span2 = element("span");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text("");
      this.h();
    },
    l: function claim(nodes) {
      span2 = claim_element(nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      span0 = claim_element(span2_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(span2_nodes);
      span1 = claim_element(span2_nodes, "SPAN", {});
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, "");
      span1_nodes.forEach(detach_dev);
      span2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span0, file11, 61, 3, 1950);
      add_location(span1, file11, 62, 3, 1973);
      attr_dev(span2, "class", span2_class_value = "chip " + /*classesChip*/
      ctx[6]);
      add_location(span2, file11, 60, 2, 1868);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span2, anchor);
      append_hydration_dev(span2, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(span2, t1);
      append_hydration_dev(span2, span1);
      append_hydration_dev(span1, t2);
      if (!mounted) {
        dispose = [
          listen_dev(span2, "click", click_handler, false, false, false),
          listen_dev(
            span2,
            "keypress",
            /*keypress_handler*/
            ctx[19],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*value*/
      1 && t0_value !== (t0_value = /*chip*/
      ctx[2] + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*classesChip*/
      64 && span2_class_value !== (span2_class_value = "chip " + /*classesChip*/
      ctx[6])) {
        attr_dev(span2, "class", span2_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span2);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(59:1) {#each value as chip, i}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let label_1;
  let t0;
  let t1;
  let form;
  let input;
  let input_class_value;
  let label_1_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*label*/
    ctx[1] && create_if_block8(ctx)
  );
  let each_value = (
    /*value*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  let input_levels = [
    { type: "text" },
    {
      class: input_class_value = "input-chip-field " + /*classesInput*/
      ctx[5]
    },
    { tabindex: "0" },
    /*prunedRestProps*/
    ctx[11]()
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      label_1 = element("label");
      if (if_block)
        if_block.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      form = element("form");
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true });
      var label_1_nodes = children(label_1);
      if (if_block)
        if_block.l(label_1_nodes);
      t0 = claim_space(label_1_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(label_1_nodes);
      }
      t1 = claim_space(label_1_nodes);
      form = claim_element(label_1_nodes, "FORM", {});
      var form_nodes = children(form);
      input = claim_element(form_nodes, "INPUT", { type: true, class: true, tabindex: true });
      form_nodes.forEach(detach_dev);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(input, "input-invalid", !/*inputValueValid*/
      ctx[4]);
      add_location(input, file11, 66, 2, 2037);
      add_location(form, file11, 65, 1, 2008);
      attr_dev(label_1, "class", label_1_class_value = "input-chip " + /*classesBase*/
      ctx[7]);
      add_location(label_1, file11, 56, 0, 1719);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (if_block)
        if_block.m(label_1, null);
      append_hydration_dev(label_1, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(label_1, null);
      }
      append_hydration_dev(label_1, t1);
      append_hydration_dev(label_1, form);
      append_hydration_dev(form, input);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*inputValue*/
        ctx[3]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[21]
          ),
          listen_dev(
            input,
            "keydown",
            /*resetValiadtionClass*/
            ctx[8],
            false,
            false,
            false
          ),
          listen_dev(
            form,
            "submit",
            /*addChip*/
            ctx[9],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*label*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          if_block.m(label_1, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*classesChip, removeChip, value*/
      1089) {
        each_value = /*value*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(label_1, t1);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        dirty & /*classesInput*/
        32 && input_class_value !== (input_class_value = "input-chip-field " + /*classesInput*/
        ctx2[5]) && { class: input_class_value },
        { tabindex: "0" },
        /*prunedRestProps*/
        ctx2[11]()
      ]));
      if (dirty & /*inputValue*/
      8 && input.value !== /*inputValue*/
      ctx2[3]) {
        set_input_value(
          input,
          /*inputValue*/
          ctx2[3]
        );
      }
      toggle_class(input, "input-invalid", !/*inputValueValid*/
      ctx2[4]);
      if (dirty & /*classesBase*/
      128 && label_1_class_value !== (label_1_class_value = "input-chip " + /*classesBase*/
      ctx2[7])) {
        attr_dev(label_1, "class", label_1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase7 = "unstyled input-cell border-token flex flex-wrap gap-2 items-center";
var cLabel3 = "unstyled w-full md:w-auto mr-2";
var cInput2 = "unstyled flex-auto border-transparent bg-transparent text-base px-1 py-0 focus:border-transparent min-h-[30px]";
function instance11($$self, $$props, $$invalidate) {
  let classesBase;
  let classesChip;
  let classesInput;
  const omit_props_names = [
    "label",
    "value",
    "whitelist",
    "allowUpperCase",
    "allowDuplicates",
    "validation",
    "chip",
    "padding",
    "rounded",
    "ring"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputChip", slots, []);
  const dispatch = createEventDispatcher();
  let { label = "" } = $$props;
  let { value = [] } = $$props;
  let { whitelist = [] } = $$props;
  let { allowUpperCase = false } = $$props;
  let { allowDuplicates = true } = $$props;
  let { validation = () => true } = $$props;
  let { chip = `variant-filled-primary` } = $$props;
  let { padding = "p-2" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { ring = "focus:ring-transparent" } = $$props;
  let inputValue = "";
  let inputValueValid = true;
  function resetValiadtionClass() {
    $$invalidate(4, inputValueValid = true);
  }
  function addChip(event) {
    event.preventDefault();
    if (validation !== void 0 && !validation(inputValue)) {
      $$invalidate(4, inputValueValid = false);
      return;
    }
    if (whitelist.length > 0 && !whitelist.includes(inputValue)) {
      $$invalidate(4, inputValueValid = false);
      return;
    }
    if (allowDuplicates === false && value.includes(inputValue)) {
      $$invalidate(4, inputValueValid = false);
      return;
    }
    $$invalidate(3, inputValue = inputValue.trim());
    $$invalidate(3, inputValue = allowUpperCase ? inputValue : inputValue.toLowerCase());
    $$invalidate(0, value = [...value, inputValue]);
    $$invalidate(3, inputValue = "");
    dispatch("add", event);
  }
  function removeChip(chipIndex) {
    $$invalidate(0, value = value.filter((_, i) => i !== chipIndex));
    dispatch("remove", chipIndex);
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = (i) => {
    removeChip(i);
  };
  function input_input_handler() {
    inputValue = this.value;
    $$invalidate(3, inputValue);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(23, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("whitelist" in $$new_props)
      $$invalidate(12, whitelist = $$new_props.whitelist);
    if ("allowUpperCase" in $$new_props)
      $$invalidate(13, allowUpperCase = $$new_props.allowUpperCase);
    if ("allowDuplicates" in $$new_props)
      $$invalidate(14, allowDuplicates = $$new_props.allowDuplicates);
    if ("validation" in $$new_props)
      $$invalidate(15, validation = $$new_props.validation);
    if ("chip" in $$new_props)
      $$invalidate(2, chip = $$new_props.chip);
    if ("padding" in $$new_props)
      $$invalidate(16, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(17, rounded = $$new_props.rounded);
    if ("ring" in $$new_props)
      $$invalidate(18, ring = $$new_props.ring);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    label,
    value,
    whitelist,
    allowUpperCase,
    allowDuplicates,
    validation,
    chip,
    padding,
    rounded,
    ring,
    inputValue,
    inputValueValid,
    cBase: cBase7,
    cLabel: cLabel3,
    cInput: cInput2,
    resetValiadtionClass,
    addChip,
    removeChip,
    prunedRestProps,
    classesInput,
    classesChip,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("whitelist" in $$props)
      $$invalidate(12, whitelist = $$new_props.whitelist);
    if ("allowUpperCase" in $$props)
      $$invalidate(13, allowUpperCase = $$new_props.allowUpperCase);
    if ("allowDuplicates" in $$props)
      $$invalidate(14, allowDuplicates = $$new_props.allowDuplicates);
    if ("validation" in $$props)
      $$invalidate(15, validation = $$new_props.validation);
    if ("chip" in $$props)
      $$invalidate(2, chip = $$new_props.chip);
    if ("padding" in $$props)
      $$invalidate(16, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(17, rounded = $$new_props.rounded);
    if ("ring" in $$props)
      $$invalidate(18, ring = $$new_props.ring);
    if ("inputValue" in $$props)
      $$invalidate(3, inputValue = $$new_props.inputValue);
    if ("inputValueValid" in $$props)
      $$invalidate(4, inputValueValid = $$new_props.inputValueValid);
    if ("classesInput" in $$props)
      $$invalidate(5, classesInput = $$new_props.classesInput);
    if ("classesChip" in $$props)
      $$invalidate(6, classesChip = $$new_props.classesChip);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*padding, rounded*/
    196608) {
      $:
        $$invalidate(7, classesBase = `${cBase7} ${padding} ${rounded}`);
    }
    if ($$self.$$.dirty & /*chip*/
    4) {
      $:
        $$invalidate(6, classesChip = `${chip}`);
    }
    if ($$self.$$.dirty & /*ring*/
    262144) {
      $:
        $$invalidate(5, classesInput = `${cInput2} ${ring}`);
    }
  };
  return [
    value,
    label,
    chip,
    inputValue,
    inputValueValid,
    classesInput,
    classesChip,
    classesBase,
    resetValiadtionClass,
    addChip,
    removeChip,
    prunedRestProps,
    whitelist,
    allowUpperCase,
    allowDuplicates,
    validation,
    padding,
    rounded,
    ring,
    keypress_handler,
    click_handler,
    input_input_handler
  ];
}
var InputChip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      label: 1,
      value: 0,
      whitelist: 12,
      allowUpperCase: 13,
      allowDuplicates: 14,
      validation: 15,
      chip: 2,
      padding: 16,
      rounded: 17,
      ring: 18
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputChip",
      options,
      id: create_fragment11.name
    });
  }
  get label() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get whitelist() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set whitelist(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowUpperCase() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowUpperCase(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowDuplicates() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowDuplicates(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validation() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validation(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chip() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chip(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ring() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ring(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputChip_default = InputChip;

// node_modules/@skeletonlabs/skeleton/components/ListBox/ListBox.svelte
var file12 = "node_modules/@skeletonlabs/skeleton/components/ListBox/ListBox.svelte";
function create_if_block9(ctx) {
  let span;
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*label*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, id: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*label*/
        ctx[2]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = "listbox-label " + /*classesLabel*/
      ctx[5] + " " + /*regionLabel*/
      ctx[0]);
      attr_dev(
        span,
        "id",
        /*labelId*/
        ctx[3]
      );
      add_location(span, file12, 31, 12, 998);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label*/
      4)
        set_data_dev(
          t,
          /*label*/
          ctx2[2]
        );
      if (dirty & /*classesLabel, regionLabel*/
      33 && span_class_value !== (span_class_value = "listbox-label " + /*classesLabel*/
      ctx2[5] + " " + /*regionLabel*/
      ctx2[0])) {
        attr_dev(span, "class", span_class_value);
      }
      if (dirty & /*labelId*/
      8) {
        attr_dev(
          span,
          "id",
          /*labelId*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(32:1) {#if label}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let div;
  let t;
  let ul;
  let ul_class_value;
  let div_class_value;
  let current;
  let if_block = (
    /*label*/
    ctx[2] && create_if_block9(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      t = claim_space(div_nodes);
      ul = claim_element(div_nodes, "UL", {
        class: true,
        role: true,
        "aria-labelledby": true
      });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", ul_class_value = "listbox-list " + /*classesListBox*/
      ctx[4] + " " + /*regionList*/
      ctx[1]);
      attr_dev(ul, "role", "listbox");
      attr_dev(
        ul,
        "aria-labelledby",
        /*labelId*/
        ctx[3]
      );
      add_location(ul, file12, 33, 1, 1107);
      attr_dev(div, "class", div_class_value = "listbox " + /*classesBase*/
      ctx[6]);
      attr_dev(div, "data-testid", "listbox-area");
      add_location(div, file12, 29, 0, 907);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_hydration_dev(div, t);
      append_hydration_dev(div, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*label*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesListBox, regionList*/
      18 && ul_class_value !== (ul_class_value = "listbox-list " + /*classesListBox*/
      ctx2[4] + " " + /*regionList*/
      ctx2[1])) {
        attr_dev(ul, "class", ul_class_value);
      }
      if (!current || dirty & /*labelId*/
      8) {
        attr_dev(
          ul,
          "aria-labelledby",
          /*labelId*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*classesBase*/
      64 && div_class_value !== (div_class_value = "listbox " + /*classesBase*/
      ctx2[6])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase8 = "space-y-4";
var cLabel4 = "font-bold text-lg";
var cListBox = "list-none overflow-y-auto";
function instance12($$self, $$props, $$invalidate) {
  let classesBase;
  let classesLabel;
  let classesListBox;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBox", slots, ["default"]);
  let { selected = writable(void 0) } = $$props;
  let { space: space2 = "space-y-1" } = $$props;
  let { height = "" } = $$props;
  let { accent = "!bg-primary-active-token" } = $$props;
  let { padding = "px-4 py-3" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { regionLabel = "" } = $$props;
  let { regionList = "" } = $$props;
  let { label = "" } = $$props;
  let { labelId = label == null ? void 0 : label.toLowerCase().replace(" ", "-") } = $$props;
  setContext("selected", selected);
  setContext("accent", accent);
  setContext("padding", padding);
  setContext("rounded", rounded);
  setContext("hover", hover);
  $$self.$$set = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selected" in $$new_props)
      $$invalidate(7, selected = $$new_props.selected);
    if ("space" in $$new_props)
      $$invalidate(8, space2 = $$new_props.space);
    if ("height" in $$new_props)
      $$invalidate(9, height = $$new_props.height);
    if ("accent" in $$new_props)
      $$invalidate(10, accent = $$new_props.accent);
    if ("padding" in $$new_props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("hover" in $$new_props)
      $$invalidate(13, hover = $$new_props.hover);
    if ("regionLabel" in $$new_props)
      $$invalidate(0, regionLabel = $$new_props.regionLabel);
    if ("regionList" in $$new_props)
      $$invalidate(1, regionList = $$new_props.regionList);
    if ("label" in $$new_props)
      $$invalidate(2, label = $$new_props.label);
    if ("labelId" in $$new_props)
      $$invalidate(3, labelId = $$new_props.labelId);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    writable,
    selected,
    space: space2,
    height,
    accent,
    padding,
    rounded,
    hover,
    regionLabel,
    regionList,
    label,
    labelId,
    cBase: cBase8,
    cLabel: cLabel4,
    cListBox,
    classesListBox,
    classesLabel,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(7, selected = $$new_props.selected);
    if ("space" in $$props)
      $$invalidate(8, space2 = $$new_props.space);
    if ("height" in $$props)
      $$invalidate(9, height = $$new_props.height);
    if ("accent" in $$props)
      $$invalidate(10, accent = $$new_props.accent);
    if ("padding" in $$props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("hover" in $$props)
      $$invalidate(13, hover = $$new_props.hover);
    if ("regionLabel" in $$props)
      $$invalidate(0, regionLabel = $$new_props.regionLabel);
    if ("regionList" in $$props)
      $$invalidate(1, regionList = $$new_props.regionList);
    if ("label" in $$props)
      $$invalidate(2, label = $$new_props.label);
    if ("labelId" in $$props)
      $$invalidate(3, labelId = $$new_props.labelId);
    if ("classesListBox" in $$props)
      $$invalidate(4, classesListBox = $$new_props.classesListBox);
    if ("classesLabel" in $$props)
      $$invalidate(5, classesLabel = $$new_props.classesLabel);
    if ("classesBase" in $$props)
      $$invalidate(6, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesBase = `${cBase8} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*height, space*/
    768) {
      $:
        $$invalidate(4, classesListBox = `${cListBox} ${height} ${space2}`);
    }
  };
  $:
    $$invalidate(5, classesLabel = `${cLabel4}`);
  $$props = exclude_internal_props($$props);
  return [
    regionLabel,
    regionList,
    label,
    labelId,
    classesListBox,
    classesLabel,
    classesBase,
    selected,
    space2,
    height,
    accent,
    padding,
    rounded,
    hover,
    $$scope,
    slots
  ];
}
var ListBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      selected: 7,
      space: 8,
      height: 9,
      accent: 10,
      padding: 11,
      rounded: 12,
      hover: 13,
      regionLabel: 0,
      regionList: 1,
      label: 2,
      labelId: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBox",
      options,
      id: create_fragment12.name
    });
  }
  get selected() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get space() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set space(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionList() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionList(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelId() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelId(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBox_default = ListBox;

// node_modules/@skeletonlabs/skeleton/components/ListBox/ListBoxItem.svelte
var file13 = "node_modules/@skeletonlabs/skeleton/components/ListBox/ListBoxItem.svelte";
var get_trail_slot_changes3 = (dirty) => ({});
var get_trail_slot_context3 = (ctx) => ({});
var get_lead_slot_changes4 = (dirty) => ({});
var get_lead_slot_context4 = (ctx) => ({});
function create_if_block_14(ctx) {
  let span;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[16].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_lead_slot_context4
  );
  const block = {
    c: function create() {
      span = element("span");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (lead_slot)
        lead_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "listbox-item-lead");
      add_location(span, file13, 66, 19, 1815);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (lead_slot) {
        lead_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_lead_slot_changes4
            ),
            get_lead_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(67:1) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let span;
  let current;
  const trail_slot_template = (
    /*#slots*/
    ctx[16].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_trail_slot_context3
  );
  const block = {
    c: function create() {
      span = element("span");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (trail_slot)
        trail_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "listbox-item-trail");
      add_location(span, file13, 70, 20, 2003);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (trail_slot) {
        trail_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_trail_slot_changes3
            ),
            get_trail_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(71:1) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let li;
  let t0;
  let div;
  let t1;
  let li_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[7].lead && create_if_block_14(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  let if_block1 = (
    /*$$slots*/
    ctx[7].trail && create_if_block10(ctx)
  );
  const block = {
    c: function create() {
      li = element("li");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        class: true,
        id: true,
        role: true,
        "aria-selected": true,
        tabindex: true,
        "data-testid": true
      });
      var li_nodes = children(li);
      if (if_block0)
        if_block0.l(li_nodes);
      t0 = claim_space(li_nodes);
      div = claim_element(li_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      if (if_block1)
        if_block1.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "listbox-item-content flex-1");
      add_location(div, file13, 68, 1, 1905);
      attr_dev(li, "class", li_class_value = "listbox-item " + /*classesBase*/
      ctx[4]);
      attr_dev(
        li,
        "id",
        /*id*/
        ctx[0]
      );
      attr_dev(li, "role", "option");
      attr_dev(
        li,
        "aria-selected",
        /*isSelected*/
        ctx[2]
      );
      attr_dev(li, "tabindex", "0");
      attr_dev(li, "data-testid", "listbox-item");
      add_location(li, file13, 52, 0, 1546);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (if_block0)
        if_block0.m(li, null);
      append_hydration_dev(li, t0);
      append_hydration_dev(li, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(li, t1);
      if (if_block1)
        if_block1.m(li, null);
      ctx[19](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "click",
            /*onClickHandler*/
            ctx[5],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keydown",
            /*onKeyDown*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keyup",
            /*keyup_handler*/
            ctx[17],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keypress",
            /*keypress_handler*/
            ctx[18],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[7].lead
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(li, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*$$slots*/
        ctx2[7].trail
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block10(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(li, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      16 && li_class_value !== (li_class_value = "listbox-item " + /*classesBase*/
      ctx2[4])) {
        attr_dev(li, "class", li_class_value);
      }
      if (!current || dirty & /*id*/
      1) {
        attr_dev(
          li,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*isSelected*/
      4) {
        attr_dev(
          li,
          "aria-selected",
          /*isSelected*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase9 = "flex items-center space-x-4 whitespace-nowrap cursor-pointer -outline-offset-[3px]";
function instance13($$self, $$props, $$invalidate) {
  let selectionMatch;
  let isSelected;
  let classesHighlight;
  let classesBase;
  let $selected, $$unsubscribe_selected = noop, $$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, ($$value) => $$invalidate(14, $selected = $$value)), selected);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selected());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxItem", slots, ["lead", "default", "trail"]);
  const $$slots = compute_slots(slots);
  let { id = "" } = $$props;
  const dispatch = createEventDispatcher();
  let { selected = getContext("selected") } = $$props;
  validate_store(selected, "selected");
  $$subscribe_selected();
  let { accent = getContext("accent") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let elemItem;
  function onClickHandler(event) {
    if (!$$props.value)
      return;
    Array.isArray($selected) === true ? handleMultiSelect() : handleSingleSelect();
    dispatch("click", event);
  }
  function handleSingleSelect() {
    selected.set($$props.value);
  }
  function handleMultiSelect() {
    const v = $$props.value;
    const local = $selected;
    if (local.includes(v)) {
      local.splice(local.indexOf(v), 1);
      selected.set(local);
    } else {
      selected.set([...local, v]);
    }
  }
  function onKeyDown(event) {
    dispatch("keydown", event);
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      elemItem.click();
    }
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemItem = $$value;
      $$invalidate(3, elemItem);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("selected" in $$new_props)
      $$subscribe_selected($$invalidate(1, selected = $$new_props.selected));
    if ("accent" in $$new_props)
      $$invalidate(8, accent = $$new_props.accent);
    if ("padding" in $$new_props)
      $$invalidate(9, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(10, rounded = $$new_props.rounded);
    if ("hover" in $$new_props)
      $$invalidate(11, hover = $$new_props.hover);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    id,
    dispatch,
    selected,
    accent,
    padding,
    rounded,
    hover,
    cBase: cBase9,
    elemItem,
    onClickHandler,
    handleSingleSelect,
    handleMultiSelect,
    onKeyDown,
    classesHighlight,
    classesBase,
    isSelected,
    selectionMatch,
    $selected
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("id" in $$props)
      $$invalidate(0, id = $$new_props.id);
    if ("selected" in $$props)
      $$subscribe_selected($$invalidate(1, selected = $$new_props.selected));
    if ("accent" in $$props)
      $$invalidate(8, accent = $$new_props.accent);
    if ("padding" in $$props)
      $$invalidate(9, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(10, rounded = $$new_props.rounded);
    if ("hover" in $$props)
      $$invalidate(11, hover = $$new_props.hover);
    if ("elemItem" in $$props)
      $$invalidate(3, elemItem = $$new_props.elemItem);
    if ("classesHighlight" in $$props)
      $$invalidate(12, classesHighlight = $$new_props.classesHighlight);
    if ("classesBase" in $$props)
      $$invalidate(4, classesBase = $$new_props.classesBase);
    if ("isSelected" in $$props)
      $$invalidate(2, isSelected = $$new_props.isSelected);
    if ("selectionMatch" in $$props)
      $$invalidate(13, selectionMatch = $$new_props.selectionMatch);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(13, selectionMatch = () => {
        if ($selected && $$props.value) {
          return typeof $selected === "object" ? $selected.includes($$props.value) : $selected === $$props.value;
        }
        return false;
      });
    if ($$self.$$.dirty & /*selectionMatch*/
    8192) {
      $:
        $$invalidate(2, isSelected = selectionMatch() ? true : false);
    }
    if ($$self.$$.dirty & /*isSelected, accent, hover*/
    2308) {
      $:
        $$invalidate(12, classesHighlight = isSelected ? `${accent}` : `${hover}`);
    }
    $:
      $$invalidate(4, classesBase = `${cBase9} ${padding} ${rounded} ${classesHighlight} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    id,
    selected,
    isSelected,
    elemItem,
    classesBase,
    onClickHandler,
    onKeyDown,
    $$slots,
    accent,
    padding,
    rounded,
    hover,
    classesHighlight,
    selectionMatch,
    $selected,
    $$scope,
    slots,
    keyup_handler,
    keypress_handler,
    li_binding
  ];
}
var ListBoxItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      id: 0,
      selected: 1,
      accent: 8,
      padding: 9,
      rounded: 10,
      hover: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxItem",
      options,
      id: create_fragment13.name
    });
  }
  get id() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxItem_default = ListBoxItem;

// node_modules/@skeletonlabs/skeleton/components/Paginator/Paginator.svelte
var file14 = "node_modules/@skeletonlabs/skeleton/components/Paginator/Paginator.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function create_each_block3(ctx) {
  let option;
  let t0_value = (
    /*amount*/
    ctx[22] + ""
  );
  let t0;
  let t1;
  let t2;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(
        /*amountText*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, t0_value);
      t1 = claim_space(option_nodes);
      t2 = claim_text(
        option_nodes,
        /*amountText*/
        ctx[2]
      );
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*amount*/
      ctx[22];
      option.value = option.__value;
      add_location(option, file14, 41, 37, 1431);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t0);
      append_hydration_dev(option, t1);
      append_hydration_dev(option, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*settings*/
      1 && t0_value !== (t0_value = /*amount*/
      ctx2[22] + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*amountText*/
      4)
        set_data_dev(
          t2,
          /*amountText*/
          ctx2[2]
        );
      if (dirty & /*settings*/
      1 && option_value_value !== (option_value_value = /*amount*/
      ctx2[22])) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(42:3) {#each settings.amounts as amount}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let div1;
  let label;
  let select_1;
  let select_1_class_value;
  let label_class_value;
  let t0;
  let span1;
  let t1_value = (
    /*settings*/
    ctx[0].offset * /*settings*/
    ctx[0].limit + 1 + ""
  );
  let t1;
  let t2;
  let t3_value = Math.min(
    /*settings*/
    ctx[0].offset * /*settings*/
    ctx[0].limit + /*settings*/
    ctx[0].limit,
    /*settings*/
    ctx[0].size
  ) + "";
  let t3;
  let t4;
  let span0;
  let t5;
  let t6;
  let strong;
  let t7_value = (
    /*settings*/
    ctx[0].size + ""
  );
  let t7;
  let span1_class_value;
  let t8;
  let div0;
  let button0;
  let button0_disabled_value;
  let t9;
  let button1;
  let button1_disabled_value;
  let div1_class_value;
  let mounted;
  let dispose;
  let each_value = (
    /*settings*/
    ctx[0].amounts
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      label = element("label");
      select_1 = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = text(" - ");
      t3 = text(t3_value);
      t4 = space();
      span0 = element("span");
      t5 = text("/");
      t6 = space();
      strong = element("strong");
      t7 = text(t7_value);
      t8 = space();
      div0 = element("div");
      button0 = element("button");
      t9 = space();
      button1 = element("button");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      label = claim_element(div1_nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      select_1 = claim_element(label_nodes, "SELECT", { class: true, "aria-label": true });
      var select_1_nodes = children(select_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_1_nodes);
      }
      select_1_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      span1 = claim_element(div1_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      t2 = claim_text(span1_nodes, " - ");
      t3 = claim_text(span1_nodes, t3_value);
      t4 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t5 = claim_text(span0_nodes, "/");
      span0_nodes.forEach(detach_dev);
      t6 = claim_space(span1_nodes);
      strong = claim_element(span1_nodes, "STRONG", {});
      var strong_nodes = children(strong);
      t7 = claim_text(strong_nodes, t7_value);
      strong_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      t8 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button0 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      button0_nodes.forEach(detach_dev);
      t9 = claim_space(div0_nodes);
      button1 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      button1_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(select_1, "class", select_1_class_value = "paginator-select " + /*classesSelect*/
      ctx[7]);
      select_1.disabled = /*disabled*/
      ctx[1];
      attr_dev(select_1, "aria-label", "Select Amount");
      if (
        /*settings*/
        ctx[0].limit === void 0
      )
        add_render_callback(() => (
          /*select_1_change_handler*/
          ctx[16].call(select_1)
        ));
      add_location(select_1, file14, 40, 2, 1239);
      attr_dev(label, "class", label_class_value = "paginator-label " + /*classesLabel*/
      ctx[8]);
      add_location(label, file14, 39, 1, 1190);
      attr_dev(span0, "class", "opacity-50 px-2");
      add_location(span0, file14, 46, 120, 1704);
      add_location(strong, file14, 46, 159, 1743);
      attr_dev(span1, "class", span1_class_value = "paginator-details " + /*classesPageText*/
      ctx[6]);
      add_location(span1, file14, 45, 1, 1533);
      attr_dev(
        button0,
        "class",
        /*buttonClasses*/
        ctx[3]
      );
      button0.disabled = button0_disabled_value = /*disabled*/
      ctx[1] || /*settings*/
      ctx[0].offset === 0;
      add_location(button0, file14, 50, 2, 1846);
      attr_dev(
        button1,
        "class",
        /*buttonClasses*/
        ctx[3]
      );
      button1.disabled = button1_disabled_value = /*disabled*/
      ctx[1] || /*settings*/
      (ctx[0].offset + 1) * /*settings*/
      ctx[0].limit >= /*settings*/
      ctx[0].size;
      add_location(button1, file14, 53, 2, 1998);
      attr_dev(div0, "class", "paginator-arrows space-x-2");
      add_location(div0, file14, 49, 1, 1803);
      attr_dev(div1, "class", div1_class_value = "paginator " + /*classesBase*/
      ctx[9]);
      attr_dev(div1, "data-testid", "paginator");
      add_location(div1, file14, 37, 0, 1103);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, label);
      append_hydration_dev(label, select_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select_1, null);
      }
      select_option(
        select_1,
        /*settings*/
        ctx[0].limit
      );
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, span1);
      append_hydration_dev(span1, t1);
      append_hydration_dev(span1, t2);
      append_hydration_dev(span1, t3);
      append_hydration_dev(span1, t4);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t5);
      append_hydration_dev(span1, t6);
      append_hydration_dev(span1, strong);
      append_hydration_dev(strong, t7);
      append_hydration_dev(div1, t8);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, button0);
      button0.innerHTML = /*buttonTextPrevious*/
      ctx[4];
      append_hydration_dev(div0, t9);
      append_hydration_dev(div0, button1);
      button1.innerHTML = /*buttonTextNext*/
      ctx[5];
      if (!mounted) {
        dispose = [
          listen_dev(
            select_1,
            "change",
            /*select_1_change_handler*/
            ctx[16]
          ),
          listen_dev(
            select_1,
            "change",
            /*change_handler*/
            ctx[17],
            false,
            false,
            false
          ),
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_1*/
            ctx[19],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*settings, amountText*/
      5) {
        each_value = /*settings*/
        ctx2[0].amounts;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select_1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*classesSelect*/
      128 && select_1_class_value !== (select_1_class_value = "paginator-select " + /*classesSelect*/
      ctx2[7])) {
        attr_dev(select_1, "class", select_1_class_value);
      }
      if (dirty & /*disabled*/
      2) {
        prop_dev(
          select_1,
          "disabled",
          /*disabled*/
          ctx2[1]
        );
      }
      if (dirty & /*settings*/
      1) {
        select_option(
          select_1,
          /*settings*/
          ctx2[0].limit
        );
      }
      if (dirty & /*classesLabel*/
      256 && label_class_value !== (label_class_value = "paginator-label " + /*classesLabel*/
      ctx2[8])) {
        attr_dev(label, "class", label_class_value);
      }
      if (dirty & /*settings*/
      1 && t1_value !== (t1_value = /*settings*/
      ctx2[0].offset * /*settings*/
      ctx2[0].limit + 1 + ""))
        set_data_dev(t1, t1_value);
      if (dirty & /*settings*/
      1 && t3_value !== (t3_value = Math.min(
        /*settings*/
        ctx2[0].offset * /*settings*/
        ctx2[0].limit + /*settings*/
        ctx2[0].limit,
        /*settings*/
        ctx2[0].size
      ) + ""))
        set_data_dev(t3, t3_value);
      if (dirty & /*settings*/
      1 && t7_value !== (t7_value = /*settings*/
      ctx2[0].size + ""))
        set_data_dev(t7, t7_value);
      if (dirty & /*classesPageText*/
      64 && span1_class_value !== (span1_class_value = "paginator-details " + /*classesPageText*/
      ctx2[6])) {
        attr_dev(span1, "class", span1_class_value);
      }
      if (dirty & /*buttonTextPrevious*/
      16)
        button0.innerHTML = /*buttonTextPrevious*/
        ctx2[4];
      ;
      if (dirty & /*buttonClasses*/
      8) {
        attr_dev(
          button0,
          "class",
          /*buttonClasses*/
          ctx2[3]
        );
      }
      if (dirty & /*disabled, settings*/
      3 && button0_disabled_value !== (button0_disabled_value = /*disabled*/
      ctx2[1] || /*settings*/
      ctx2[0].offset === 0)) {
        prop_dev(button0, "disabled", button0_disabled_value);
      }
      if (dirty & /*buttonTextNext*/
      32)
        button1.innerHTML = /*buttonTextNext*/
        ctx2[5];
      ;
      if (dirty & /*buttonClasses*/
      8) {
        attr_dev(
          button1,
          "class",
          /*buttonClasses*/
          ctx2[3]
        );
      }
      if (dirty & /*disabled, settings*/
      3 && button1_disabled_value !== (button1_disabled_value = /*disabled*/
      ctx2[1] || /*settings*/
      (ctx2[0].offset + 1) * /*settings*/
      ctx2[0].limit >= /*settings*/
      ctx2[0].size)) {
        prop_dev(button1, "disabled", button1_disabled_value);
      }
      if (dirty & /*classesBase*/
      512 && div1_class_value !== (div1_class_value = "paginator " + /*classesBase*/
      ctx2[9])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase10 = "flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-4";
var cLabel5 = "w-full md:w-auto";
var cPageText = "whitespace-nowrap";
function instance14($$self, $$props, $$invalidate) {
  let classesBase;
  let classesLabel;
  let classesSelect;
  let classesPageText;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Paginator", slots, []);
  const dispatch = createEventDispatcher();
  let { settings = {
    offset: 0,
    limit: 5,
    size: 0,
    amounts: [1, 2, 5, 10]
  } } = $$props;
  let { justify = "justify-between" } = $$props;
  let { text: text2 = "text-xs" } = $$props;
  let { select = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { amountText = "Items" } = $$props;
  let { buttonClasses = "btn-icon variant-filled" } = $$props;
  let { buttonTextPrevious = "&larr;" } = $$props;
  let { buttonTextNext = "&rarr;" } = $$props;
  function onChangeLength() {
    $$invalidate(0, settings.offset = 0, settings);
    dispatch("amount", settings.limit);
  }
  function onPrev() {
    $$invalidate(0, settings.offset--, settings);
    dispatch("page", settings.offset);
  }
  function onNext() {
    $$invalidate(0, settings.offset++, settings);
    dispatch("page", settings.offset);
  }
  function select_1_change_handler() {
    settings.limit = select_value(this);
    $$invalidate(0, settings);
  }
  const change_handler = () => {
    onChangeLength();
  };
  const click_handler = () => {
    onPrev();
  };
  const click_handler_1 = () => {
    onNext();
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("settings" in $$new_props)
      $$invalidate(0, settings = $$new_props.settings);
    if ("justify" in $$new_props)
      $$invalidate(13, justify = $$new_props.justify);
    if ("text" in $$new_props)
      $$invalidate(14, text2 = $$new_props.text);
    if ("select" in $$new_props)
      $$invalidate(15, select = $$new_props.select);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("amountText" in $$new_props)
      $$invalidate(2, amountText = $$new_props.amountText);
    if ("buttonClasses" in $$new_props)
      $$invalidate(3, buttonClasses = $$new_props.buttonClasses);
    if ("buttonTextPrevious" in $$new_props)
      $$invalidate(4, buttonTextPrevious = $$new_props.buttonTextPrevious);
    if ("buttonTextNext" in $$new_props)
      $$invalidate(5, buttonTextNext = $$new_props.buttonTextNext);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    settings,
    justify,
    text: text2,
    select,
    disabled,
    amountText,
    buttonClasses,
    buttonTextPrevious,
    buttonTextNext,
    cBase: cBase10,
    cLabel: cLabel5,
    cPageText,
    onChangeLength,
    onPrev,
    onNext,
    classesPageText,
    classesSelect,
    classesLabel,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    if ("settings" in $$props)
      $$invalidate(0, settings = $$new_props.settings);
    if ("justify" in $$props)
      $$invalidate(13, justify = $$new_props.justify);
    if ("text" in $$props)
      $$invalidate(14, text2 = $$new_props.text);
    if ("select" in $$props)
      $$invalidate(15, select = $$new_props.select);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("amountText" in $$props)
      $$invalidate(2, amountText = $$new_props.amountText);
    if ("buttonClasses" in $$props)
      $$invalidate(3, buttonClasses = $$new_props.buttonClasses);
    if ("buttonTextPrevious" in $$props)
      $$invalidate(4, buttonTextPrevious = $$new_props.buttonTextPrevious);
    if ("buttonTextNext" in $$props)
      $$invalidate(5, buttonTextNext = $$new_props.buttonTextNext);
    if ("classesPageText" in $$props)
      $$invalidate(6, classesPageText = $$new_props.classesPageText);
    if ("classesSelect" in $$props)
      $$invalidate(7, classesSelect = $$new_props.classesSelect);
    if ("classesLabel" in $$props)
      $$invalidate(8, classesLabel = $$new_props.classesLabel);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(9, classesBase = `${cBase10} ${justify} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*select*/
    32768) {
      $:
        $$invalidate(7, classesSelect = `${select}`);
    }
    if ($$self.$$.dirty & /*text*/
    16384) {
      $:
        $$invalidate(6, classesPageText = `${cPageText} ${text2}`);
    }
  };
  $:
    $$invalidate(8, classesLabel = `${cLabel5}`);
  $$props = exclude_internal_props($$props);
  return [
    settings,
    disabled,
    amountText,
    buttonClasses,
    buttonTextPrevious,
    buttonTextNext,
    classesPageText,
    classesSelect,
    classesLabel,
    classesBase,
    onChangeLength,
    onPrev,
    onNext,
    justify,
    text2,
    select,
    select_1_change_handler,
    change_handler,
    click_handler,
    click_handler_1
  ];
}
var Paginator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      settings: 0,
      justify: 13,
      text: 14,
      select: 15,
      disabled: 1,
      amountText: 2,
      buttonClasses: 3,
      buttonTextPrevious: 4,
      buttonTextNext: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Paginator",
      options,
      id: create_fragment14.name
    });
  }
  get settings() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get select() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set select(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get amountText() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set amountText(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClasses() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClasses(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextPrevious() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextPrevious(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextNext() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextNext(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Paginator_default = Paginator;

// node_modules/@skeletonlabs/skeleton/components/ProgressBar/ProgressBar.svelte
var file15 = "node_modules/@skeletonlabs/skeleton/components/ProgressBar/ProgressBar.svelte";
function add_css3(target) {
  append_styles(target, "svelte-meqa4r", ".animIndeterminate.svelte-meqa4r{transform-origin:0% 50%;animation:svelte-meqa4r-animIndeterminate 2s infinite linear}@keyframes svelte-meqa4r-animIndeterminate{0%{transform:translateX(0) scaleX(0)}40%{transform:translateX(0) scaleX(0.4)}100%{transform:translateX(100%) scaleX(0.5)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvZ3Jlc3NCYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRDQyxrQkFBa0IsY0FBQyxDQUFBLEFBQ2xCLGdCQUFnQixDQUFFLEVBQUUsQ0FBQyxHQUFHLENBQ3hCLFNBQVMsQ0FBRSwrQkFBaUIsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQUFDaEQsQ0FBQSxBQUVBLFdBQVcsK0JBQWtCLENBQUEsQUFDNUIsRUFBRSxBQUFDLENBQUMsQUFBQyxTQUFTLENBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxBQUFFLENBQUEsQUFDekMsR0FBRyxBQUFDLENBQUMsQUFBQyxTQUFTLENBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxBQUFFLENBQUEsQUFDNUMsSUFBSSxBQUFDLENBQUMsQUFBQyxTQUFTLENBQUUsV0FBVyxJQUFJLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxBQUFFLENBQUEsQUFDakQsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJQcm9ncmVzc0Jhci5zdmVsdGUiXX0= */");
}
function create_if_block_15(ctx) {
  let label_1;
  let t;
  let label_1_class_value;
  const block = {
    c: function create() {
      label_1 = element("label");
      t = text(
        /*label*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_1_nodes = children(label_1);
      t = claim_text(
        label_1_nodes,
        /*label*/
        ctx[0]
      );
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label_1, "for", "progress");
      attr_dev(label_1, "class", label_1_class_value = "progress-bar-label " + cBaseLabel + " svelte-meqa4r");
      add_location(label_1, file15, 31, 12, 864);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*label*/
      1)
        set_data_dev(
          t,
          /*label*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(32:1) {#if label}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "progress-bar-meter " + cBaseMeterIndeterminate + " " + /*classesMeter*/
      ctx[4] + " animIndeterminate svelte-meqa4r");
      add_location(div, file15, 38, 3, 1220);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*classesMeter*/
      16 && div_class_value !== (div_class_value = "progress-bar-meter " + cBaseMeterIndeterminate + " " + /*classesMeter*/
      ctx2[4] + " animIndeterminate svelte-meqa4r")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(38:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let div;
  let div_class_value;
  let style_width = `${/*fillPercent*/
  ctx[6]}%`;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "progress-bar-meter " + cBaseMeterDeterminate + " " + /*classesMeter*/
      ctx[4] + " svelte-meqa4r");
      set_style(div, "width", style_width);
      add_location(div, file15, 36, 3, 1104);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*classesMeter*/
      16 && div_class_value !== (div_class_value = "progress-bar-meter " + cBaseMeterDeterminate + " " + /*classesMeter*/
      ctx2[4] + " svelte-meqa4r")) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & /*fillPercent*/
      64 && style_width !== (style_width = `${/*fillPercent*/
      ctx2[6]}%`)) {
        set_style(div, "width", style_width);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(36:2) {#if value !== undefined && value >= 0}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let div1;
  let t;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let div1_aria_valuemax_value;
  let if_block0 = (
    /*label*/
    ctx[0] && create_if_block_15(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*value*/
      ctx2[1] !== void 0 && /*value*/
      ctx2[1] >= 0
    )
      return create_if_block11;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      div0 = element("div");
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-valuenow": true,
        "aria-valuemin": true,
        "aria-valuemax": true
      });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "progress-bar-track " + /*classesTrack*/
      ctx[5] + " svelte-meqa4r");
      add_location(div0, file15, 33, 1, 964);
      attr_dev(div1, "class", div1_class_value = "progress-bar " + cBase11 + " svelte-meqa4r");
      attr_dev(div1, "data-testid", "progress-bar");
      attr_dev(div1, "role", "progressbar");
      attr_dev(
        div1,
        "aria-label",
        /*label*/
        ctx[0]
      );
      attr_dev(
        div1,
        "aria-valuenow",
        /*value*/
        ctx[1]
      );
      attr_dev(
        div1,
        "aria-valuemin",
        /*min*/
        ctx[2]
      );
      attr_dev(div1, "aria-valuemax", div1_aria_valuemax_value = /*max*/
      ctx[3] - /*min*/
      ctx[2]);
      add_location(div1, file15, 21, 0, 660);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if_block1.m(div0, null);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*label*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_15(ctx2);
          if_block0.c();
          if_block0.m(div1, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div0, null);
        }
      }
      if (dirty & /*classesTrack*/
      32 && div0_class_value !== (div0_class_value = "progress-bar-track " + /*classesTrack*/
      ctx2[5] + " svelte-meqa4r")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*label*/
      1) {
        attr_dev(
          div1,
          "aria-label",
          /*label*/
          ctx2[0]
        );
      }
      if (dirty & /*value*/
      2) {
        attr_dev(
          div1,
          "aria-valuenow",
          /*value*/
          ctx2[1]
        );
      }
      if (dirty & /*min*/
      4) {
        attr_dev(
          div1,
          "aria-valuemin",
          /*min*/
          ctx2[2]
        );
      }
      if (dirty & /*max, min*/
      12 && div1_aria_valuemax_value !== (div1_aria_valuemax_value = /*max*/
      ctx2[3] - /*min*/
      ctx2[2])) {
        attr_dev(div1, "aria-valuemax", div1_aria_valuemax_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase11 = "w-full";
var cBaseLabel = "block text-sm mb-2";
var cBaseMeterDeterminate = "h-full";
var cBaseMeterIndeterminate = "h-full w-full";
function instance15($$self, $$props, $$invalidate) {
  let fillPercent;
  let classesTrack;
  let classesMeter;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressBar", slots, []);
  let { label = "" } = $$props;
  let { value = void 0 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { height = "h-2" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { meter = "bg-secondary-500" } = $$props;
  let { track = "bg-surface-200-700-token" } = $$props;
  const cBaseTrack2 = `w-full overflow-hidden`;
  $$self.$$set = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(2, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(3, max = $$new_props.max);
    if ("height" in $$new_props)
      $$invalidate(7, height = $$new_props.height);
    if ("rounded" in $$new_props)
      $$invalidate(8, rounded = $$new_props.rounded);
    if ("meter" in $$new_props)
      $$invalidate(9, meter = $$new_props.meter);
    if ("track" in $$new_props)
      $$invalidate(10, track = $$new_props.track);
  };
  $$self.$capture_state = () => ({
    label,
    value,
    min,
    max,
    height,
    rounded,
    meter,
    track,
    cBase: cBase11,
    cBaseLabel,
    cBaseTrack: cBaseTrack2,
    cBaseMeterDeterminate,
    cBaseMeterIndeterminate,
    classesMeter,
    classesTrack,
    fillPercent
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("min" in $$props)
      $$invalidate(2, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(3, max = $$new_props.max);
    if ("height" in $$props)
      $$invalidate(7, height = $$new_props.height);
    if ("rounded" in $$props)
      $$invalidate(8, rounded = $$new_props.rounded);
    if ("meter" in $$props)
      $$invalidate(9, meter = $$new_props.meter);
    if ("track" in $$props)
      $$invalidate(10, track = $$new_props.track);
    if ("classesMeter" in $$props)
      $$invalidate(4, classesMeter = $$new_props.classesMeter);
    if ("classesTrack" in $$props)
      $$invalidate(5, classesTrack = $$new_props.classesTrack);
    if ("fillPercent" in $$props)
      $$invalidate(6, fillPercent = $$new_props.fillPercent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, min, max*/
    14) {
      $:
        $$invalidate(6, fillPercent = value ? 100 * (value - min) / (max - min) : 0);
    }
    $:
      $$invalidate(5, classesTrack = `${cBaseTrack2} ${height} ${rounded} ${track} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*rounded, meter*/
    768) {
      $:
        $$invalidate(4, classesMeter = `${rounded} ${meter}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    label,
    value,
    min,
    max,
    classesMeter,
    classesTrack,
    fillPercent,
    height,
    rounded,
    meter,
    track
  ];
}
var ProgressBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        label: 0,
        value: 1,
        min: 2,
        max: 3,
        height: 7,
        rounded: 8,
        meter: 9,
        track: 10
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressBar",
      options,
      id: create_fragment15.name
    });
  }
  get label() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get meter() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meter(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get track() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set track(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressBar_default = ProgressBar;

// node_modules/@skeletonlabs/skeleton/components/ProgressRadial/ProgressRadial.svelte
var file16 = "node_modules/@skeletonlabs/skeleton/components/ProgressRadial/ProgressRadial.svelte";
function create_if_block12(ctx) {
  let text_1;
  let text_1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      text_1 = claim_svg_element(nodes, "text", {
        x: true,
        y: true,
        "text-anchor": true,
        "dominant-baseline": true,
        "font-weight": true,
        "font-size": true,
        class: true
      });
      var text_1_nodes = children(text_1);
      if (default_slot)
        default_slot.l(text_1_nodes);
      text_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "x", "50%");
      attr_dev(text_1, "y", "50%");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "dominant-baseline", "middle");
      attr_dev(text_1, "font-weight", "bold");
      attr_dev(
        text_1,
        "font-size",
        /*font*/
        ctx[5]
      );
      attr_dev(text_1, "class", text_1_class_value = "progress-radial-text " + /*fill*/
      ctx[4]);
      add_location(text_1, file16, 59, 3, 1871);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, text_1, anchor);
      if (default_slot) {
        default_slot.m(text_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*font*/
      32) {
        attr_dev(
          text_1,
          "font-size",
          /*font*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*fill*/
      16 && text_1_class_value !== (text_1_class_value = "progress-radial-text " + /*fill*/
      ctx2[4])) {
        attr_dev(text_1, "class", text_1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(text_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(59:2) {#if value != undefined && value >= 0 && $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let figure;
  let svg;
  let circle0;
  let circle0_class_value;
  let circle0_r_value;
  let circle1;
  let circle1_class_value;
  let circle1_r_value;
  let style_stroke_dasharray = `${/*circumference*/
  ctx[7]}
			${/*circumference*/
  ctx[7]}`;
  let svg_viewBox_value;
  let figure_class_value;
  let figure_aria_valuenow_value;
  let figure_aria_valuetext_value;
  let figure_aria_valuemin_value;
  let figure_aria_valuemax_value;
  let current;
  let if_block = (
    /*value*/
    ctx[0] != void 0 && /*value*/
    ctx[0] >= 0 && /*$$slots*/
    ctx[10].default && create_if_block12(ctx)
  );
  const block = {
    c: function create() {
      figure = element("figure");
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-valuenow": true,
        "aria-valuetext": true,
        "aria-valuemin": true,
        "aria-valuemax": true
      });
      var figure_nodes = children(figure);
      svg = claim_svg_element(figure_nodes, "svg", { viewBox: true, class: true });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        "stroke-width": true,
        r: true,
        cx: true,
        cy: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        "stroke-width": true,
        r: true,
        cx: true,
        cy: true
      });
      children(circle1).forEach(detach_dev);
      if (if_block)
        if_block.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "class", circle0_class_value = "progress-radial-track " + cBaseTrack + " " + /*track*/
      ctx[3]);
      attr_dev(
        circle0,
        "stroke-width",
        /*stroke*/
        ctx[1]
      );
      attr_dev(circle0, "r", circle0_r_value = baseSize / 2);
      attr_dev(circle0, "cx", "50%");
      attr_dev(circle0, "cy", "50%");
      add_location(circle0, file16, 43, 2, 1406);
      attr_dev(circle1, "class", circle1_class_value = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      ctx[2]);
      attr_dev(
        circle1,
        "stroke-width",
        /*stroke*/
        ctx[1]
      );
      attr_dev(circle1, "r", circle1_r_value = baseSize / 2);
      attr_dev(circle1, "cx", "50%");
      attr_dev(circle1, "cy", "50%");
      set_style(circle1, "stroke-dasharray", style_stroke_dasharray);
      set_style(
        circle1,
        "stroke-dashoffset",
        /*dashoffset*/
        ctx[8]
      );
      add_location(circle1, file16, 46, 2, 1545);
      attr_dev(svg, "viewBox", svg_viewBox_value = "0 0 " + baseSize + " " + baseSize);
      attr_dev(svg, "class", "rounded-full");
      toggle_class(
        svg,
        "animate-spin",
        /*value*/
        ctx[0] === void 0
      );
      add_location(svg, file16, 41, 1, 1283);
      attr_dev(figure, "class", figure_class_value = "progress-radial " + /*classesBase*/
      ctx[9]);
      attr_dev(figure, "data-testid", "progress-radial");
      attr_dev(figure, "role", "meter");
      attr_dev(
        figure,
        "aria-label",
        /*label*/
        ctx[6]
      );
      attr_dev(figure, "aria-valuenow", figure_aria_valuenow_value = /*value*/
      ctx[0] || 0);
      attr_dev(figure, "aria-valuetext", figure_aria_valuetext_value = /*value*/
      ctx[0] ? `${/*value*/
      ctx[0]}%` : "Indeterminate Spinner");
      attr_dev(figure, "aria-valuemin", figure_aria_valuemin_value = 0);
      attr_dev(figure, "aria-valuemax", figure_aria_valuemax_value = 100);
      add_location(figure, file16, 30, 0, 1017);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      append_hydration_dev(figure, svg);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      if (if_block)
        if_block.m(svg, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*track*/
      8 && circle0_class_value !== (circle0_class_value = "progress-radial-track " + cBaseTrack + " " + /*track*/
      ctx2[3])) {
        attr_dev(circle0, "class", circle0_class_value);
      }
      if (!current || dirty & /*stroke*/
      2) {
        attr_dev(
          circle0,
          "stroke-width",
          /*stroke*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*meter*/
      4 && circle1_class_value !== (circle1_class_value = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      ctx2[2])) {
        attr_dev(circle1, "class", circle1_class_value);
      }
      if (!current || dirty & /*stroke*/
      2) {
        attr_dev(
          circle1,
          "stroke-width",
          /*stroke*/
          ctx2[1]
        );
      }
      if (dirty & /*circumference*/
      128 && style_stroke_dasharray !== (style_stroke_dasharray = `${/*circumference*/
      ctx2[7]}
			${/*circumference*/
      ctx2[7]}`)) {
        set_style(circle1, "stroke-dasharray", style_stroke_dasharray);
      }
      if (dirty & /*dashoffset*/
      256) {
        set_style(
          circle1,
          "stroke-dashoffset",
          /*dashoffset*/
          ctx2[8]
        );
      }
      if (
        /*value*/
        ctx2[0] != void 0 && /*value*/
        ctx2[0] >= 0 && /*$$slots*/
        ctx2[10].default
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*value, $$slots*/
          1025) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(svg, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*value, undefined*/
      1) {
        toggle_class(
          svg,
          "animate-spin",
          /*value*/
          ctx2[0] === void 0
        );
      }
      if (!current || dirty & /*classesBase*/
      512 && figure_class_value !== (figure_class_value = "progress-radial " + /*classesBase*/
      ctx2[9])) {
        attr_dev(figure, "class", figure_class_value);
      }
      if (!current || dirty & /*label*/
      64) {
        attr_dev(
          figure,
          "aria-label",
          /*label*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*value*/
      1 && figure_aria_valuenow_value !== (figure_aria_valuenow_value = /*value*/
      ctx2[0] || 0)) {
        attr_dev(figure, "aria-valuenow", figure_aria_valuenow_value);
      }
      if (!current || dirty & /*value*/
      1 && figure_aria_valuetext_value !== (figure_aria_valuetext_value = /*value*/
      ctx2[0] ? `${/*value*/
      ctx2[0]}%` : "Indeterminate Spinner")) {
        attr_dev(figure, "aria-valuetext", figure_aria_valuetext_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figure);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase12 = "progress-radial relative overflow-hidden";
var cBaseTrack = "fill-transparent";
var cBaseMeter = "fill-transparent transition-[stroke-dashoffset] duration-200 -rotate-90 origin-[50%_50%]";
var baseSize = 512;
function instance16($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressRadial", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { value = void 0 } = $$props;
  let { stroke = 20 } = $$props;
  let { meter = "stroke-secondary-500" } = $$props;
  let { track = "stroke-surface-200 dark:stroke-surface-700" } = $$props;
  let { fill = "fill-token" } = $$props;
  let { font = 56 } = $$props;
  let { label = "" } = $$props;
  const radius = baseSize / 2;
  let circumference = radius;
  let dashoffset;
  function setProgress(percent) {
    $$invalidate(7, circumference = radius * 2 * Math.PI);
    $$invalidate(8, dashoffset = circumference - percent / 100 * circumference);
  }
  setProgress(0);
  afterUpdate(() => {
    setProgress(value === void 0 ? 25 : value);
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("stroke" in $$new_props)
      $$invalidate(1, stroke = $$new_props.stroke);
    if ("meter" in $$new_props)
      $$invalidate(2, meter = $$new_props.meter);
    if ("track" in $$new_props)
      $$invalidate(3, track = $$new_props.track);
    if ("fill" in $$new_props)
      $$invalidate(4, fill = $$new_props.fill);
    if ("font" in $$new_props)
      $$invalidate(5, font = $$new_props.font);
    if ("label" in $$new_props)
      $$invalidate(6, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    value,
    stroke,
    meter,
    track,
    fill,
    font,
    label,
    cBase: cBase12,
    cBaseTrack,
    cBaseMeter,
    baseSize,
    radius,
    circumference,
    dashoffset,
    setProgress,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("stroke" in $$props)
      $$invalidate(1, stroke = $$new_props.stroke);
    if ("meter" in $$props)
      $$invalidate(2, meter = $$new_props.meter);
    if ("track" in $$props)
      $$invalidate(3, track = $$new_props.track);
    if ("fill" in $$props)
      $$invalidate(4, fill = $$new_props.fill);
    if ("font" in $$props)
      $$invalidate(5, font = $$new_props.font);
    if ("label" in $$props)
      $$invalidate(6, label = $$new_props.label);
    if ("circumference" in $$props)
      $$invalidate(7, circumference = $$new_props.circumference);
    if ("dashoffset" in $$props)
      $$invalidate(8, dashoffset = $$new_props.dashoffset);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(9, classesBase = `${cBase12} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    stroke,
    meter,
    track,
    fill,
    font,
    label,
    circumference,
    dashoffset,
    classesBase,
    $$slots,
    $$scope,
    slots
  ];
}
var ProgressRadial = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {
      value: 0,
      stroke: 1,
      meter: 2,
      track: 3,
      fill: 4,
      font: 5,
      label: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressRadial",
      options,
      id: create_fragment16.name
    });
  }
  get value() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get meter() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meter(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get track() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set track(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get font() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set font(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressRadial_default = ProgressRadial;

// node_modules/@skeletonlabs/skeleton/components/Radio/RadioGroup.svelte
var file17 = "node_modules/@skeletonlabs/skeleton/components/Radio/RadioGroup.svelte";
function create_fragment17(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "radio-group " + /*classesGroup*/
      ctx[1]);
      attr_dev(div, "data-testid", "radio-group");
      attr_dev(div, "role", "radiogroup");
      attr_dev(
        div,
        "aria-label",
        /*label*/
        ctx[0]
      );
      add_location(div, file17, 26, 0, 1036);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesGroup*/
      2 && div_class_value !== (div_class_value = "radio-group " + /*classesGroup*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*label*/
      1) {
        attr_dev(
          div,
          "aria-label",
          /*label*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let classesGroup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioGroup", slots, ["default"]);
  let { selected = writable(void 0) } = $$props;
  let { display = "inline-flex" } = $$props;
  let { background = "bg-surface-200-700-token" } = $$props;
  let { borderWidth = "border-token" } = $$props;
  let { borderColor = "border-surface-300 dark:border-surface-600" } = $$props;
  let { padding = "px-4 py-1" } = $$props;
  let { hover = "bg-secondary-hover-token" } = $$props;
  let { accent = "bg-secondary-active-token !text-on-secondary-token" } = $$props;
  let { color = "text-surface-50" } = $$props;
  let { fill = "" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { label = "radiogroup" } = $$props;
  setContext("selected", selected);
  setContext("padding", padding);
  setContext("hover", hover);
  setContext("accent", accent);
  setContext("color", color);
  setContext("fill", fill);
  setContext("rounded", rounded);
  let cBaseGroup = `items-center p-1 overflow-hidden space-x-1 rounded-token`;
  $$self.$$set = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selected" in $$new_props)
      $$invalidate(2, selected = $$new_props.selected);
    if ("display" in $$new_props)
      $$invalidate(3, display = $$new_props.display);
    if ("background" in $$new_props)
      $$invalidate(4, background = $$new_props.background);
    if ("borderWidth" in $$new_props)
      $$invalidate(5, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$new_props)
      $$invalidate(6, borderColor = $$new_props.borderColor);
    if ("padding" in $$new_props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("hover" in $$new_props)
      $$invalidate(8, hover = $$new_props.hover);
    if ("accent" in $$new_props)
      $$invalidate(9, accent = $$new_props.accent);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(11, fill = $$new_props.fill);
    if ("rounded" in $$new_props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    writable,
    setContext,
    selected,
    display,
    background,
    borderWidth,
    borderColor,
    padding,
    hover,
    accent,
    color,
    fill,
    rounded,
    label,
    cBaseGroup,
    classesGroup
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(2, selected = $$new_props.selected);
    if ("display" in $$props)
      $$invalidate(3, display = $$new_props.display);
    if ("background" in $$props)
      $$invalidate(4, background = $$new_props.background);
    if ("borderWidth" in $$props)
      $$invalidate(5, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$props)
      $$invalidate(6, borderColor = $$new_props.borderColor);
    if ("padding" in $$props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("hover" in $$props)
      $$invalidate(8, hover = $$new_props.hover);
    if ("accent" in $$props)
      $$invalidate(9, accent = $$new_props.accent);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(11, fill = $$new_props.fill);
    if ("rounded" in $$props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("cBaseGroup" in $$props)
      $$invalidate(15, cBaseGroup = $$new_props.cBaseGroup);
    if ("classesGroup" in $$props)
      $$invalidate(1, classesGroup = $$new_props.classesGroup);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classesGroup = `${cBaseGroup} ${display} ${background} ${borderColor} ${borderWidth} ${rounded} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    label,
    classesGroup,
    selected,
    display,
    background,
    borderWidth,
    borderColor,
    padding,
    hover,
    accent,
    color,
    fill,
    rounded,
    $$scope,
    slots
  ];
}
var RadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {
      selected: 2,
      display: 3,
      background: 4,
      borderWidth: 5,
      borderColor: 6,
      padding: 7,
      hover: 8,
      accent: 9,
      color: 10,
      fill: 11,
      rounded: 12,
      label: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioGroup",
      options,
      id: create_fragment17.name
    });
  }
  get selected() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get display() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set display(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioGroup_default = RadioGroup;

// node_modules/@skeletonlabs/skeleton/components/Radio/RadioItem.svelte
var file18 = "node_modules/@skeletonlabs/skeleton/components/Radio/RadioItem.svelte";
function create_fragment18(ctx) {
  let div;
  let label_1;
  let input;
  let t;
  let label_1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  let div_levels = [
    { class: "radio-item flex-auto" },
    { role: "radio" },
    { "aria-checked": (
      /*checked*/
      ctx[3]
    ) },
    { "aria-label": (
      /*label*/
      ctx[1]
    ) },
    /*prunedRestProps*/
    ctx[7](),
    { tabindex: "0" },
    { "data-testid": "radio-item" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      label_1 = element("label");
      input = element("input");
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-checked": true,
        "aria-label": true,
        tabindex: true,
        "data-testid": true
      });
      var div_nodes = children(div);
      label_1 = claim_element(div_nodes, "LABEL", { class: true });
      var label_1_nodes = children(label_1);
      input = claim_element(label_1_nodes, "INPUT", { class: true, type: true });
      t = claim_space(label_1_nodes);
      if (default_slot)
        default_slot.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "radio-item-input hidden");
      attr_dev(input, "type", "radio");
      input.__value = /*value*/
      ctx[0];
      input.value = input.__value;
      ctx[21][0].push(input);
      add_location(input, file18, 45, 2, 1261);
      attr_dev(label_1, "class", label_1_class_value = "radio-item-label " + /*classesLabel*/
      ctx[5]);
      add_location(label_1, file18, 44, 1, 1211);
      set_attributes(div, div_data);
      add_location(div, file18, 31, 0, 994);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, label_1);
      append_hydration_dev(label_1, input);
      input.checked = input.__value === /*$selected*/
      ctx[4];
      append_hydration_dev(label_1, t);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[20]
          ),
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[17],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*onKeyDown*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keyup",
            /*keyup_handler*/
            ctx[18],
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keypress",
            /*keypress_handler*/
            ctx[19],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*value*/
      1) {
        prop_dev(
          input,
          "__value",
          /*value*/
          ctx2[0]
        );
        input.value = input.__value;
      }
      if (dirty & /*$selected*/
      16) {
        input.checked = input.__value === /*$selected*/
        ctx2[4];
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesLabel*/
      32 && label_1_class_value !== (label_1_class_value = "radio-item-label " + /*classesLabel*/
      ctx2[5])) {
        attr_dev(label_1, "class", label_1_class_value);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { class: "radio-item flex-auto" },
        { role: "radio" },
        (!current || dirty & /*checked*/
        8) && { "aria-checked": (
          /*checked*/
          ctx2[3]
        ) },
        (!current || dirty & /*label*/
        2) && { "aria-label": (
          /*label*/
          ctx2[1]
        ) },
        /*prunedRestProps*/
        ctx2[7](),
        { tabindex: "0" },
        { "data-testid": "radio-item" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[21][0].splice(
        /*$$binding_groups*/
        ctx[21][0].indexOf(input),
        1
      );
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase13 = "font-bold text-base text-center cursor-pointer whitespace-nowrap";
function instance18($$self, $$props, $$invalidate) {
  let checked;
  let classesSelected;
  let classesLabel;
  const omit_props_names = ["value", "label", "selected", "padding", "hover", "accent", "color", "fill", "rounded"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selected, $$unsubscribe_selected = noop, $$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, ($$value) => $$invalidate(4, $selected = $$value)), selected);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selected());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioItem", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { value = void 0 } = $$props;
  let { label = "" } = $$props;
  let { selected = getContext("selected") } = $$props;
  validate_store(selected, "selected");
  $$subscribe_selected();
  let { padding = getContext("padding") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { accent = getContext("accent") } = $$props;
  let { color = getContext("color") } = $$props;
  let { fill = getContext("fill") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  function onKeyDown(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      dispatch("keydown", event);
      event.target.children[0].click();
    }
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  const $$binding_groups = [[]];
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    $selected = this.__value;
    selected.set($selected);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(23, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("selected" in $$new_props)
      $$subscribe_selected($$invalidate(2, selected = $$new_props.selected));
    if ("padding" in $$new_props)
      $$invalidate(8, padding = $$new_props.padding);
    if ("hover" in $$new_props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("accent" in $$new_props)
      $$invalidate(10, accent = $$new_props.accent);
    if ("color" in $$new_props)
      $$invalidate(11, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(12, fill = $$new_props.fill);
    if ("rounded" in $$new_props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    dispatch,
    value,
    label,
    selected,
    padding,
    hover,
    accent,
    color,
    fill,
    rounded,
    cBase: cBase13,
    onKeyDown,
    prunedRestProps,
    classesSelected,
    classesLabel,
    checked,
    $selected
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("selected" in $$props)
      $$subscribe_selected($$invalidate(2, selected = $$new_props.selected));
    if ("padding" in $$props)
      $$invalidate(8, padding = $$new_props.padding);
    if ("hover" in $$props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("accent" in $$props)
      $$invalidate(10, accent = $$new_props.accent);
    if ("color" in $$props)
      $$invalidate(11, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(12, fill = $$new_props.fill);
    if ("rounded" in $$props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("classesSelected" in $$props)
      $$invalidate(14, classesSelected = $$new_props.classesSelected);
    if ("classesLabel" in $$props)
      $$invalidate(5, classesLabel = $$new_props.classesLabel);
    if ("checked" in $$props)
      $$invalidate(3, checked = $$new_props.checked);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, $selected*/
    17) {
      $:
        $$invalidate(3, checked = value === $selected);
    }
    if ($$self.$$.dirty & /*checked, accent, fill, color, hover*/
    7688) {
      $:
        $$invalidate(14, classesSelected = checked ? `${accent} ${fill} ${color}` : `${hover}`);
    }
    if ($$self.$$.dirty & /*classesSelected, padding, rounded*/
    24832) {
      $:
        $$invalidate(5, classesLabel = `${cBase13} ${classesSelected} ${padding} ${rounded}`);
    }
  };
  return [
    value,
    label,
    selected,
    checked,
    $selected,
    classesLabel,
    onKeyDown,
    prunedRestProps,
    padding,
    hover,
    accent,
    color,
    fill,
    rounded,
    classesSelected,
    $$scope,
    slots,
    click_handler,
    keyup_handler,
    keypress_handler,
    input_change_handler,
    $$binding_groups
  ];
}
var RadioItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      value: 0,
      label: 1,
      selected: 2,
      padding: 8,
      hover: 9,
      accent: 10,
      color: 11,
      fill: 12,
      rounded: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioItem",
      options,
      id: create_fragment18.name
    });
  }
  get value() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioItem_default = RadioItem;

// node_modules/@skeletonlabs/skeleton/components/RangeSlider/RangeSlider.svelte
var file19 = "node_modules/@skeletonlabs/skeleton/components/RangeSlider/RangeSlider.svelte";
var get_trail_slot_changes4 = (dirty) => ({});
var get_trail_slot_context4 = (ctx) => ({});
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function create_if_block_23(ctx) {
  let label_1;
  let label_1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      label_1 = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_1_nodes = children(label_1);
      if (default_slot)
        default_slot.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label_1, "class", label_1_class_value = "range-slider-label " + cBaseLabel2);
      attr_dev(
        label_1,
        "for",
        /*id*/
        ctx[5]
      );
      add_location(label_1, file19, 40, 22, 942);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      32) {
        attr_dev(
          label_1,
          "for",
          /*id*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(41:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let datalist;
  let datalist_id_value;
  let each_value = (
    /*tickmarks*/
    ctx[8]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      datalist = element("datalist");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      datalist = claim_element(nodes, "DATALIST", { id: true, class: true });
      var datalist_nodes = children(datalist);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(datalist_nodes);
      }
      datalist_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(datalist, "id", datalist_id_value = "tickmarks-" + /*id*/
      ctx[5]);
      attr_dev(datalist, "class", "range-slider-ticks");
      add_location(datalist, file19, 65, 2, 1420);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, datalist, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(datalist, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tickmarks*/
      256) {
        each_value = /*tickmarks*/
        ctx2[8];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(datalist, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*id*/
      32 && datalist_id_value !== (datalist_id_value = "tickmarks-" + /*id*/
      ctx2[5])) {
        attr_dev(datalist, "id", datalist_id_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(datalist);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(65:2) {#if ticked && tickmarks && tickmarks.length}",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let option;
  let option_value_value;
  let option_label_value;
  const block = {
    c: function create() {
      option = element("option");
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", { label: true });
      children(option).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*tm*/
      ctx[23];
      option.value = option.__value;
      attr_dev(option, "label", option_label_value = /*tm*/
      ctx[23]);
      add_location(option, file19, 67, 3, 1508);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tickmarks*/
      256 && option_value_value !== (option_value_value = /*tm*/
      ctx2[23])) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
      if (dirty & /*tickmarks*/
      256 && option_label_value !== (option_label_value = /*tm*/
      ctx2[23])) {
        attr_dev(option, "label", option_label_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(67:3) {#each tickmarks as tm}",
    ctx
  });
  return block;
}
function create_if_block13(ctx) {
  let div;
  let current;
  const trail_slot_template = (
    /*#slots*/
    ctx[15].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_trail_slot_context4
  );
  const block = {
    c: function create() {
      div = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (trail_slot)
        trail_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "range-slider-trail");
      add_location(div, file19, 75, 20, 1626);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (trail_slot) {
        trail_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_trail_slot_changes4
            ),
            get_trail_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(76:1) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let div1;
  let t0;
  let div0;
  let input;
  let input_class_value;
  let input_list_value;
  let t1;
  let div0_class_value;
  let t2;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[12].default && create_if_block_23(ctx)
  );
  let input_levels = [
    { type: "range" },
    { id: (
      /*id*/
      ctx[5]
    ) },
    { name: (
      /*name*/
      ctx[6]
    ) },
    {
      class: input_class_value = "range-slider-input " + /*classesInput*/
      ctx[9]
    },
    {
      list: input_list_value = "tickmarks-" + /*id*/
      ctx[5]
    },
    { "aria-label": (
      /*label*/
      ctx[7]
    ) },
    { min: (
      /*min*/
      ctx[1]
    ) },
    { max: (
      /*max*/
      ctx[2]
    ) },
    { step: (
      /*step*/
      ctx[3]
    ) },
    /*prunedRestProps*/
    ctx[11]()
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block1 = (
    /*ticked*/
    ctx[4] && /*tickmarks*/
    ctx[8] && /*tickmarks*/
    ctx[8].length && create_if_block_16(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[12].trail && create_if_block13(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      input = element("input");
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        class: true,
        list: true,
        "aria-label": true,
        min: true,
        max: true,
        step: true
      });
      t1 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file19, 46, 2, 1106);
      attr_dev(div0, "class", div0_class_value = "range-content " + cBaseContent);
      add_location(div0, file19, 43, 1, 1040);
      attr_dev(div1, "class", div1_class_value = "range-slider " + /*classesBase*/
      ctx[10]);
      attr_dev(div1, "data-testid", "range-slider");
      add_location(div1, file19, 34, 0, 816);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      append_hydration_dev(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[19]
          ),
          listen_dev(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[19]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[16],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[17],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[18],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[12].default
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          4096) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_23(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "range" },
        (!current || dirty & /*id*/
        32) && { id: (
          /*id*/
          ctx2[5]
        ) },
        (!current || dirty & /*name*/
        64) && { name: (
          /*name*/
          ctx2[6]
        ) },
        (!current || dirty & /*classesInput*/
        512 && input_class_value !== (input_class_value = "range-slider-input " + /*classesInput*/
        ctx2[9])) && { class: input_class_value },
        (!current || dirty & /*id*/
        32 && input_list_value !== (input_list_value = "tickmarks-" + /*id*/
        ctx2[5])) && { list: input_list_value },
        (!current || dirty & /*label*/
        128) && { "aria-label": (
          /*label*/
          ctx2[7]
        ) },
        (!current || dirty & /*min*/
        2) && { min: (
          /*min*/
          ctx2[1]
        ) },
        (!current || dirty & /*max*/
        4) && { max: (
          /*max*/
          ctx2[2]
        ) },
        (!current || dirty & /*step*/
        8) && { step: (
          /*step*/
          ctx2[3]
        ) },
        /*prunedRestProps*/
        ctx2[11]()
      ]));
      if (dirty & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (
        /*ticked*/
        ctx2[4] && /*tickmarks*/
        ctx2[8] && /*tickmarks*/
        ctx2[8].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_16(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$$slots*/
        ctx2[12].trail
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          4096) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block13(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      1024 && div1_class_value !== (div1_class_value = "range-slider " + /*classesBase*/
      ctx2[10])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase14 = "space-y-2";
var cBaseLabel2 = "";
var cBaseContent = "flex justify-center py-2";
var cBaseInput = "w-full h-2";
function instance19($$self, $$props, $$invalidate) {
  let classesBase;
  let classesInput;
  const omit_props_names = ["value", "min", "max", "step", "ticked", "accent", "id", "name", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RangeSlider", slots, ["default", "trail"]);
  const $$slots = compute_slots(slots);
  let { value = 0 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 1 } = $$props;
  let { ticked = false } = $$props;
  let { accent = "accent-secondary-500" } = $$props;
  let { id = crypto.randomUUID() } = $$props;
  let { name = id } = $$props;
  let { label = "" } = $$props;
  let tickmarks;
  function setTicks() {
    if (ticked == false)
      return;
    $$invalidate(8, tickmarks = Array.from({ length: max - min + 1 }, (_, i) => i + 1));
  }
  afterUpdate(() => {
    setTicks();
  });
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(1, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(2, max = $$new_props.max);
    if ("step" in $$new_props)
      $$invalidate(3, step = $$new_props.step);
    if ("ticked" in $$new_props)
      $$invalidate(4, ticked = $$new_props.ticked);
    if ("accent" in $$new_props)
      $$invalidate(13, accent = $$new_props.accent);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(6, name = $$new_props.name);
    if ("label" in $$new_props)
      $$invalidate(7, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    value,
    min,
    max,
    step,
    ticked,
    accent,
    id,
    name,
    label,
    cBase: cBase14,
    cBaseLabel: cBaseLabel2,
    cBaseContent,
    cBaseInput,
    tickmarks,
    setTicks,
    prunedRestProps,
    classesInput,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$props)
      $$invalidate(1, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(2, max = $$new_props.max);
    if ("step" in $$props)
      $$invalidate(3, step = $$new_props.step);
    if ("ticked" in $$props)
      $$invalidate(4, ticked = $$new_props.ticked);
    if ("accent" in $$props)
      $$invalidate(13, accent = $$new_props.accent);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(6, name = $$new_props.name);
    if ("label" in $$props)
      $$invalidate(7, label = $$new_props.label);
    if ("tickmarks" in $$props)
      $$invalidate(8, tickmarks = $$new_props.tickmarks);
    if ("classesInput" in $$props)
      $$invalidate(9, classesInput = $$new_props.classesInput);
    if ("classesBase" in $$props)
      $$invalidate(10, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(10, classesBase = `${cBase14} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*accent*/
    8192) {
      $:
        $$invalidate(9, classesInput = `${cBaseInput} ${accent}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    min,
    max,
    step,
    ticked,
    id,
    name,
    label,
    tickmarks,
    classesInput,
    classesBase,
    prunedRestProps,
    $$slots,
    accent,
    $$scope,
    slots,
    click_handler,
    change_handler,
    blur_handler,
    input_change_input_handler
  ];
}
var RangeSlider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      value: 0,
      min: 1,
      max: 2,
      step: 3,
      ticked: 4,
      accent: 13,
      id: 5,
      name: 6,
      label: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RangeSlider",
      options,
      id: create_fragment19.name
    });
  }
  get value() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticked() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticked(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RangeSlider_default = RangeSlider;

// node_modules/@skeletonlabs/skeleton/components/SlideToggle/SlideToggle.svelte
var file20 = "node_modules/@skeletonlabs/skeleton/components/SlideToggle/SlideToggle.svelte";
function create_if_block14(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "slide-toggle-text ml-3");
      add_location(div, file20, 85, 23, 2421);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(86:2) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let div2;
  let label_1;
  let input;
  let input_disabled_value;
  let t0;
  let div1;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let t1;
  let label_1_class_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "checkbox" },
    { class: "slide-toggle-input hidden" },
    /*prunedRestProps*/
    ctx[7](),
    {
      disabled: input_disabled_value = /*$$props*/
      ctx[8].disabled
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block = (
    /*$$slots*/
    ctx[9].default && create_if_block14(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      label_1 = element("label");
      input = element("input");
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        id: true,
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-checked": true,
        tabindex: true
      });
      var div2_nodes = children(div2);
      label_1 = claim_element(div2_nodes, "LABEL", { class: true });
      var label_1_nodes = children(label_1);
      input = claim_element(label_1_nodes, "INPUT", { type: true, class: true });
      t0 = claim_space(label_1_nodes);
      div1 = claim_element(label_1_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(label_1_nodes);
      if (if_block)
        if_block.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file20, 65, 2, 1905);
      attr_dev(div0, "class", div0_class_value = "slide-toggle-thumb " + /*classesThumb*/
      ctx[2]);
      toggle_class(
        div0,
        "cursor-not-allowed",
        /*$$props*/
        ctx[8].disabled
      );
      add_location(div0, file20, 82, 3, 2278);
      attr_dev(div1, "class", div1_class_value = "slide-toggle-track " + /*classesTrack*/
      ctx[3]);
      toggle_class(
        div1,
        "cursor-not-allowed",
        /*$$props*/
        ctx[8].disabled
      );
      add_location(div1, file20, 81, 2, 2183);
      attr_dev(label_1, "class", label_1_class_value = "slide-toggle-label " + /*classesLabel*/
      ctx[4]);
      add_location(label_1, file20, 63, 1, 1829);
      attr_dev(
        div2,
        "id",
        /*label*/
        ctx[1]
      );
      attr_dev(div2, "class", div2_class_value = "slide-toggle " + /*classesBase*/
      ctx[5]);
      attr_dev(div2, "data-testid", "slide-toggle");
      attr_dev(div2, "role", "switch");
      attr_dev(
        div2,
        "aria-label",
        /*label*/
        ctx[1]
      );
      attr_dev(
        div2,
        "aria-checked",
        /*checked*/
        ctx[0]
      );
      attr_dev(div2, "tabindex", "0");
      add_location(div2, file20, 53, 0, 1648);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, label_1);
      append_hydration_dev(label_1, input);
      if (input.autofocus)
        input.focus();
      input.checked = /*checked*/
      ctx[0];
      append_hydration_dev(label_1, t0);
      append_hydration_dev(label_1, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(label_1, t1);
      if (if_block)
        if_block.m(label_1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[30]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[22],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[23],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[24],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler*/
            ctx[25],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mouseover",
            /*mouseover_handler*/
            ctx[26],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[27],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[28],
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[29],
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "keydown",
            /*onKeyDown*/
            ctx[6],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "checkbox" },
        { class: "slide-toggle-input hidden" },
        /*prunedRestProps*/
        ctx2[7](),
        (!current || dirty[0] & /*$$props*/
        256 && input_disabled_value !== (input_disabled_value = /*$$props*/
        ctx2[8].disabled)) && { disabled: input_disabled_value }
      ]));
      if (dirty[0] & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
      if (!current || dirty[0] & /*classesThumb*/
      4 && div0_class_value !== (div0_class_value = "slide-toggle-thumb " + /*classesThumb*/
      ctx2[2])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classesThumb, $$props*/
      260) {
        toggle_class(
          div0,
          "cursor-not-allowed",
          /*$$props*/
          ctx2[8].disabled
        );
      }
      if (!current || dirty[0] & /*classesTrack*/
      8 && div1_class_value !== (div1_class_value = "slide-toggle-track " + /*classesTrack*/
      ctx2[3])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*classesTrack, $$props*/
      264) {
        toggle_class(
          div1,
          "cursor-not-allowed",
          /*$$props*/
          ctx2[8].disabled
        );
      }
      if (
        /*$$slots*/
        ctx2[9].default
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesLabel*/
      16 && label_1_class_value !== (label_1_class_value = "slide-toggle-label " + /*classesLabel*/
      ctx2[4])) {
        attr_dev(label_1, "class", label_1_class_value);
      }
      if (!current || dirty[0] & /*label*/
      2) {
        attr_dev(
          div2,
          "id",
          /*label*/
          ctx2[1]
        );
      }
      if (!current || dirty[0] & /*classesBase*/
      32 && div2_class_value !== (div2_class_value = "slide-toggle " + /*classesBase*/
      ctx2[5])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*label*/
      2) {
        attr_dev(
          div2,
          "aria-label",
          /*label*/
          ctx2[1]
        );
      }
      if (!current || dirty[0] & /*checked*/
      1) {
        attr_dev(
          div2,
          "aria-checked",
          /*checked*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase15 = "inline-block";
var cLabel6 = "unstyled flex items-center";
var cTrack = "flex transition-all duration-[200ms] cursor-pointer";
var cThumb = "w-[50%] h-full scale-[0.7] transition-all duration-[200ms] shadow-lg";
function instance20($$self, $$props, $$invalidate) {
  let cTrackAccent;
  let cThumbBackground;
  let cThumbPos;
  let classesDisabled;
  let classesBase;
  let classesLabel;
  let classesTrack;
  let classesThumb;
  const omit_props_names = ["checked", "size", "accent", "borderWidth", "borderColor", "rounded", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SlideToggle", slots, ["default"]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { checked = false } = $$props;
  let { size = "md" } = $$props;
  let { accent = "bg-secondary-500" } = $$props;
  let { borderWidth = "border-0" } = $$props;
  let { borderColor = "border-surface-300-600-token" } = $$props;
  let { rounded = "rounded-full" } = $$props;
  let { label = "" } = $$props;
  let trackSize;
  switch (size) {
    case "sm":
      trackSize = "w-12 h-6";
      break;
    case "lg":
      trackSize = "w-20 h-10";
      break;
    default:
      trackSize = "w-16 h-8";
  }
  function onKeyDown(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      dispatch("keyup", event);
      event.target.firstChild.click();
    }
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(32, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("size" in $$new_props)
      $$invalidate(10, size = $$new_props.size);
    if ("accent" in $$new_props)
      $$invalidate(11, accent = $$new_props.accent);
    if ("borderWidth" in $$new_props)
      $$invalidate(12, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$new_props)
      $$invalidate(13, borderColor = $$new_props.borderColor);
    if ("rounded" in $$new_props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    checked,
    size,
    accent,
    borderWidth,
    borderColor,
    rounded,
    label,
    cBase: cBase15,
    cLabel: cLabel6,
    cTrack,
    cThumb,
    trackSize,
    onKeyDown,
    prunedRestProps,
    cThumbPos,
    cThumbBackground,
    classesThumb,
    cTrackAccent,
    classesTrack,
    classesLabel,
    classesDisabled,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("size" in $$props)
      $$invalidate(10, size = $$new_props.size);
    if ("accent" in $$props)
      $$invalidate(11, accent = $$new_props.accent);
    if ("borderWidth" in $$props)
      $$invalidate(12, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$props)
      $$invalidate(13, borderColor = $$new_props.borderColor);
    if ("rounded" in $$props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("trackSize" in $$props)
      $$invalidate(15, trackSize = $$new_props.trackSize);
    if ("cThumbPos" in $$props)
      $$invalidate(16, cThumbPos = $$new_props.cThumbPos);
    if ("cThumbBackground" in $$props)
      $$invalidate(17, cThumbBackground = $$new_props.cThumbBackground);
    if ("classesThumb" in $$props)
      $$invalidate(2, classesThumb = $$new_props.classesThumb);
    if ("cTrackAccent" in $$props)
      $$invalidate(18, cTrackAccent = $$new_props.cTrackAccent);
    if ("classesTrack" in $$props)
      $$invalidate(3, classesTrack = $$new_props.classesTrack);
    if ("classesLabel" in $$props)
      $$invalidate(4, classesLabel = $$new_props.classesLabel);
    if ("classesDisabled" in $$props)
      $$invalidate(19, classesDisabled = $$new_props.classesDisabled);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*checked, accent*/
    2049) {
      $:
        $$invalidate(18, cTrackAccent = checked ? accent : "bg-surface-200-700-token cursor-pointer");
    }
    if ($$self.$$.dirty[0] & /*checked*/
    1) {
      $:
        $$invalidate(17, cThumbBackground = checked ? "bg-white" : "bg-white/50");
    }
    if ($$self.$$.dirty[0] & /*checked*/
    1) {
      $:
        $$invalidate(16, cThumbPos = checked ? "translate-x-full" : "");
    }
    $:
      $$invalidate(19, classesDisabled = $$props.disabled === true ? "opacity-50" : "hover:brightness-[105%] dark:hover:brightness-110 cursor-pointer");
    if ($$self.$$.dirty[0] & /*classesDisabled*/
    524288) {
      $:
        $$invalidate(5, classesBase = `${cBase15} ${classesDisabled}`);
    }
    $:
      $$invalidate(4, classesLabel = `${cLabel6} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*borderWidth, borderColor, rounded, trackSize, cTrackAccent*/
    323584) {
      $:
        $$invalidate(3, classesTrack = `${cTrack} ${borderWidth} ${borderColor} ${rounded} ${trackSize} ${cTrackAccent}`);
    }
    if ($$self.$$.dirty[0] & /*rounded, cThumbBackground, cThumbPos*/
    212992) {
      $:
        $$invalidate(2, classesThumb = `${cThumb} ${rounded} ${cThumbBackground} ${cThumbPos}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    checked,
    label,
    classesThumb,
    classesTrack,
    classesLabel,
    classesBase,
    onKeyDown,
    prunedRestProps,
    $$props,
    $$slots,
    size,
    accent,
    borderWidth,
    borderColor,
    rounded,
    trackSize,
    cThumbPos,
    cThumbBackground,
    cTrackAccent,
    classesDisabled,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    mouseover_handler,
    change_handler,
    focus_handler,
    blur_handler,
    input_change_handler
  ];
}
var SlideToggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance20,
      create_fragment20,
      safe_not_equal,
      {
        checked: 0,
        size: 10,
        accent: 11,
        borderWidth: 12,
        borderColor: 13,
        rounded: 14,
        label: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SlideToggle",
      options,
      id: create_fragment20.name
    });
  }
  get checked() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SlideToggle_default = SlideToggle;

// node_modules/@skeletonlabs/skeleton/components/Stepper/Stepper.svelte
var file21 = "node_modules/@skeletonlabs/skeleton/components/Stepper/Stepper.svelte";
function create_fragment21(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "stepper " + /*classesStepper*/
      ctx[0]);
      attr_dev(div, "data-testid", "stepper");
      add_location(div, file21, 40, 0, 1528);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesStepper*/
      1 && div_class_value !== (div_class_value = "stepper " + /*classesStepper*/
      ctx2[0])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let classesStepper;
  let $highestStepReached;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Stepper", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { active = writable(0) } = $$props;
  let { length = 0 } = $$props;
  let { duration = 200 } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { clickNavigation = false } = $$props;
  let { color = "text-white" } = $$props;
  let { background = "bg-secondary-500" } = $$props;
  let { buttonClassesBack = "btn-icon variant-ghost-surface" } = $$props;
  let { buttonClassesNext = "btn variant-filled-surface" } = $$props;
  let { buttonClassesComplete = "btn variant-filled-primary" } = $$props;
  let { buttonTextBack = "&uarr;" } = $$props;
  let { buttonTextNext = "Next &darr;" } = $$props;
  let { buttonTextComplete = "Complete" } = $$props;
  let highestStepReached = writable(0);
  validate_store(highestStepReached, "highestStepReached");
  component_subscribe($$self, highestStepReached, (value) => $$invalidate(17, $highestStepReached = value));
  active.subscribe((v) => {
    if (v > $highestStepReached)
      highestStepReached.set(v);
  });
  setContext("dispatch", dispatch);
  setContext("active", active);
  setContext("length", length);
  setContext("rounded", rounded);
  setContext("clickNavigation", clickNavigation);
  setContext("highestStepReached", highestStepReached);
  setContext("color", color);
  setContext("background", background);
  setContext("buttonClassesBack", buttonClassesBack);
  setContext("buttonClassesNext", buttonClassesNext);
  setContext("buttonClassesComplete", buttonClassesComplete);
  setContext("buttonTextBack", buttonTextBack);
  setContext("buttonTextNext", buttonTextNext);
  setContext("buttonTextComplete", buttonTextComplete);
  setContext("duration", duration);
  $$self.$$set = ($$new_props) => {
    $$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("active" in $$new_props)
      $$invalidate(2, active = $$new_props.active);
    if ("length" in $$new_props)
      $$invalidate(3, length = $$new_props.length);
    if ("duration" in $$new_props)
      $$invalidate(4, duration = $$new_props.duration);
    if ("rounded" in $$new_props)
      $$invalidate(5, rounded = $$new_props.rounded);
    if ("clickNavigation" in $$new_props)
      $$invalidate(6, clickNavigation = $$new_props.clickNavigation);
    if ("color" in $$new_props)
      $$invalidate(7, color = $$new_props.color);
    if ("background" in $$new_props)
      $$invalidate(8, background = $$new_props.background);
    if ("buttonClassesBack" in $$new_props)
      $$invalidate(9, buttonClassesBack = $$new_props.buttonClassesBack);
    if ("buttonClassesNext" in $$new_props)
      $$invalidate(10, buttonClassesNext = $$new_props.buttonClassesNext);
    if ("buttonClassesComplete" in $$new_props)
      $$invalidate(11, buttonClassesComplete = $$new_props.buttonClassesComplete);
    if ("buttonTextBack" in $$new_props)
      $$invalidate(12, buttonTextBack = $$new_props.buttonTextBack);
    if ("buttonTextNext" in $$new_props)
      $$invalidate(13, buttonTextNext = $$new_props.buttonTextNext);
    if ("buttonTextComplete" in $$new_props)
      $$invalidate(14, buttonTextComplete = $$new_props.buttonTextComplete);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    writable,
    dispatch,
    active,
    length,
    duration,
    rounded,
    clickNavigation,
    color,
    background,
    buttonClassesBack,
    buttonClassesNext,
    buttonClassesComplete,
    buttonTextBack,
    buttonTextNext,
    buttonTextComplete,
    highestStepReached,
    classesStepper,
    $highestStepReached
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(19, $$props = assign(assign({}, $$props), $$new_props));
    if ("active" in $$props)
      $$invalidate(2, active = $$new_props.active);
    if ("length" in $$props)
      $$invalidate(3, length = $$new_props.length);
    if ("duration" in $$props)
      $$invalidate(4, duration = $$new_props.duration);
    if ("rounded" in $$props)
      $$invalidate(5, rounded = $$new_props.rounded);
    if ("clickNavigation" in $$props)
      $$invalidate(6, clickNavigation = $$new_props.clickNavigation);
    if ("color" in $$props)
      $$invalidate(7, color = $$new_props.color);
    if ("background" in $$props)
      $$invalidate(8, background = $$new_props.background);
    if ("buttonClassesBack" in $$props)
      $$invalidate(9, buttonClassesBack = $$new_props.buttonClassesBack);
    if ("buttonClassesNext" in $$props)
      $$invalidate(10, buttonClassesNext = $$new_props.buttonClassesNext);
    if ("buttonClassesComplete" in $$props)
      $$invalidate(11, buttonClassesComplete = $$new_props.buttonClassesComplete);
    if ("buttonTextBack" in $$props)
      $$invalidate(12, buttonTextBack = $$new_props.buttonTextBack);
    if ("buttonTextNext" in $$props)
      $$invalidate(13, buttonTextNext = $$new_props.buttonTextNext);
    if ("buttonTextComplete" in $$props)
      $$invalidate(14, buttonTextComplete = $$new_props.buttonTextComplete);
    if ("highestStepReached" in $$props)
      $$invalidate(1, highestStepReached = $$new_props.highestStepReached);
    if ("classesStepper" in $$props)
      $$invalidate(0, classesStepper = $$new_props.classesStepper);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classesStepper = `${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    classesStepper,
    highestStepReached,
    active,
    length,
    duration,
    rounded,
    clickNavigation,
    color,
    background,
    buttonClassesBack,
    buttonClassesNext,
    buttonClassesComplete,
    buttonTextBack,
    buttonTextNext,
    buttonTextComplete,
    $$scope,
    slots
  ];
}
var Stepper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      active: 2,
      length: 3,
      duration: 4,
      rounded: 5,
      clickNavigation: 6,
      color: 7,
      background: 8,
      buttonClassesBack: 9,
      buttonClassesNext: 10,
      buttonClassesComplete: 11,
      buttonTextBack: 12,
      buttonTextNext: 13,
      buttonTextComplete: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Stepper",
      options,
      id: create_fragment21.name
    });
  }
  get active() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get length() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set length(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clickNavigation() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clickNavigation(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClassesBack() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClassesBack(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClassesNext() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClassesNext(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClassesComplete() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClassesComplete(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextBack() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextBack(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextNext() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextNext(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextComplete() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextComplete(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Stepper_default = Stepper;

// node_modules/@skeletonlabs/skeleton/components/Stepper/Step.svelte
var file22 = "node_modules/@skeletonlabs/skeleton/components/Stepper/Step.svelte";
var get_header_slot_changes2 = (dirty) => ({});
var get_header_slot_context2 = (ctx) => ({});
function create_else_block_1(ctx) {
  let html_tag;
  let raw_value = (
    /*index*/
    (ctx[0] < /*$active*/
    ctx[14] ? "&check;" : (
      /*index*/
      ctx[0] + 1
    )) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*index, $active*/
      16385 && raw_value !== (raw_value = /*index*/
      (ctx2[0] < /*$active*/
      ctx2[14] ? "&check;" : (
        /*index*/
        ctx2[0] + 1
      )) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(88:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M144 144v48H304V144c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192V144C80 64.5 144.5 0 224 0s144 64.5 144 144v48h16c35.3 0 64 28.7 64 64V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V256c0-35.3 28.7-64 64-64H80z");
      add_location(path, file22, 83, 5, 2987);
      attr_dev(svg, "class", "fill-token w-3 aspect-square");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 448 512");
      add_location(svg, file22, 82, 4, 2882);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(82:3) {#if locked}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "step-line " + /*classesLine*/
      ctx[18]);
      add_location(div, file22, 92, 19, 3354);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*classesLine*/
      262144 && div_class_value !== (div_class_value = "step-line " + /*classesLine*/
      ctx2[18])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(93:2) {#if !isLastItem}",
    ctx
  });
  return block;
}
function fallback_block4(ctx) {
  let h4;
  let t0;
  let t1_value = (
    /*index*/
    ctx[0] + 1 + ""
  );
  let t1;
  const block = {
    c: function create() {
      h4 = element("h4");
      t0 = text("Step ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      h4 = claim_element(nodes, "H4", {});
      var h4_nodes = children(h4);
      t0 = claim_text(h4_nodes, "Step ");
      t1 = claim_text(h4_nodes, t1_value);
      h4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h4, file22, 98, 23, 3617);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h4, anchor);
      append_hydration_dev(h4, t0);
      append_hydration_dev(h4, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*index*/
      1 && t1_value !== (t1_value = /*index*/
      ctx2[0] + 1 + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h4);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(99:23) <h4>",
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let div;
  let t0;
  let footer;
  let t1;
  let footer_class_value;
  let div_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[37].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    null
  );
  let if_block0 = (
    /*index*/
    ctx[0] !== 0 && create_if_block_24(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$active*/
      ctx2[14] + 1 < /*length*/
      ctx2[3]
    )
      return create_if_block_17;
    return create_else_block3;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block1 = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t0 = space();
      footer = element("footer");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      footer = claim_element(div_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      if (if_block0)
        if_block0.l(footer_nodes);
      t1 = claim_space(footer_nodes);
      if_block1.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(footer, "class", footer_class_value = "step-navigation " + /*classesNav*/
      ctx[15]);
      add_location(footer, file22, 105, 4, 3824);
      attr_dev(div, "class", "step-body space-y-4");
      add_location(div, file22, 101, 3, 3691);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t0);
      append_hydration_dev(div, footer);
      if (if_block0)
        if_block0.m(footer, null);
      append_hydration_dev(footer, t1);
      if_block1.m(footer, null);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[36]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[36],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*index*/
        ctx[0] !== 0
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_24(ctx);
          if_block0.c();
          if_block0.m(footer, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block1) {
        if_block1.p(ctx, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx);
        if (if_block1) {
          if_block1.c();
          if_block1.m(footer, null);
        }
      }
      if (!current || dirty[0] & /*classesNav*/
      32768 && footer_class_value !== (footer_class_value = "step-navigation " + /*classesNav*/
      ctx[15])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, { duration: (
              /*duration*/
              ctx[4]
            ) }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: (
            /*duration*/
            ctx[4]
          ) }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if_block1.d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(101:2) {#if index === $active}",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        button,
        "class",
        /*buttonClassesBack*/
        ctx[6]
      );
      add_location(button, file22, 107, 6, 3899);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = /*buttonTextBack*/
      ctx[9];
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*stepPrev*/
          ctx[21],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextBack*/
      512)
        button.innerHTML = /*buttonTextBack*/
        ctx2[9];
      ;
      if (dirty[0] & /*buttonClassesBack*/
      64) {
        attr_dev(
          button,
          "class",
          /*buttonClassesBack*/
          ctx2[6]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(107:5) {#if index !== 0}",
    ctx
  });
  return block;
}
function create_else_block3(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        button,
        "class",
        /*buttonClassesComplete*/
        ctx[8]
      );
      button.disabled = /*locked*/
      ctx[1];
      add_location(button, file22, 116, 6, 4187);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = /*buttonTextComplete*/
      ctx[11];
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*onComplete*/
          ctx[23],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextComplete*/
      2048)
        button.innerHTML = /*buttonTextComplete*/
        ctx2[11];
      ;
      if (dirty[0] & /*buttonClassesComplete*/
      256) {
        attr_dev(
          button,
          "class",
          /*buttonClassesComplete*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*locked*/
      2) {
        prop_dev(
          button,
          "disabled",
          /*locked*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(116:5) {:else}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        button,
        "class",
        /*buttonClassesNext*/
        ctx[7]
      );
      button.disabled = /*locked*/
      ctx[1];
      add_location(button, file22, 112, 6, 4049);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = /*buttonTextNext*/
      ctx[10];
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*stepNext*/
          ctx[22],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextNext*/
      1024)
        button.innerHTML = /*buttonTextNext*/
        ctx2[10];
      ;
      if (dirty[0] & /*buttonClassesNext*/
      128) {
        attr_dev(
          button,
          "class",
          /*buttonClassesNext*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*locked*/
      2) {
        prop_dev(
          button,
          "disabled",
          /*locked*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(112:5) {#if $active + 1 < length}",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let div2;
  let div0;
  let button;
  let button_class_value;
  let t0;
  let t1;
  let div1;
  let header;
  let t2;
  let div1_class_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*locked*/
      ctx2[1]
    )
      return create_if_block_42;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = !/*isLastItem*/
  ctx[12] && create_if_block_32(ctx);
  const header_slot_template = (
    /*#slots*/
    ctx[37].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    get_header_slot_context2
  );
  const header_slot_or_fallback = header_slot || fallback_block4(ctx);
  let if_block2 = (
    /*index*/
    ctx[0] === /*$active*/
    ctx[14] && create_if_block15(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      button = element("button");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      header = element("header");
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button = claim_element(div0_nodes, "BUTTON", { class: true, tabindex: true });
      var button_nodes = children(button);
      if_block0.l(button_nodes);
      button_nodes.forEach(detach_dev);
      t0 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      header = claim_element(div1_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      if (header_slot_or_fallback)
        header_slot_or_fallback.l(header_nodes);
      header_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "step-numeral flex-none " + /*classesNumeral*/
      ctx[17]);
      attr_dev(
        button,
        "tabindex",
        /*btnTabindex*/
        ctx[20]
      );
      toggle_class(
        button,
        "cursor-pointer",
        /*isClickable*/
        ctx[13]
      );
      add_location(button, file22, 74, 2, 2694);
      attr_dev(div0, "class", "step-timeline flex flex-col items-center");
      add_location(div0, file22, 72, 1, 2618);
      attr_dev(header, "class", "step-header");
      toggle_class(
        header,
        "cursor-pointer",
        /*isClickable*/
        ctx[13]
      );
      add_location(header, file22, 97, 2, 3495);
      attr_dev(div1, "class", div1_class_value = "step-content " + /*classesDrawer*/
      ctx[16]);
      add_location(div1, file22, 95, 1, 3426);
      attr_dev(div2, "class", div2_class_value = "step " + /*classesBase*/
      ctx[19]);
      attr_dev(div2, "data-testid", "step");
      add_location(div2, file22, 70, 0, 2546);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, button);
      if_block0.m(button, null);
      append_hydration_dev(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, header);
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(header, null);
      }
      append_hydration_dev(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*stepToIndex*/
            ctx[24],
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keypress",
            /*keypress_handler*/
            ctx[39],
            false,
            false,
            false
          ),
          listen_dev(
            header,
            "click",
            /*stepToIndex*/
            ctx[24],
            false,
            false,
            false
          ),
          listen_dev(
            header,
            "keypress",
            /*keypress_handler_1*/
            ctx[38],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(button, null);
        }
      }
      if (!current || dirty[0] & /*classesNumeral*/
      131072 && button_class_value !== (button_class_value = "step-numeral flex-none " + /*classesNumeral*/
      ctx2[17])) {
        attr_dev(button, "class", button_class_value);
      }
      if (!current || dirty[0] & /*btnTabindex*/
      1048576) {
        attr_dev(
          button,
          "tabindex",
          /*btnTabindex*/
          ctx2[20]
        );
      }
      if (!current || dirty[0] & /*classesNumeral, isClickable*/
      139264) {
        toggle_class(
          button,
          "cursor-pointer",
          /*isClickable*/
          ctx2[13]
        );
      }
      if (!/*isLastItem*/
      ctx2[12]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_32(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              get_header_slot_changes2
            ),
            get_header_slot_context2
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty[0] & /*index*/
        1)) {
          header_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*isClickable*/
      8192) {
        toggle_class(
          header,
          "cursor-pointer",
          /*isClickable*/
          ctx2[13]
        );
      }
      if (
        /*index*/
        ctx2[0] === /*$active*/
        ctx2[14]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*index, $active*/
          16385) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block15(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesDrawer*/
      65536 && div1_class_value !== (div1_class_value = "step-content " + /*classesDrawer*/
      ctx2[16])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      524288 && div2_class_value !== (div2_class_value = "step " + /*classesBase*/
      ctx2[19])) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot_or_fallback, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase16 = "grid grid-cols-[32px_1fr] gap-4";
var cLine = "w-1 h-full";
var cLineBackground = "bg-surface-300-600-token";
var cNumeral = "font-bold text-base w-8 h-8 rounded-full flex justify-center items-center";
var cNumeralBackground = "bg-surface-300-600-token";
var cDrawer = "ml-1 space-y-4";
var cNav = "flex items-center space-x-2";
function instance22($$self, $$props, $$invalidate) {
  let isLastItem;
  let isClickable;
  let classCursor;
  let btnTabindex;
  let classesBase;
  let classesLineBackgroundColor;
  let classesLineBackground;
  let classesLine;
  let classesNumeralBackground;
  let classesNumeral;
  let classesDrawerPadding;
  let classesDrawer;
  let classesNav;
  let $active, $$unsubscribe_active = noop, $$subscribe_active = () => ($$unsubscribe_active(), $$unsubscribe_active = subscribe(active, ($$value) => $$invalidate(14, $active = $$value)), active);
  let $highestStepReached, $$unsubscribe_highestStepReached = noop, $$subscribe_highestStepReached = () => ($$unsubscribe_highestStepReached(), $$unsubscribe_highestStepReached = subscribe(highestStepReached, ($$value) => $$invalidate(35, $highestStepReached = $$value)), highestStepReached);
  $$self.$$.on_destroy.push(() => $$unsubscribe_active());
  $$self.$$.on_destroy.push(() => $$unsubscribe_highestStepReached());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Step", slots, ["header", "default"]);
  let { index = 0 } = $$props;
  let { locked = false } = $$props;
  let { dispatch = getContext("dispatch") } = $$props;
  let { active = getContext("active") } = $$props;
  validate_store(active, "active");
  $$subscribe_active();
  let { length = getContext("length") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { duration = getContext("duration") } = $$props;
  let { clickNavigation = getContext("clickNavigation") } = $$props;
  let { highestStepReached = getContext("highestStepReached") } = $$props;
  validate_store(highestStepReached, "highestStepReached");
  $$subscribe_highestStepReached();
  let { color = getContext("color") } = $$props;
  let { background = getContext("background") } = $$props;
  let { buttonClassesBack = getContext("buttonClassesBack") } = $$props;
  let { buttonClassesNext = getContext("buttonClassesNext") } = $$props;
  let { buttonClassesComplete = getContext("buttonClassesComplete") } = $$props;
  let { buttonTextBack = getContext("buttonTextBack") } = $$props;
  let { buttonTextNext = getContext("buttonTextNext") } = $$props;
  let { buttonTextComplete = getContext("buttonTextComplete") } = $$props;
  function stepPrev() {
    active.set($active - 1);
    dispatch("previous", {});
  }
  function stepNext() {
    active.set($active + 1);
    dispatch("next", {});
  }
  function onComplete() {
    dispatch("complete", {});
  }
  function stepToIndex() {
    if (isClickable)
      active.set(index);
  }
  function keypress_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("index" in $$new_props)
      $$invalidate(0, index = $$new_props.index);
    if ("locked" in $$new_props)
      $$invalidate(1, locked = $$new_props.locked);
    if ("dispatch" in $$new_props)
      $$invalidate(25, dispatch = $$new_props.dispatch);
    if ("active" in $$new_props)
      $$subscribe_active($$invalidate(2, active = $$new_props.active));
    if ("length" in $$new_props)
      $$invalidate(3, length = $$new_props.length);
    if ("rounded" in $$new_props)
      $$invalidate(26, rounded = $$new_props.rounded);
    if ("duration" in $$new_props)
      $$invalidate(4, duration = $$new_props.duration);
    if ("clickNavigation" in $$new_props)
      $$invalidate(27, clickNavigation = $$new_props.clickNavigation);
    if ("highestStepReached" in $$new_props)
      $$subscribe_highestStepReached($$invalidate(5, highestStepReached = $$new_props.highestStepReached));
    if ("color" in $$new_props)
      $$invalidate(28, color = $$new_props.color);
    if ("background" in $$new_props)
      $$invalidate(29, background = $$new_props.background);
    if ("buttonClassesBack" in $$new_props)
      $$invalidate(6, buttonClassesBack = $$new_props.buttonClassesBack);
    if ("buttonClassesNext" in $$new_props)
      $$invalidate(7, buttonClassesNext = $$new_props.buttonClassesNext);
    if ("buttonClassesComplete" in $$new_props)
      $$invalidate(8, buttonClassesComplete = $$new_props.buttonClassesComplete);
    if ("buttonTextBack" in $$new_props)
      $$invalidate(9, buttonTextBack = $$new_props.buttonTextBack);
    if ("buttonTextNext" in $$new_props)
      $$invalidate(10, buttonTextNext = $$new_props.buttonTextNext);
    if ("buttonTextComplete" in $$new_props)
      $$invalidate(11, buttonTextComplete = $$new_props.buttonTextComplete);
    if ("$$scope" in $$new_props)
      $$invalidate(36, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    slide,
    index,
    locked,
    cBase: cBase16,
    cLine,
    cLineBackground,
    cNumeral,
    cNumeralBackground,
    cDrawer,
    cNav,
    dispatch,
    active,
    length,
    rounded,
    duration,
    clickNavigation,
    highestStepReached,
    color,
    background,
    buttonClassesBack,
    buttonClassesNext,
    buttonClassesComplete,
    buttonTextBack,
    buttonTextNext,
    buttonTextComplete,
    stepPrev,
    stepNext,
    onComplete,
    stepToIndex,
    classesNav,
    classesDrawerPadding,
    classesDrawer,
    isLastItem,
    classCursor,
    classesNumeralBackground,
    classesNumeral,
    classesLineBackground,
    classesLine,
    classesLineBackgroundColor,
    classesBase,
    isClickable,
    btnTabindex,
    $active,
    $highestStepReached
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(40, $$props = assign(assign({}, $$props), $$new_props));
    if ("index" in $$props)
      $$invalidate(0, index = $$new_props.index);
    if ("locked" in $$props)
      $$invalidate(1, locked = $$new_props.locked);
    if ("dispatch" in $$props)
      $$invalidate(25, dispatch = $$new_props.dispatch);
    if ("active" in $$props)
      $$subscribe_active($$invalidate(2, active = $$new_props.active));
    if ("length" in $$props)
      $$invalidate(3, length = $$new_props.length);
    if ("rounded" in $$props)
      $$invalidate(26, rounded = $$new_props.rounded);
    if ("duration" in $$props)
      $$invalidate(4, duration = $$new_props.duration);
    if ("clickNavigation" in $$props)
      $$invalidate(27, clickNavigation = $$new_props.clickNavigation);
    if ("highestStepReached" in $$props)
      $$subscribe_highestStepReached($$invalidate(5, highestStepReached = $$new_props.highestStepReached));
    if ("color" in $$props)
      $$invalidate(28, color = $$new_props.color);
    if ("background" in $$props)
      $$invalidate(29, background = $$new_props.background);
    if ("buttonClassesBack" in $$props)
      $$invalidate(6, buttonClassesBack = $$new_props.buttonClassesBack);
    if ("buttonClassesNext" in $$props)
      $$invalidate(7, buttonClassesNext = $$new_props.buttonClassesNext);
    if ("buttonClassesComplete" in $$props)
      $$invalidate(8, buttonClassesComplete = $$new_props.buttonClassesComplete);
    if ("buttonTextBack" in $$props)
      $$invalidate(9, buttonTextBack = $$new_props.buttonTextBack);
    if ("buttonTextNext" in $$props)
      $$invalidate(10, buttonTextNext = $$new_props.buttonTextNext);
    if ("buttonTextComplete" in $$props)
      $$invalidate(11, buttonTextComplete = $$new_props.buttonTextComplete);
    if ("classesNav" in $$props)
      $$invalidate(15, classesNav = $$new_props.classesNav);
    if ("classesDrawerPadding" in $$props)
      $$invalidate(30, classesDrawerPadding = $$new_props.classesDrawerPadding);
    if ("classesDrawer" in $$props)
      $$invalidate(16, classesDrawer = $$new_props.classesDrawer);
    if ("isLastItem" in $$props)
      $$invalidate(12, isLastItem = $$new_props.isLastItem);
    if ("classCursor" in $$props)
      $$invalidate(31, classCursor = $$new_props.classCursor);
    if ("classesNumeralBackground" in $$props)
      $$invalidate(32, classesNumeralBackground = $$new_props.classesNumeralBackground);
    if ("classesNumeral" in $$props)
      $$invalidate(17, classesNumeral = $$new_props.classesNumeral);
    if ("classesLineBackground" in $$props)
      $$invalidate(33, classesLineBackground = $$new_props.classesLineBackground);
    if ("classesLine" in $$props)
      $$invalidate(18, classesLine = $$new_props.classesLine);
    if ("classesLineBackgroundColor" in $$props)
      $$invalidate(34, classesLineBackgroundColor = $$new_props.classesLineBackgroundColor);
    if ("classesBase" in $$props)
      $$invalidate(19, classesBase = $$new_props.classesBase);
    if ("isClickable" in $$props)
      $$invalidate(13, isClickable = $$new_props.isClickable);
    if ("btnTabindex" in $$props)
      $$invalidate(20, btnTabindex = $$new_props.btnTabindex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*index, length*/
    9) {
      $:
        $$invalidate(12, isLastItem = index === length - 1);
    }
    if ($$self.$$.dirty[0] & /*clickNavigation, index*/
    134217729 | $$self.$$.dirty[1] & /*$highestStepReached*/
    16) {
      $:
        $$invalidate(13, isClickable = clickNavigation && index <= $highestStepReached);
    }
    if ($$self.$$.dirty[0] & /*isClickable*/
    8192) {
      $:
        $$invalidate(31, classCursor = isClickable ? "cursor-pointer" : "cursor-default");
    }
    if ($$self.$$.dirty[0] & /*isClickable*/
    8192) {
      $:
        $$invalidate(20, btnTabindex = isClickable ? 0 : -1);
    }
    $:
      $$invalidate(19, classesBase = `${cBase16} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*index, $active, background*/
    536887297) {
      $:
        $$invalidate(34, classesLineBackgroundColor = index < $active ? `${background}` : `${cLineBackground}`);
    }
    if ($$self.$$.dirty[0] & /*isLastItem*/
    4096 | $$self.$$.dirty[1] & /*classesLineBackgroundColor*/
    8) {
      $:
        $$invalidate(33, classesLineBackground = !isLastItem ? `${classesLineBackgroundColor}` : "");
    }
    if ($$self.$$.dirty[1] & /*classesLineBackground*/
    4) {
      $:
        $$invalidate(18, classesLine = `${cLine} ${classesLineBackground}`);
    }
    if ($$self.$$.dirty[0] & /*index, $active, color, background*/
    805322753) {
      $:
        $$invalidate(32, classesNumeralBackground = index <= $active ? `${color} ${background}` : `${cNumeralBackground}`);
    }
    if ($$self.$$.dirty[0] & /*rounded*/
    67108864 | $$self.$$.dirty[1] & /*classesNumeralBackground, classCursor*/
    3) {
      $:
        $$invalidate(17, classesNumeral = `${cNumeral} ${classesNumeralBackground} ${rounded} ${classCursor}`);
    }
    if ($$self.$$.dirty[0] & /*isLastItem*/
    4096) {
      $:
        $$invalidate(30, classesDrawerPadding = !isLastItem ? "pb-10" : "0");
    }
    if ($$self.$$.dirty[0] & /*classesDrawerPadding*/
    1073741824) {
      $:
        $$invalidate(16, classesDrawer = `${cDrawer} ${classesDrawerPadding}`);
    }
  };
  $:
    $$invalidate(15, classesNav = `${cNav}`);
  $$props = exclude_internal_props($$props);
  return [
    index,
    locked,
    active,
    length,
    duration,
    highestStepReached,
    buttonClassesBack,
    buttonClassesNext,
    buttonClassesComplete,
    buttonTextBack,
    buttonTextNext,
    buttonTextComplete,
    isLastItem,
    isClickable,
    $active,
    classesNav,
    classesDrawer,
    classesNumeral,
    classesLine,
    classesBase,
    btnTabindex,
    stepPrev,
    stepNext,
    onComplete,
    stepToIndex,
    dispatch,
    rounded,
    clickNavigation,
    color,
    background,
    classesDrawerPadding,
    classCursor,
    classesNumeralBackground,
    classesLineBackground,
    classesLineBackgroundColor,
    $highestStepReached,
    $$scope,
    slots,
    keypress_handler_1,
    keypress_handler
  ];
}
var Step = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance22,
      create_fragment22,
      safe_not_equal,
      {
        index: 0,
        locked: 1,
        dispatch: 25,
        active: 2,
        length: 3,
        rounded: 26,
        duration: 4,
        clickNavigation: 27,
        highestStepReached: 5,
        color: 28,
        background: 29,
        buttonClassesBack: 6,
        buttonClassesNext: 7,
        buttonClassesComplete: 8,
        buttonTextBack: 9,
        buttonTextNext: 10,
        buttonTextComplete: 11
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Step",
      options,
      id: create_fragment22.name
    });
  }
  get index() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set index(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get locked() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locked(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispatch() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispatch(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get length() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set length(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clickNavigation() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clickNavigation(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highestStepReached() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highestStepReached(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClassesBack() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClassesBack(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClassesNext() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClassesNext(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClassesComplete() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClassesComplete(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextBack() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextBack(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextNext() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextNext(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextComplete() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextComplete(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Step_default = Step;

// node_modules/@skeletonlabs/skeleton/components/Table/Table.svelte
var file23 = "node_modules/@skeletonlabs/skeleton/components/Table/Table.svelte";
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  child_ctx[21] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[23] = i;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i];
  return child_ctx;
}
function create_each_block_3(ctx) {
  let th;
  let raw_value = (
    /*heading*/
    ctx[24] + ""
  );
  const block = {
    c: function create() {
      th = element("th");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {});
      var th_nodes = children(th);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(th, file23, 43, 5, 1208);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      th.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*source*/
      1 && raw_value !== (raw_value = /*heading*/
      ctx2[24] + ""))
        th.innerHTML = raw_value;
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(43:4) {#each source.head as heading }",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let td;
  let raw_value = (
    /*cell*/
    (ctx[16] ? (
      /*cell*/
      ctx[16]
    ) : "-") + ""
  );
  let td_aria_colindex_value;
  let td_tabindex_value;
  const block = {
    c: function create() {
      td = element("td");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", {
        role: true,
        "aria-colindex": true,
        tabindex: true
      });
      var td_nodes = children(td);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "role", "gridcell");
      attr_dev(td, "aria-colindex", td_aria_colindex_value = /*cellIndex*/
      ctx[23] + 1);
      attr_dev(td, "tabindex", td_tabindex_value = /*cellIndex*/
      ctx[23] === 0 ? 0 : -1);
      add_location(td, file23, 60, 6, 1658);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      td.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*source*/
      1 && raw_value !== (raw_value = /*cell*/
      (ctx2[16] ? (
        /*cell*/
        ctx2[16]
      ) : "-") + ""))
        td.innerHTML = raw_value;
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(58:5) {#each row as cell, cellIndex}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let tr;
  let t;
  let tr_aria_rowindex_value;
  let mounted;
  let dispose;
  let each_value_2 = (
    /*row*/
    ctx[19]
  );
  validate_each_argument(each_value_2);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[12](
        /*rowIndex*/
        ctx[21],
        ...args
      )
    );
  }
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[13](
        /*rowIndex*/
        ctx[21],
        ...args
      )
    );
  }
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { "aria-rowindex": true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "aria-rowindex", tr_aria_rowindex_value = /*rowIndex*/
      ctx[21] + 1);
      add_location(tr, file23, 52, 4, 1413);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tr, null);
      }
      append_hydration_dev(tr, t);
      if (!mounted) {
        dispose = [
          listen_dev(tr, "click", click_handler, false, false, false),
          listen_dev(tr, "keydown", keydown_handler, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*source*/
      1) {
        each_value_2 = /*row*/
        ctx[19];
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(50:3) {#each source.body as row, rowIndex}",
    ctx
  });
  return block;
}
function create_if_block16(ctx) {
  let tfoot;
  let tr;
  let tfoot_class_value;
  let each_value = (
    /*source*/
    ctx[0].foot
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      tfoot = element("tfoot");
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      tfoot = claim_element(nodes, "TFOOT", { class: true });
      var tfoot_nodes = children(tfoot);
      tr = claim_element(tfoot_nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      tfoot_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file23, 74, 4, 1946);
      attr_dev(tfoot, "class", tfoot_class_value = "table-foot " + /*regionFoot*/
      ctx[4]);
      add_location(tfoot, file23, 73, 3, 1902);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tfoot, anchor);
      append_hydration_dev(tfoot, tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tr, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*source*/
      1) {
        each_value = /*source*/
        ctx2[0].foot;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*regionFoot*/
      16 && tfoot_class_value !== (tfoot_class_value = "table-foot " + /*regionFoot*/
      ctx2[4])) {
        attr_dev(tfoot, "class", tfoot_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tfoot);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(73:2) {#if source.foot}",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let td;
  let raw_value = (
    /*cell*/
    ctx[16] + ""
  );
  const block = {
    c: function create() {
      td = element("td");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", {});
      var td_nodes = children(td);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(td, file23, 76, 6, 1991);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      td.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*source*/
      1 && raw_value !== (raw_value = /*cell*/
      ctx2[16] + ""))
        td.innerHTML = raw_value;
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(76:5) {#each source.foot as cell }",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let div;
  let table;
  let thead;
  let tr;
  let thead_class_value;
  let t0;
  let tbody;
  let tbody_class_value;
  let t1;
  let tableA11y_action;
  let div_class_value;
  let mounted;
  let dispose;
  let each_value_3 = (
    /*source*/
    ctx[0].head
  );
  validate_each_argument(each_value_3);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_1 = (
    /*source*/
    ctx[0].body
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let if_block = (
    /*source*/
    ctx[0].foot && create_if_block16(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      table = claim_element(div_nodes, "TABLE", { class: true, role: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", { class: true });
      var thead_nodes = children(thead);
      tr = claim_element(thead_nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t0 = claim_space(table_nodes);
      tbody = claim_element(table_nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      t1 = claim_space(table_nodes);
      if (if_block)
        if_block.l(table_nodes);
      table_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file23, 41, 3, 1162);
      attr_dev(thead, "class", thead_class_value = "table-head " + /*regionHead*/
      ctx[2]);
      add_location(thead, file23, 40, 2, 1119);
      attr_dev(tbody, "class", tbody_class_value = "table-body " + /*regionBody*/
      ctx[3]);
      add_location(tbody, file23, 48, 2, 1283);
      attr_dev(
        table,
        "class",
        /*classesTable*/
        ctx[5]
      );
      attr_dev(table, "role", "grid");
      toggle_class(
        table,
        "table-interactive",
        /*interactive*/
        ctx[1]
      );
      add_location(table, file23, 32, 1, 936);
      attr_dev(div, "class", div_class_value = "table-container " + /*classesBase*/
      ctx[6]);
      add_location(div, file23, 29, 0, 849);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, table);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(tr, null);
      }
      append_hydration_dev(table, t0);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tbody, null);
      }
      append_hydration_dev(table, t1);
      if (if_block)
        if_block.m(table, null);
      if (!mounted) {
        dispose = action_destroyer(tableA11y_action = tableA11y.call(null, table));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*source*/
      1) {
        each_value_3 = /*source*/
        ctx2[0].head;
        validate_each_argument(each_value_3);
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_3(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(tr, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_3.length;
      }
      if (dirty & /*regionHead*/
      4 && thead_class_value !== (thead_class_value = "table-head " + /*regionHead*/
      ctx2[2])) {
        attr_dev(thead, "class", thead_class_value);
      }
      if (dirty & /*onRowClick, onRowKeydown, source*/
      385) {
        each_value_1 = /*source*/
        ctx2[0].body;
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*regionBody*/
      8 && tbody_class_value !== (tbody_class_value = "table-body " + /*regionBody*/
      ctx2[3])) {
        attr_dev(tbody, "class", tbody_class_value);
      }
      if (
        /*source*/
        ctx2[0].foot
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block16(ctx2);
          if_block.c();
          if_block.m(table, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*classesTable*/
      32) {
        attr_dev(
          table,
          "class",
          /*classesTable*/
          ctx2[5]
        );
      }
      if (dirty & /*classesTable, interactive*/
      34) {
        toggle_class(
          table,
          "table-interactive",
          /*interactive*/
          ctx2[1]
        );
      }
      if (dirty & /*classesBase*/
      64 && div_class_value !== (div_class_value = "table-container " + /*classesBase*/
      ctx2[6])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let classesBase;
  let classesTable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, []);
  const dispatch = createEventDispatcher();
  let { source } = $$props;
  let { interactive = false } = $$props;
  let { element: element2 = "table" } = $$props;
  let { text: text2 = "" } = $$props;
  let { color = "" } = $$props;
  let { regionHead = "" } = $$props;
  let { regionBody = "" } = $$props;
  let { regionFoot = "" } = $$props;
  function onRowClick(event, rowIndex) {
    if (!interactive)
      return;
    event.preventDefault();
    event.stopPropagation();
    const rowMetaData = source.meta ? source.meta[rowIndex] : source.body[rowIndex];
    dispatch("selected", rowMetaData);
  }
  function onRowKeydown(event, rowIndex) {
    if (["Enter", "Space"].includes(event.code))
      onRowClick(event, rowIndex);
  }
  $$self.$$.on_mount.push(function() {
    if (source === void 0 && !("source" in $$props || $$self.$$.bound[$$self.$$.props["source"]])) {
      console.warn("<Table> was created without expected prop 'source'");
    }
  });
  const click_handler = (rowIndex, e) => {
    onRowClick(e, rowIndex);
  };
  const keydown_handler = (rowIndex, e) => {
    onRowKeydown(e, rowIndex);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("source" in $$new_props)
      $$invalidate(0, source = $$new_props.source);
    if ("interactive" in $$new_props)
      $$invalidate(1, interactive = $$new_props.interactive);
    if ("element" in $$new_props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("text" in $$new_props)
      $$invalidate(10, text2 = $$new_props.text);
    if ("color" in $$new_props)
      $$invalidate(11, color = $$new_props.color);
    if ("regionHead" in $$new_props)
      $$invalidate(2, regionHead = $$new_props.regionHead);
    if ("regionBody" in $$new_props)
      $$invalidate(3, regionBody = $$new_props.regionBody);
    if ("regionFoot" in $$new_props)
      $$invalidate(4, regionFoot = $$new_props.regionFoot);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    tableA11y,
    dispatch,
    source,
    interactive,
    element: element2,
    text: text2,
    color,
    regionHead,
    regionBody,
    regionFoot,
    onRowClick,
    onRowKeydown,
    classesTable,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    if ("source" in $$props)
      $$invalidate(0, source = $$new_props.source);
    if ("interactive" in $$props)
      $$invalidate(1, interactive = $$new_props.interactive);
    if ("element" in $$props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("text" in $$props)
      $$invalidate(10, text2 = $$new_props.text);
    if ("color" in $$props)
      $$invalidate(11, color = $$new_props.color);
    if ("regionHead" in $$props)
      $$invalidate(2, regionHead = $$new_props.regionHead);
    if ("regionBody" in $$props)
      $$invalidate(3, regionBody = $$new_props.regionBody);
    if ("regionFoot" in $$props)
      $$invalidate(4, regionFoot = $$new_props.regionFoot);
    if ("classesTable" in $$props)
      $$invalidate(5, classesTable = $$new_props.classesTable);
    if ("classesBase" in $$props)
      $$invalidate(6, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesBase = `${$$props.class || ""}`);
    if ($$self.$$.dirty & /*element, text, color*/
    3584) {
      $:
        $$invalidate(5, classesTable = `${element2} ${text2} ${color}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    source,
    interactive,
    regionHead,
    regionBody,
    regionFoot,
    classesTable,
    classesBase,
    onRowClick,
    onRowKeydown,
    element2,
    text2,
    color,
    click_handler,
    keydown_handler
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {
      source: 0,
      interactive: 1,
      element: 9,
      text: 10,
      color: 11,
      regionHead: 2,
      regionBody: 3,
      regionFoot: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment23.name
    });
  }
  get source() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHead() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHead(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBody() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBody(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionFoot() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionFoot(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/@skeletonlabs/skeleton/components/Tab/TabGroup.svelte
var file24 = "node_modules/@skeletonlabs/skeleton/components/Tab/TabGroup.svelte";
function create_fragment24(ctx) {
  let nav;
  let ul;
  let ul_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const block = {
    c: function create() {
      nav = element("nav");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true, "data-testid": true });
      var nav_nodes = children(nav);
      ul = claim_element(nav_nodes, "UL", {
        class: true,
        role: true,
        "aria-labelledby": true,
        "aria-label": true
      });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", ul_class_value = "tab-group-list " + /*classesGroup*/
      ctx[3]);
      attr_dev(ul, "role", "tablist");
      attr_dev(
        ul,
        "aria-labelledby",
        /*labeledby*/
        ctx[0]
      );
      attr_dev(
        ul,
        "aria-label",
        /*label*/
        ctx[1]
      );
      add_location(ul, file24, 40, 1, 1304);
      attr_dev(nav, "class", "tab-group");
      attr_dev(nav, "data-testid", "tab-group");
      add_location(nav, file24, 39, 0, 1255);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[17](ul);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          ul,
          "keydown",
          /*keydown*/
          ctx[4],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesGroup*/
      8 && ul_class_value !== (ul_class_value = "tab-group-list " + /*classesGroup*/
      ctx2[3])) {
        attr_dev(ul, "class", ul_class_value);
      }
      if (!current || dirty & /*labeledby*/
      1) {
        attr_dev(
          ul,
          "aria-labelledby",
          /*labeledby*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*label*/
      2) {
        attr_dev(
          ul,
          "aria-label",
          /*label*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if (default_slot)
        default_slot.d(detaching);
      ctx[17](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase17 = "border-surface-300-600-token flex hide-scrollbar overflow-x-auto";
function instance24($$self, $$props, $$invalidate) {
  let classesRail;
  let classesGroup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabGroup", slots, ["default"]);
  let { selected } = $$props;
  let { rail = true } = $$props;
  let { justify = "justify-start" } = $$props;
  let { borderWidth = "border-b-2" } = $$props;
  let { borderColor = "border-primary-500" } = $$props;
  let { color = "text-primary-500" } = $$props;
  let { fill = "fill-primary-500" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { rounded = "rounded-tl-container-token rounded-tr-container-token" } = $$props;
  let { labeledby = "" } = $$props;
  let { label = "" } = $$props;
  setContext("selected", selected);
  setContext("borderWidth", borderWidth);
  setContext("borderColor", borderColor);
  setContext("color", color);
  setContext("fill", fill);
  setContext("hover", hover);
  setContext("rounded", rounded);
  let elemTabGroup;
  function keydown(event) {
    if (["Home", "End"].includes(event.code)) {
      event.preventDefault();
      if (event.code === "Home") {
        elemTabGroup.children[0].focus();
      }
      if (event.code === "End") {
        elemTabGroup.children[elemTabGroup.children.length - 1].focus();
      }
    }
  }
  $$self.$$.on_mount.push(function() {
    if (selected === void 0 && !("selected" in $$props || $$self.$$.bound[$$self.$$.props["selected"]])) {
      console.warn("<TabGroup> was created without expected prop 'selected'");
    }
  });
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemTabGroup = $$value;
      $$invalidate(2, elemTabGroup);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selected" in $$new_props)
      $$invalidate(5, selected = $$new_props.selected);
    if ("rail" in $$new_props)
      $$invalidate(6, rail = $$new_props.rail);
    if ("justify" in $$new_props)
      $$invalidate(7, justify = $$new_props.justify);
    if ("borderWidth" in $$new_props)
      $$invalidate(8, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$new_props)
      $$invalidate(9, borderColor = $$new_props.borderColor);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(11, fill = $$new_props.fill);
    if ("hover" in $$new_props)
      $$invalidate(12, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("labeledby" in $$new_props)
      $$invalidate(0, labeledby = $$new_props.labeledby);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    selected,
    rail,
    justify,
    borderWidth,
    borderColor,
    color,
    fill,
    hover,
    rounded,
    labeledby,
    label,
    cBase: cBase17,
    elemTabGroup,
    keydown,
    classesRail,
    classesGroup
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(5, selected = $$new_props.selected);
    if ("rail" in $$props)
      $$invalidate(6, rail = $$new_props.rail);
    if ("justify" in $$props)
      $$invalidate(7, justify = $$new_props.justify);
    if ("borderWidth" in $$props)
      $$invalidate(8, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$props)
      $$invalidate(9, borderColor = $$new_props.borderColor);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(11, fill = $$new_props.fill);
    if ("hover" in $$props)
      $$invalidate(12, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("labeledby" in $$props)
      $$invalidate(0, labeledby = $$new_props.labeledby);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("elemTabGroup" in $$props)
      $$invalidate(2, elemTabGroup = $$new_props.elemTabGroup);
    if ("classesRail" in $$props)
      $$invalidate(14, classesRail = $$new_props.classesRail);
    if ("classesGroup" in $$props)
      $$invalidate(3, classesGroup = $$new_props.classesGroup);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*rail, borderWidth*/
    320) {
      $:
        $$invalidate(14, classesRail = rail ? borderWidth : "border-0");
    }
    $:
      $$invalidate(3, classesGroup = `${cBase17} ${classesRail} ${justify} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    labeledby,
    label,
    elemTabGroup,
    classesGroup,
    keydown,
    selected,
    rail,
    justify,
    borderWidth,
    borderColor,
    color,
    fill,
    hover,
    rounded,
    classesRail,
    $$scope,
    slots,
    ul_binding
  ];
}
var TabGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      selected: 5,
      rail: 6,
      justify: 7,
      borderWidth: 8,
      borderColor: 9,
      color: 10,
      fill: 11,
      hover: 12,
      rounded: 13,
      labeledby: 0,
      label: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabGroup",
      options,
      id: create_fragment24.name
    });
  }
  get selected() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rail() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rail(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labeledby() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labeledby(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabGroup_default = TabGroup;

// node_modules/@skeletonlabs/skeleton/components/Tab/Tab.svelte
var file25 = "node_modules/@skeletonlabs/skeleton/components/Tab/Tab.svelte";
var get_lead_slot_changes5 = (dirty) => ({});
var get_lead_slot_context5 = (ctx) => ({});
function create_if_block_18(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[19].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_lead_slot_context5
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "tab-lead " + /*classesLead*/
      ctx[4]);
      add_location(div, file25, 50, 19, 1497);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_lead_slot_changes5
            ),
            get_lead_slot_context5
          );
        }
      }
      if (!current || dirty & /*classesLead*/
      16 && div_class_value !== (div_class_value = "tab-lead " + /*classesLead*/
      ctx2[4])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(51:1) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_if_block17(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "aria-label": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "tab-label " + /*classesLabel*/
      ctx[3]);
      attr_dev(
        div,
        "aria-label",
        /*label*/
        ctx[2]
      );
      add_location(div, file25, 52, 22, 1611);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesLabel*/
      8 && div_class_value !== (div_class_value = "tab-label " + /*classesLabel*/
      ctx2[3])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*label*/
      4) {
        attr_dev(
          div,
          "aria-label",
          /*label*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(53:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let li;
  let t;
  let li_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[8].lead && create_if_block_18(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[8].default && create_if_block17(ctx)
  );
  const block = {
    c: function create() {
      li = element("li");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        class: true,
        role: true,
        tabindex: true,
        "data-testid": true
      });
      var li_nodes = children(li);
      if (if_block0)
        if_block0.l(li_nodes);
      t = claim_space(li_nodes);
      if (if_block1)
        if_block1.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", li_class_value = "tab $" + /*classesBase*/
      ctx[5]);
      attr_dev(li, "role", "tab");
      attr_dev(li, "tabindex", "0");
      attr_dev(li, "data-testid", "tab");
      add_location(li, file25, 37, 0, 1283);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (if_block0)
        if_block0.m(li, null);
      append_hydration_dev(li, t);
      if (if_block1)
        if_block1.m(li, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "click",
            /*click_handler*/
            ctx[22],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keydown",
            /*onKeyDown*/
            ctx[7],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keyup",
            /*keyup_handler*/
            ctx[20],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keypress",
            /*keypress_handler*/
            ctx[21],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[8].lead
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_18(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(li, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[8].default
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block17(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(li, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      32 && li_class_value !== (li_class_value = "tab $" + /*classesBase*/
      ctx2[5])) {
        attr_dev(li, "class", li_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase18 = "font-bold list-none py-2.5 px-4 flex items-center space-x-2 cursor-pointer";
var cBorderColor = "border-transparent";
var cBaseLabel3 = "font-bold whitespace-nowrap";
function instance25($$self, $$props, $$invalidate) {
  let isSelected;
  let classesSelected;
  let classesBase;
  let classesLead;
  let classesLabel;
  let $selected, $$unsubscribe_selected = noop, $$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, ($$value) => $$invalidate(17, $selected = $$value)), selected);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selected());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["lead", "default"]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { selected = getContext("selected") } = $$props;
  validate_store(selected, "selected");
  $$subscribe_selected();
  let { borderWidth = getContext("borderWidth") } = $$props;
  let { borderColor = getContext("borderColor") } = $$props;
  let { color = getContext("color") } = $$props;
  let { fill = getContext("fill") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { value = $selected.value } = $$props;
  let { label = "tab" } = $$props;
  function onClickHandler(value2) {
    dispatch("click", value2);
    selected.set(value2);
  }
  function onKeyDown(event) {
    dispatch("keydown", event);
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      event.target.click();
    }
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = () => {
    onClickHandler(value);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selected" in $$new_props)
      $$subscribe_selected($$invalidate(0, selected = $$new_props.selected));
    if ("borderWidth" in $$new_props)
      $$invalidate(9, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$new_props)
      $$invalidate(10, borderColor = $$new_props.borderColor);
    if ("color" in $$new_props)
      $$invalidate(11, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(12, fill = $$new_props.fill);
    if ("hover" in $$new_props)
      $$invalidate(13, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate(2, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    dispatch,
    selected,
    borderWidth,
    borderColor,
    color,
    fill,
    hover,
    rounded,
    value,
    label,
    cBase: cBase18,
    cBorderColor,
    cBaseLabel: cBaseLabel3,
    onClickHandler,
    onKeyDown,
    classesLabel,
    isSelected,
    classesLead,
    classesSelected,
    classesBase,
    $selected
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$subscribe_selected($$invalidate(0, selected = $$new_props.selected));
    if ("borderWidth" in $$props)
      $$invalidate(9, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$props)
      $$invalidate(10, borderColor = $$new_props.borderColor);
    if ("color" in $$props)
      $$invalidate(11, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(12, fill = $$new_props.fill);
    if ("hover" in $$props)
      $$invalidate(13, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("label" in $$props)
      $$invalidate(2, label = $$new_props.label);
    if ("classesLabel" in $$props)
      $$invalidate(3, classesLabel = $$new_props.classesLabel);
    if ("isSelected" in $$props)
      $$invalidate(15, isSelected = $$new_props.isSelected);
    if ("classesLead" in $$props)
      $$invalidate(4, classesLead = $$new_props.classesLead);
    if ("classesSelected" in $$props)
      $$invalidate(16, classesSelected = $$new_props.classesSelected);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, $selected*/
    131074) {
      $:
        $$invalidate(15, isSelected = value == $selected);
    }
    if ($$self.$$.dirty & /*isSelected, borderWidth, borderColor, color, fill*/
    40448) {
      $:
        $$invalidate(16, classesSelected = isSelected ? `${borderWidth} ${borderColor} ${color} ${fill}` : `${borderWidth} ${cBorderColor}`);
    }
    $:
      $$invalidate(5, classesBase = `${cBase18} ${classesSelected} ${hover} ${rounded} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*isSelected, fill*/
    36864) {
      $:
        $$invalidate(4, classesLead = isSelected ? `${fill}` : "fill-token");
    }
  };
  $:
    $$invalidate(3, classesLabel = `${cBaseLabel3}`);
  $$props = exclude_internal_props($$props);
  return [
    selected,
    value,
    label,
    classesLabel,
    classesLead,
    classesBase,
    onClickHandler,
    onKeyDown,
    $$slots,
    borderWidth,
    borderColor,
    color,
    fill,
    hover,
    rounded,
    isSelected,
    classesSelected,
    $selected,
    $$scope,
    slots,
    keyup_handler,
    keypress_handler,
    click_handler
  ];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, {
      selected: 0,
      borderWidth: 9,
      borderColor: 10,
      color: 11,
      fill: 12,
      hover: 13,
      rounded: 14,
      value: 1,
      label: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment25.name
    });
  }
  get selected() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tab_default = Tab;

// node_modules/@skeletonlabs/skeleton/components/TableOfContents/TableOfContents.svelte
var file26 = "node_modules/@skeletonlabs/skeleton/components/TableOfContents/TableOfContents.svelte";
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  child_ctx[29] = i;
  return child_ctx;
}
function create_each_block6(ctx) {
  let li;
  let t0_value = (
    /*headingElem*/
    ctx[27].innerText + ""
  );
  let t0;
  let t1;
  let li_class_value;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[20](
        /*headingElem*/
        ctx[27]
      )
    );
  }
  const block = {
    c: function create() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      t0 = claim_text(li_nodes, t0_value);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", li_class_value = "toc-list-item " + /*classesListItem*/
      ctx[4] + " " + setHeadingClasses(
        /*headingElem*/
        ctx[27]
      ) + " " + /*headingElem*/
      (ctx[27].id === /*activeHeaderId*/
      ctx[3] ? (
        /*active*/
        ctx[1]
      ) : ""));
      add_location(li, file26, 89, 3, 3035);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, t0);
      append_hydration_dev(li, t1);
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", click_handler_1, false, false, false),
          listen_dev(
            li,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keypress",
            /*keypress_handler*/
            ctx[19],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*filteredHeadingsList*/
      4 && t0_value !== (t0_value = /*headingElem*/
      ctx[27].innerText + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*classesListItem, filteredHeadingsList, activeHeaderId, active*/
      30 && li_class_value !== (li_class_value = "toc-list-item " + /*classesListItem*/
      ctx[4] + " " + setHeadingClasses(
        /*headingElem*/
        ctx[27]
      ) + " " + /*headingElem*/
      (ctx[27].id === /*activeHeaderId*/
      ctx[3] ? (
        /*active*/
        ctx[1]
      ) : ""))) {
        attr_dev(li, "class", li_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(88:2) {#each filteredHeadingsList as headingElem, i}",
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let div1;
  let nav;
  let div0;
  let t0;
  let div0_class_value;
  let t1;
  let nav_class_value;
  let div1_class_value;
  let each_value = (
    /*filteredHeadingsList*/
    ctx[2]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      nav = element("nav");
      div0 = element("div");
      t0 = text(
        /*label*/
        ctx[0]
      );
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      nav = claim_element(div1_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      div0 = claim_element(nav_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*label*/
        ctx[0]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(nav_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nav_nodes);
      }
      nav_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "toc-label " + /*classesLabel*/
      ctx[6]);
      add_location(div0, file26, 86, 2, 2903);
      attr_dev(nav, "class", nav_class_value = "toc-list " + /*classesList*/
      ctx[5]);
      add_location(nav, file26, 85, 1, 2864);
      attr_dev(div1, "class", div1_class_value = "toc " + /*classesBase*/
      ctx[7]);
      add_location(div1, file26, 84, 0, 2831);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, nav);
      append_hydration_dev(nav, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(nav, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(nav, null);
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*label*/
      1)
        set_data_dev(
          t0,
          /*label*/
          ctx2[0]
        );
      if (dirty & /*classesLabel*/
      64 && div0_class_value !== (div0_class_value = "toc-label " + /*classesLabel*/
      ctx2[6])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*classesListItem, setHeadingClasses, filteredHeadingsList, activeHeaderId, active, scrollToHeading*/
      30) {
        each_value = /*filteredHeadingsList*/
        ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(nav, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*classesList*/
      32 && nav_class_value !== (nav_class_value = "toc-list " + /*classesList*/
      ctx2[5])) {
        attr_dev(nav, "class", nav_class_value);
      }
      if (dirty & /*classesBase*/
      128 && div1_class_value !== (div1_class_value = "toc " + /*classesBase*/
      ctx2[7])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cLabel7 = "p-4 pt-0";
var cListItem = "px-4 py-2 cursor-pointer";
function setHeadingClasses(headingElem) {
  if (headingElem.tagName === "H3")
    return "ml-3";
  if (headingElem.tagName === "H4")
    return "ml-6";
  if (headingElem.tagName === "H5")
    return "ml-9";
  if (headingElem.tagName === "H6")
    return "ml-12";
  return "";
}
function scrollToHeading(headingElem) {
  const elemTarget = document.querySelector(`#${headingElem.id}`);
  elemTarget.scrollIntoView({ behavior: "smooth" });
}
function instance26($$self, $$props, $$invalidate) {
  let classesBase;
  let classesLabel;
  let classesList;
  let classesListItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableOfContents", slots, []);
  let { scrollParent = "#page" } = $$props;
  let { target = "#page" } = $$props;
  let { allowedHeadings = "h2, h3" } = $$props;
  let { label = "On This Page" } = $$props;
  let { width = "w-[240px]" } = $$props;
  let { spacing = "space-y-4" } = $$props;
  let { text: text2 = "text-surface-600-300-token" } = $$props;
  let { hover = "hover:bg-primary-hover-token" } = $$props;
  let { active = "bg-primary-active-token !text-on-primary-token" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { regionLabel = "font-bold" } = $$props;
  let { regionList = "list-none" } = $$props;
  let elemScrollParent;
  let allowedHeadingsList = [];
  let filteredHeadingsList = [];
  let activeHeaderId;
  function queryAllowedHeadingsList() {
    const elemTarget = document.querySelector(target);
    allowedHeadingsList = elemTarget == null ? void 0 : elemTarget.querySelectorAll(allowedHeadings);
  }
  function generateHeadingList() {
    allowedHeadingsList == null ? void 0 : allowedHeadingsList.forEach((elem, i) => {
      if (elem.hasAttribute("data-toc-ignore"))
        return;
      if (!elem.id) {
        let newId = elem.innerText.replaceAll(/[^a-zA-Z0-9 ]/g, "").replaceAll(" ", "-").toLowerCase();
        elem.id = `${newId}-${i}`;
      }
      filteredHeadingsList.push(elem);
    });
    $$invalidate(2, filteredHeadingsList = [...filteredHeadingsList]);
  }
  function pageScrollHandler() {
    var _a;
    const headingSizeThreadshold = 40;
    let visibleHeadings = [];
    allowedHeadingsList == null ? void 0 : allowedHeadingsList.forEach((header) => {
      const scrollableTop = (elemScrollParent == null ? void 0 : elemScrollParent.getBoundingClientRect().top) || 0;
      const headerBoundTop = header.getBoundingClientRect().top;
      const offsetTop = headerBoundTop - scrollableTop + headingSizeThreadshold;
      if (offsetTop >= 0)
        visibleHeadings.push(header);
    });
    $$invalidate(3, activeHeaderId = (_a = visibleHeadings[0]) == null ? void 0 : _a.id);
  }
  onMount(() => {
    queryAllowedHeadingsList();
    generateHeadingList();
    elemScrollParent = document.querySelector(scrollParent);
    elemScrollParent == null ? void 0 : elemScrollParent.addEventListener("scroll", pageScrollHandler);
    pageScrollHandler();
  });
  onDestroy(() => {
    elemScrollParent == null ? void 0 : elemScrollParent.removeEventListener("scroll", pageScrollHandler);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler_1 = (headingElem) => {
    scrollToHeading(headingElem);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("scrollParent" in $$new_props)
      $$invalidate(8, scrollParent = $$new_props.scrollParent);
    if ("target" in $$new_props)
      $$invalidate(9, target = $$new_props.target);
    if ("allowedHeadings" in $$new_props)
      $$invalidate(10, allowedHeadings = $$new_props.allowedHeadings);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("width" in $$new_props)
      $$invalidate(11, width = $$new_props.width);
    if ("spacing" in $$new_props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("text" in $$new_props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("hover" in $$new_props)
      $$invalidate(14, hover = $$new_props.hover);
    if ("active" in $$new_props)
      $$invalidate(1, active = $$new_props.active);
    if ("rounded" in $$new_props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("regionLabel" in $$new_props)
      $$invalidate(16, regionLabel = $$new_props.regionLabel);
    if ("regionList" in $$new_props)
      $$invalidate(17, regionList = $$new_props.regionList);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    scrollParent,
    target,
    allowedHeadings,
    label,
    width,
    spacing,
    text: text2,
    hover,
    active,
    rounded,
    regionLabel,
    regionList,
    cLabel: cLabel7,
    cListItem,
    elemScrollParent,
    allowedHeadingsList,
    filteredHeadingsList,
    activeHeaderId,
    queryAllowedHeadingsList,
    generateHeadingList,
    setHeadingClasses,
    scrollToHeading,
    pageScrollHandler,
    classesListItem,
    classesList,
    classesLabel,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(26, $$props = assign(assign({}, $$props), $$new_props));
    if ("scrollParent" in $$props)
      $$invalidate(8, scrollParent = $$new_props.scrollParent);
    if ("target" in $$props)
      $$invalidate(9, target = $$new_props.target);
    if ("allowedHeadings" in $$props)
      $$invalidate(10, allowedHeadings = $$new_props.allowedHeadings);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("width" in $$props)
      $$invalidate(11, width = $$new_props.width);
    if ("spacing" in $$props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("text" in $$props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("hover" in $$props)
      $$invalidate(14, hover = $$new_props.hover);
    if ("active" in $$props)
      $$invalidate(1, active = $$new_props.active);
    if ("rounded" in $$props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("regionLabel" in $$props)
      $$invalidate(16, regionLabel = $$new_props.regionLabel);
    if ("regionList" in $$props)
      $$invalidate(17, regionList = $$new_props.regionList);
    if ("elemScrollParent" in $$props)
      elemScrollParent = $$new_props.elemScrollParent;
    if ("allowedHeadingsList" in $$props)
      allowedHeadingsList = $$new_props.allowedHeadingsList;
    if ("filteredHeadingsList" in $$props)
      $$invalidate(2, filteredHeadingsList = $$new_props.filteredHeadingsList);
    if ("activeHeaderId" in $$props)
      $$invalidate(3, activeHeaderId = $$new_props.activeHeaderId);
    if ("classesListItem" in $$props)
      $$invalidate(4, classesListItem = $$new_props.classesListItem);
    if ("classesList" in $$props)
      $$invalidate(5, classesList = $$new_props.classesList);
    if ("classesLabel" in $$props)
      $$invalidate(6, classesLabel = $$new_props.classesLabel);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, classesBase = `${width} ${spacing} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*regionLabel*/
    65536) {
      $:
        $$invalidate(6, classesLabel = `${cLabel7} ${regionLabel}`);
    }
    if ($$self.$$.dirty & /*regionList*/
    131072) {
      $:
        $$invalidate(5, classesList = `${regionList}`);
    }
    if ($$self.$$.dirty & /*text, hover, rounded*/
    57344) {
      $:
        $$invalidate(4, classesListItem = `${cListItem} ${text2} ${hover} ${rounded}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    label,
    active,
    filteredHeadingsList,
    activeHeaderId,
    classesListItem,
    classesList,
    classesLabel,
    classesBase,
    scrollParent,
    target,
    allowedHeadings,
    width,
    spacing,
    text2,
    hover,
    rounded,
    regionLabel,
    regionList,
    click_handler,
    keypress_handler,
    click_handler_1
  ];
}
var TableOfContents = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, {
      scrollParent: 8,
      target: 9,
      allowedHeadings: 10,
      label: 0,
      width: 11,
      spacing: 12,
      text: 13,
      hover: 14,
      active: 1,
      rounded: 15,
      regionLabel: 16,
      regionList: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableOfContents",
      options,
      id: create_fragment26.name
    });
  }
  get scrollParent() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollParent(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowedHeadings() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowedHeadings(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionList() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionList(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableOfContents_default = TableOfContents;

// node_modules/@skeletonlabs/skeleton/utilities/CodeBlock/CodeBlock.svelte
var file27 = "node_modules/@skeletonlabs/skeleton/utilities/CodeBlock/CodeBlock.svelte";
function create_if_block18(ctx) {
  let div;
  let header;
  let span;
  let t0_value = languageFormatter(
    /*language*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let button;
  let t2_value = !/*copyState*/
  ctx[6] ? "Copy" : "Copied ";
  let t2;
  let button_class_value;
  let clipboard_action;
  let header_class_value;
  let t3;
  let pre;
  let code_1;
  let code_1_class_value;
  let pre_class_value;
  let div_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*formatted*/
      ctx2[4]
    )
      return create_if_block_19;
    return create_else_block4;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      header = element("header");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      button = element("button");
      t2 = text(t2_value);
      t3 = space();
      pre = element("pre");
      code_1 = element("code");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      header = claim_element(div_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      span = claim_element(header_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(header_nodes);
      button = claim_element(header_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t2 = claim_text(button_nodes, t2_value);
      button_nodes.forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      t3 = claim_space(div_nodes);
      pre = claim_element(div_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      code_1 = claim_element(pre_nodes, "CODE", { class: true });
      var code_1_nodes = children(code_1);
      if_block.l(code_1_nodes);
      code_1_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "code-block-language text-white/60");
      add_location(span, file27, 44, 2, 1415);
      attr_dev(button, "class", button_class_value = "code-block-btn btn btn-sm " + /*buttonCopy*/
      ctx[3]);
      add_location(button, file27, 46, 2, 1525);
      attr_dev(header, "class", header_class_value = "code-block-header " + cHeader + " " + /*background*/
      ctx[2] + " sticky top-0");
      add_location(header, file27, 42, 1, 1322);
      attr_dev(code_1, "class", code_1_class_value = "code-block-code language-" + /*language*/
      ctx[0]);
      add_location(code_1, file27, 51, 36, 1741);
      attr_dev(pre, "class", pre_class_value = "code-block-pre " + cPre);
      add_location(pre, file27, 51, 1, 1706);
      attr_dev(div, "class", div_class_value = "code-block " + /*classesBase*/
      ctx[7]);
      attr_dev(div, "data-testid", "code-block");
      add_location(div, file27, 40, 0, 1240);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, header);
      append_hydration_dev(header, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(header, t1);
      append_hydration_dev(header, button);
      append_hydration_dev(button, t2);
      append_hydration_dev(div, t3);
      append_hydration_dev(div, pre);
      append_hydration_dev(pre, code_1);
      if_block.m(code_1, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*onCopyClick*/
            ctx[8],
            false,
            false,
            false
          ),
          action_destroyer(clipboard_action = clipboard.call(
            null,
            button,
            /*code*/
            ctx[1]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*language*/
      1 && t0_value !== (t0_value = languageFormatter(
        /*language*/
        ctx2[0]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*copyState*/
      64 && t2_value !== (t2_value = !/*copyState*/
      ctx2[6] ? "Copy" : "Copied "))
        set_data_dev(t2, t2_value);
      if (dirty & /*buttonCopy*/
      8 && button_class_value !== (button_class_value = "code-block-btn btn btn-sm " + /*buttonCopy*/
      ctx2[3])) {
        attr_dev(button, "class", button_class_value);
      }
      if (clipboard_action && is_function(clipboard_action.update) && dirty & /*code*/
      2)
        clipboard_action.update.call(
          null,
          /*code*/
          ctx2[1]
        );
      if (dirty & /*background*/
      4 && header_class_value !== (header_class_value = "code-block-header " + cHeader + " " + /*background*/
      ctx2[2] + " sticky top-0")) {
        attr_dev(header, "class", header_class_value);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(code_1, null);
        }
      }
      if (dirty & /*language*/
      1 && code_1_class_value !== (code_1_class_value = "code-block-code language-" + /*language*/
      ctx2[0])) {
        attr_dev(code_1, "class", code_1_class_value);
      }
      if (dirty & /*classesBase*/
      128 && div_class_value !== (div_class_value = "code-block " + /*classesBase*/
      ctx2[7])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(40:0) {#if language && code}",
    ctx
  });
  return block;
}
function create_else_block4(ctx) {
  let t_value = (
    /*code*/
    ctx[1].trim() + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*code*/
      2 && t_value !== (t_value = /*code*/
      ctx2[1].trim() + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(52:120) {:else}",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*displayCode*/
        ctx[5],
        target,
        anchor
      );
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*displayCode*/
      32)
        html_tag.p(
          /*displayCode*/
          ctx2[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(52:86) {#if formatted}",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let if_block_anchor;
  let if_block = (
    /*language*/
    ctx[0] && /*code*/
    ctx[1] && create_if_block18(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*language*/
        ctx2[0] && /*code*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block18(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase19 = "overflow-hidden shadow";
var cHeader = "text-xs uppercase flex justify-between items-center p-2 pl-4";
var cPre = "whitespace-pre-wrap break-all p-4 pt-1";
function languageFormatter(lang) {
  if (lang === "js")
    return "javascript";
  return lang;
}
function instance27($$self, $$props, $$invalidate) {
  let classesBase;
  let $storeHighlightJs;
  validate_store(storeHighlightJs, "storeHighlightJs");
  component_subscribe($$self, storeHighlightJs, ($$value) => $$invalidate(12, $storeHighlightJs = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeBlock", slots, []);
  const dispatch = createEventDispatcher();
  let { language = "plaintext" } = $$props;
  let { code = "" } = $$props;
  let { background = "bg-[#141517]" } = $$props;
  let { text: text2 = "text-sm" } = $$props;
  let { color = "text-white" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { buttonCopy = "bg-white/5 hover:bg-white/10" } = $$props;
  let formatted = false;
  let displayCode = code;
  let copyState = false;
  function onCopyClick() {
    $$invalidate(6, copyState = true);
    setTimeout(
      () => {
        $$invalidate(6, copyState = false);
      },
      2e3
    );
    dispatch("copy", {});
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("language" in $$new_props)
      $$invalidate(0, language = $$new_props.language);
    if ("code" in $$new_props)
      $$invalidate(1, code = $$new_props.code);
    if ("background" in $$new_props)
      $$invalidate(2, background = $$new_props.background);
    if ("text" in $$new_props)
      $$invalidate(9, text2 = $$new_props.text);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("rounded" in $$new_props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("buttonCopy" in $$new_props)
      $$invalidate(3, buttonCopy = $$new_props.buttonCopy);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    storeHighlightJs,
    clipboard,
    language,
    code,
    background,
    text: text2,
    color,
    rounded,
    buttonCopy,
    cBase: cBase19,
    cHeader,
    cPre,
    formatted,
    displayCode,
    copyState,
    languageFormatter,
    onCopyClick,
    classesBase,
    $storeHighlightJs
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
    if ("language" in $$props)
      $$invalidate(0, language = $$new_props.language);
    if ("code" in $$props)
      $$invalidate(1, code = $$new_props.code);
    if ("background" in $$props)
      $$invalidate(2, background = $$new_props.background);
    if ("text" in $$props)
      $$invalidate(9, text2 = $$new_props.text);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("rounded" in $$props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("buttonCopy" in $$props)
      $$invalidate(3, buttonCopy = $$new_props.buttonCopy);
    if ("formatted" in $$props)
      $$invalidate(4, formatted = $$new_props.formatted);
    if ("displayCode" in $$props)
      $$invalidate(5, displayCode = $$new_props.displayCode);
    if ("copyState" in $$props)
      $$invalidate(6, copyState = $$new_props.copyState);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$storeHighlightJs, code, language*/
    4099) {
      $:
        if ($storeHighlightJs !== void 0) {
          $$invalidate(5, displayCode = $storeHighlightJs.highlight(code, { language }).value.trim());
          $$invalidate(4, formatted = true);
        }
    }
    $:
      $$invalidate(7, classesBase = `${cBase19} ${background} ${text2} ${color} ${rounded} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    language,
    code,
    background,
    buttonCopy,
    formatted,
    displayCode,
    copyState,
    classesBase,
    onCopyClick,
    text2,
    color,
    rounded,
    $storeHighlightJs
  ];
}
var CodeBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {
      language: 0,
      code: 1,
      background: 2,
      text: 9,
      color: 10,
      rounded: 11,
      buttonCopy: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeBlock",
      options,
      id: create_fragment27.name
    });
  }
  get language() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set language(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCopy() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCopy(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeBlock_default = CodeBlock;

// node_modules/@skeletonlabs/skeleton/utilities/Modal/Modal.svelte
var file28 = "node_modules/@skeletonlabs/skeleton/utilities/Modal/Modal.svelte";
function create_if_block19(ctx) {
  let previous_key = (
    /*$modalStore*/
    ctx[13]
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  const block = {
    c: function create() {
      key_block.c();
      key_block_anchor = empty();
    },
    l: function claim(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration_dev(target, key_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$modalStore*/
      8192 && safe_not_equal(previous_key, previous_key = /*$modalStore*/
      ctx2[13])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(key_block_anchor);
      key_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(96:0) {#if $modalStore.length > 0}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let header;
  let raw_value = (
    /*$modalStore*/
    ctx[13][0].title + ""
  );
  let header_class_value;
  const block = {
    c: function create() {
      header = element("header");
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "class", header_class_value = "modal-header " + /*regionHeader*/
      ctx[6]);
      add_location(header, file28, 117, 5, 3503);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      header.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$modalStore*/
      8192 && raw_value !== (raw_value = /*$modalStore*/
      ctx2[13][0].title + ""))
        header.innerHTML = raw_value;
      ;
      if (dirty[0] & /*regionHeader*/
      64 && header_class_value !== (header_class_value = "modal-header " + /*regionHeader*/
      ctx2[6])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(117:4) {#if $modalStore[0]?.title}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let article;
  let raw_value = (
    /*$modalStore*/
    ctx[13][0].body + ""
  );
  let article_class_value;
  const block = {
    c: function create() {
      article = element("article");
      this.h();
    },
    l: function claim(nodes) {
      article = claim_element(nodes, "ARTICLE", { class: true });
      var article_nodes = children(article);
      article_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(article, "class", article_class_value = "modal-body " + /*regionBody*/
      ctx[7]);
      add_location(article, file28, 121, 5, 3649);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, article, anchor);
      article.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$modalStore*/
      8192 && raw_value !== (raw_value = /*$modalStore*/
      ctx2[13][0].body + ""))
        article.innerHTML = raw_value;
      ;
      if (dirty[0] & /*regionBody*/
      128 && article_class_value !== (article_class_value = "modal-body " + /*regionBody*/
      ctx2[7])) {
        attr_dev(article, "class", article_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(article);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(121:4) {#if $modalStore[0]?.body}",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let img;
  let img_class_value;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(img, "class", img_class_value = "modal-image " + cModalImage);
      if (!src_url_equal(img.src, img_src_value = /*$modalStore*/
      (_a = ctx[13][0]) == null ? void 0 : _a.image))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Modal");
      add_location(img, file28, 125, 5, 3839);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a;
      if (dirty[0] & /*$modalStore*/
      8192 && !src_url_equal(img.src, img_src_value = /*$modalStore*/
      (_a = ctx2[13][0]) == null ? void 0 : _a.image)) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(125:4) {#if $modalStore[0]?.image && typeof $modalStore[0]?.image === 'string'}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  var _a, _b;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*$modalStore*/
    (_a = ctx[13][0].component) == null ? void 0 : _a.props,
    { parent: (
      /*parent*/
      ctx[10]
    ) }
  ];
  var switch_value = (
    /*$modalStore*/
    (_b = ctx[13][0].component) == null ? void 0 : _b.ref
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      const switch_instance_changes = dirty[0] & /*$modalStore, parent*/
      9216 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*$modalStore*/
        8192 && get_spread_object(
          /*$modalStore*/
          (_a2 = ctx2[13][0].component) == null ? void 0 : _a2.props
        ),
        dirty[0] & /*parent*/
        1024 && { parent: (
          /*parent*/
          ctx2[10]
        ) }
      ]) : {};
      if (dirty[0] & /*$modalStore*/
      8192 | dirty[1] & /*$$scope*/
      1) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = /*$modalStore*/
      (_b2 = ctx2[13][0].component) == null ? void 0 : _b2.ref)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(150:50) ",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let input;
  let t0;
  let footer;
  let button0;
  let t1;
  let button0_class_value;
  let t2;
  let button1;
  let t3;
  let button1_class_value;
  let button1_disabled_value;
  let footer_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      footer = element("footer");
      button0 = element("button");
      t1 = text(
        /*buttonTextCancel*/
        ctx[0]
      );
      t2 = space();
      button1 = element("button");
      t3 = text(
        /*buttonTextSubmit*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { class: true, type: true });
      t0 = claim_space(nodes);
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button0 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t1 = claim_text(
        button0_nodes,
        /*buttonTextCancel*/
        ctx[0]
      );
      button0_nodes.forEach(detach_dev);
      t2 = claim_space(footer_nodes);
      button1 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      t3 = claim_text(
        button1_nodes,
        /*buttonTextSubmit*/
        ctx[2]
      );
      button1_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "modal-prompt-input");
      attr_dev(input, "type", "text");
      add_location(input, file28, 143, 5, 4645);
      attr_dev(button0, "class", button0_class_value = "btn " + /*buttonNeutral*/
      ctx[4]);
      add_location(button0, file28, 146, 5, 4804);
      attr_dev(button1, "class", button1_class_value = "btn " + /*buttonPositive*/
      ctx[5]);
      button1.disabled = button1_disabled_value = !/*promptValue*/
      ctx[9];
      add_location(button1, file28, 147, 5, 4892);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + /*regionFooter*/
      ctx[8]);
      add_location(footer, file28, 145, 5, 4754);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*promptValue*/
        ctx[9]
      );
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, footer, anchor);
      append_hydration_dev(footer, button0);
      append_hydration_dev(button0, t1);
      append_hydration_dev(footer, t2);
      append_hydration_dev(footer, button1);
      append_hydration_dev(button1, t3);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[27]
          ),
          listen_dev(
            button0,
            "click",
            /*onClose*/
            ctx[15],
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*onPromptSubmit*/
            ctx[17],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*promptValue*/
      512 && input.value !== /*promptValue*/
      ctx2[9]) {
        set_input_value(
          input,
          /*promptValue*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*buttonTextCancel*/
      1)
        set_data_dev(
          t1,
          /*buttonTextCancel*/
          ctx2[0]
        );
      if (dirty[0] & /*buttonNeutral*/
      16 && button0_class_value !== (button0_class_value = "btn " + /*buttonNeutral*/
      ctx2[4])) {
        attr_dev(button0, "class", button0_class_value);
      }
      if (dirty[0] & /*buttonTextSubmit*/
      4)
        set_data_dev(
          t3,
          /*buttonTextSubmit*/
          ctx2[2]
        );
      if (dirty[0] & /*buttonPositive*/
      32 && button1_class_value !== (button1_class_value = "btn " + /*buttonPositive*/
      ctx2[5])) {
        attr_dev(button1, "class", button1_class_value);
      }
      if (dirty[0] & /*promptValue*/
      512 && button1_disabled_value !== (button1_disabled_value = !/*promptValue*/
      ctx2[9])) {
        prop_dev(button1, "disabled", button1_disabled_value);
      }
      if (dirty[0] & /*regionFooter*/
      256 && footer_class_value !== (footer_class_value = "modal-footer " + /*regionFooter*/
      ctx2[8])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(footer);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(142:47) ",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let footer;
  let button0;
  let t0;
  let button0_class_value;
  let t1;
  let button1;
  let t2;
  let button1_class_value;
  let footer_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      footer = element("footer");
      button0 = element("button");
      t0 = text(
        /*buttonTextCancel*/
        ctx[0]
      );
      t1 = space();
      button1 = element("button");
      t2 = text(
        /*buttonTextConfirm*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button0 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t0 = claim_text(
        button0_nodes,
        /*buttonTextCancel*/
        ctx[0]
      );
      button0_nodes.forEach(detach_dev);
      t1 = claim_space(footer_nodes);
      button1 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      t2 = claim_text(
        button1_nodes,
        /*buttonTextConfirm*/
        ctx[1]
      );
      button1_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "class", button0_class_value = "btn " + /*buttonNeutral*/
      ctx[4]);
      add_location(button0, file28, 138, 5, 4372);
      attr_dev(button1, "class", button1_class_value = "btn " + /*buttonPositive*/
      ctx[5]);
      add_location(button1, file28, 139, 5, 4460);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + /*regionFooter*/
      ctx[8]);
      add_location(footer, file28, 137, 5, 4322);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      append_hydration_dev(footer, button0);
      append_hydration_dev(button0, t0);
      append_hydration_dev(footer, t1);
      append_hydration_dev(footer, button1);
      append_hydration_dev(button1, t2);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*onClose*/
            ctx[15],
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*onConfirm*/
            ctx[16],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextCancel*/
      1)
        set_data_dev(
          t0,
          /*buttonTextCancel*/
          ctx2[0]
        );
      if (dirty[0] & /*buttonNeutral*/
      16 && button0_class_value !== (button0_class_value = "btn " + /*buttonNeutral*/
      ctx2[4])) {
        attr_dev(button0, "class", button0_class_value);
      }
      if (dirty[0] & /*buttonTextConfirm*/
      2)
        set_data_dev(
          t2,
          /*buttonTextConfirm*/
          ctx2[1]
        );
      if (dirty[0] & /*buttonPositive*/
      32 && button1_class_value !== (button1_class_value = "btn " + /*buttonPositive*/
      ctx2[5])) {
        attr_dev(button1, "class", button1_class_value);
      }
      if (dirty[0] & /*regionFooter*/
      256 && footer_class_value !== (footer_class_value = "modal-footer " + /*regionFooter*/
      ctx2[8])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(135:48) ",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let footer;
  let button;
  let t;
  let button_class_value;
  let footer_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      footer = element("footer");
      button = element("button");
      t = text(
        /*buttonTextCancel*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button = claim_element(footer_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(
        button_nodes,
        /*buttonTextCancel*/
        ctx[0]
      );
      button_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "btn " + /*buttonNeutral*/
      ctx[4]);
      add_location(button, file28, 132, 6, 4108);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + /*regionFooter*/
      ctx[8]);
      add_location(footer, file28, 130, 5, 4026);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      append_hydration_dev(footer, button);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*onClose*/
          ctx[15],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextCancel*/
      1)
        set_data_dev(
          t,
          /*buttonTextCancel*/
          ctx2[0]
        );
      if (dirty[0] & /*buttonNeutral*/
      16 && button_class_value !== (button_class_value = "btn " + /*buttonNeutral*/
      ctx2[4])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty[0] & /*regionFooter*/
      256 && footer_class_value !== (footer_class_value = "modal-footer " + /*regionFooter*/
      ctx2[8])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(129:4) {#if $modalStore[0].type === 'alert'}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  var _a;
  let html_tag;
  let raw_value = (
    /*$modalStore*/
    ((_a = ctx[13][0].component) == null ? void 0 : _a.slot) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (dirty[0] & /*$modalStore*/
      8192 && raw_value !== (raw_value = /*$modalStore*/
      ((_a2 = ctx2[13][0].component) == null ? void 0 : _a2.slot) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(153:5) <svelte:component this={$modalStore[0].component?.ref} {...$modalStore[0].component?.props} {parent}>",
    ctx
  });
  return block;
}
function create_key_block(ctx) {
  var _a, _b, _c, _d;
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let current_block_type_index;
  let if_block3;
  let div0_class_value;
  let div0_aria_label_value;
  let focusTrap_action;
  let div0_transition;
  let div1_class_value;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$modalStore*/
    ((_a = ctx[13][0]) == null ? void 0 : _a.title) && create_if_block_7(ctx)
  );
  let if_block1 = (
    /*$modalStore*/
    ((_b = ctx[13][0]) == null ? void 0 : _b.body) && create_if_block_6(ctx)
  );
  let if_block2 = (
    /*$modalStore*/
    ((_c = ctx[13][0]) == null ? void 0 : _c.image) && typeof /*$modalStore*/
    ((_d = ctx[13][0]) == null ? void 0 : _d.image) === "string" && create_if_block_52(ctx)
  );
  const if_block_creators = [create_if_block_110, create_if_block_25, create_if_block_33, create_if_block_43];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$modalStore*/
      ctx2[13][0].type === "alert"
    )
      return 0;
    if (
      /*$modalStore*/
      ctx2[13][0].type === "confirm"
    )
      return 1;
    if (
      /*$modalStore*/
      ctx2[13][0].type === "prompt"
    )
      return 2;
    if (
      /*$modalStore*/
      ctx2[13][0].type === "component"
    )
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-modal": true,
        "aria-label": true
      });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block3)
        if_block3.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "modal " + /*classesModal*/
      ctx[11] + " " + /*$modalStore*/
      ctx[13][0].modalClasses);
      attr_dev(div0, "data-testid", "modal");
      attr_dev(div0, "role", "dialog");
      attr_dev(div0, "aria-modal", "true");
      attr_dev(div0, "aria-label", div0_aria_label_value = /*$modalStore*/
      ctx[13][0].title);
      add_location(div0, file28, 106, 3, 3192);
      attr_dev(div1, "class", div1_class_value = "modal-backdrop " + /*classesBackdrop*/
      ctx[12] + " " + /*$modalStore*/
      ctx[13][0].backdropClasses);
      attr_dev(div1, "data-testid", "modal-backdrop");
      add_location(div1, file28, 98, 2, 2938);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration_dev(div0, t2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(focusTrap_action = focusTrap.call(null, div0, true)),
          listen_dev(
            div1,
            "mousedown",
            /*onBackdropInteraction*/
            ctx[14],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchstart",
            /*onBackdropInteraction*/
            ctx[14],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      var _a2, _b2, _c2, _d2;
      ctx = new_ctx;
      if (
        /*$modalStore*/
        (_a2 = ctx[13][0]) == null ? void 0 : _a2.title
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_7(ctx);
          if_block0.c();
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$modalStore*/
        (_b2 = ctx[13][0]) == null ? void 0 : _b2.body
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_6(ctx);
          if_block1.c();
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$modalStore*/
        ((_c2 = ctx[13][0]) == null ? void 0 : _c2.image) && typeof /*$modalStore*/
        ((_d2 = ctx[13][0]) == null ? void 0 : _d2.image) === "string"
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_52(ctx);
          if_block2.c();
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block3) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block3 = if_blocks[current_block_type_index];
          if (!if_block3) {
            if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block3.c();
          } else {
            if_block3.p(ctx, dirty);
          }
          transition_in(if_block3, 1);
          if_block3.m(div0, null);
        } else {
          if_block3 = null;
        }
      }
      if (!current || dirty[0] & /*classesModal, $modalStore*/
      10240 && div0_class_value !== (div0_class_value = "modal " + /*classesModal*/
      ctx[11] + " " + /*$modalStore*/
      ctx[13][0].modalClasses)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*$modalStore*/
      8192 && div0_aria_label_value !== (div0_aria_label_value = /*$modalStore*/
      ctx[13][0].title)) {
        attr_dev(div0, "aria-label", div0_aria_label_value);
      }
      if (!current || dirty[0] & /*classesBackdrop, $modalStore*/
      12288 && div1_class_value !== (div1_class_value = "modal-backdrop " + /*classesBackdrop*/
      ctx[12] + " " + /*$modalStore*/
      ctx[13][0].backdropClasses)) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block3);
      add_render_callback(() => {
        if (!div0_transition)
          div0_transition = create_bidirectional_transition(
            div0,
            fly,
            {
              duration: (
                /*duration*/
                ctx[3]
              ),
              opacity: 0,
              y: 100
            },
            true
          );
        div0_transition.run(1);
      });
      add_render_callback(() => {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, { duration: (
            /*duration*/
            ctx[3]
          ) }, true);
        div1_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block3);
      if (!div0_transition)
        div0_transition = create_bidirectional_transition(
          div0,
          fly,
          {
            duration: (
              /*duration*/
              ctx[3]
            ),
            opacity: 0,
            y: 100
          },
          false
        );
      div0_transition.run(0);
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(div1, fade, { duration: (
          /*duration*/
          ctx[3]
        ) }, false);
      div1_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching && div0_transition)
        div0_transition.end();
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(97:1) {#key $modalStore}",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$modalStore*/
    ctx[13].length > 0 && create_if_block19(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "keydown",
          /*onKeyDown*/
          ctx[18],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$modalStore*/
        ctx2[13].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$modalStore*/
          8192) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBackdrop = "fixed top-0 left-0 right-0 bottom-0 z-[999] flex justify-center items-center p-4";
var cModal = "max-h-full overflow-y-auto overflow-x-hidden";
var cModalImage = "w-full h-auto";
function instance28($$self, $$props, $$invalidate) {
  let classesBackdrop;
  let classesModal;
  let parent;
  let $modalStore;
  validate_store(modalStore, "modalStore");
  component_subscribe($$self, modalStore, ($$value) => $$invalidate(13, $modalStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, []);
  const dispatch = createEventDispatcher();
  let { duration = 150 } = $$props;
  let { background = "bg-surface-100-800-token" } = $$props;
  let { width = "w-full max-w-[640px]" } = $$props;
  let { height = "h-auto" } = $$props;
  let { padding = "p-4" } = $$props;
  let { spacing = "space-y-4" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { shadow = "shadow-xl" } = $$props;
  let { buttonNeutral = "variant-ghost-surface" } = $$props;
  let { buttonPositive = "variant-filled-primary" } = $$props;
  let { buttonTextCancel = "Cancel" } = $$props;
  let { buttonTextConfirm = "Confirm" } = $$props;
  let { buttonTextSubmit = "Submit" } = $$props;
  let { regionBackdrop = "bg-surface-backdrop-token" } = $$props;
  let { regionHeader = "text-2xl font-bold" } = $$props;
  let { regionBody = "max-h-[200px] overflow-hidden" } = $$props;
  let { regionFooter = "flex justify-end space-x-2" } = $$props;
  let promptValue;
  const buttonTextDefaults = {
    buttonTextCancel,
    buttonTextConfirm,
    buttonTextSubmit
  };
  modalStore.subscribe((dArr) => {
    if (!dArr.length)
      return;
    $$invalidate(9, promptValue = dArr[0].value);
    $$invalidate(0, buttonTextCancel = dArr[0].buttonTextCancel || buttonTextDefaults.buttonTextCancel);
    $$invalidate(1, buttonTextConfirm = dArr[0].buttonTextConfirm || buttonTextDefaults.buttonTextConfirm);
    $$invalidate(2, buttonTextSubmit = dArr[0].buttonTextSubmit || buttonTextDefaults.buttonTextSubmit);
  });
  function onBackdropInteraction(event) {
    if (!(event.target instanceof Element))
      return;
    if (event.target.classList.contains("modal-backdrop"))
      onClose();
    dispatch("backdrop", event);
  }
  function onClose() {
    if ($modalStore[0].response)
      $modalStore[0].response(false);
    modalStore.close();
  }
  function onConfirm() {
    if ($modalStore[0].response)
      $modalStore[0].response(true);
    modalStore.close();
  }
  function onPromptSubmit() {
    if ($modalStore[0].response)
      $modalStore[0].response(promptValue);
    modalStore.close();
  }
  function onKeyDown(event) {
    if (!$modalStore.length)
      return;
    if (event.code === "Escape")
      onClose();
  }
  function input_input_handler() {
    promptValue = this.value;
    $$invalidate(9, promptValue);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(30, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("duration" in $$new_props)
      $$invalidate(3, duration = $$new_props.duration);
    if ("background" in $$new_props)
      $$invalidate(19, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(20, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(21, height = $$new_props.height);
    if ("padding" in $$new_props)
      $$invalidate(22, padding = $$new_props.padding);
    if ("spacing" in $$new_props)
      $$invalidate(23, spacing = $$new_props.spacing);
    if ("rounded" in $$new_props)
      $$invalidate(24, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(25, shadow = $$new_props.shadow);
    if ("buttonNeutral" in $$new_props)
      $$invalidate(4, buttonNeutral = $$new_props.buttonNeutral);
    if ("buttonPositive" in $$new_props)
      $$invalidate(5, buttonPositive = $$new_props.buttonPositive);
    if ("buttonTextCancel" in $$new_props)
      $$invalidate(0, buttonTextCancel = $$new_props.buttonTextCancel);
    if ("buttonTextConfirm" in $$new_props)
      $$invalidate(1, buttonTextConfirm = $$new_props.buttonTextConfirm);
    if ("buttonTextSubmit" in $$new_props)
      $$invalidate(2, buttonTextSubmit = $$new_props.buttonTextSubmit);
    if ("regionBackdrop" in $$new_props)
      $$invalidate(26, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionHeader" in $$new_props)
      $$invalidate(6, regionHeader = $$new_props.regionHeader);
    if ("regionBody" in $$new_props)
      $$invalidate(7, regionBody = $$new_props.regionBody);
    if ("regionFooter" in $$new_props)
      $$invalidate(8, regionFooter = $$new_props.regionFooter);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    fade,
    fly,
    dispatch,
    focusTrap,
    modalStore,
    duration,
    background,
    width,
    height,
    padding,
    spacing,
    rounded,
    shadow,
    buttonNeutral,
    buttonPositive,
    buttonTextCancel,
    buttonTextConfirm,
    buttonTextSubmit,
    regionBackdrop,
    regionHeader,
    regionBody,
    regionFooter,
    cBackdrop,
    cModal,
    cModalImage,
    promptValue,
    buttonTextDefaults,
    onBackdropInteraction,
    onClose,
    onConfirm,
    onPromptSubmit,
    onKeyDown,
    parent,
    classesModal,
    classesBackdrop,
    $modalStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(30, $$props = assign(assign({}, $$props), $$new_props));
    if ("duration" in $$props)
      $$invalidate(3, duration = $$new_props.duration);
    if ("background" in $$props)
      $$invalidate(19, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(20, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(21, height = $$new_props.height);
    if ("padding" in $$props)
      $$invalidate(22, padding = $$new_props.padding);
    if ("spacing" in $$props)
      $$invalidate(23, spacing = $$new_props.spacing);
    if ("rounded" in $$props)
      $$invalidate(24, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(25, shadow = $$new_props.shadow);
    if ("buttonNeutral" in $$props)
      $$invalidate(4, buttonNeutral = $$new_props.buttonNeutral);
    if ("buttonPositive" in $$props)
      $$invalidate(5, buttonPositive = $$new_props.buttonPositive);
    if ("buttonTextCancel" in $$props)
      $$invalidate(0, buttonTextCancel = $$new_props.buttonTextCancel);
    if ("buttonTextConfirm" in $$props)
      $$invalidate(1, buttonTextConfirm = $$new_props.buttonTextConfirm);
    if ("buttonTextSubmit" in $$props)
      $$invalidate(2, buttonTextSubmit = $$new_props.buttonTextSubmit);
    if ("regionBackdrop" in $$props)
      $$invalidate(26, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionHeader" in $$props)
      $$invalidate(6, regionHeader = $$new_props.regionHeader);
    if ("regionBody" in $$props)
      $$invalidate(7, regionBody = $$new_props.regionBody);
    if ("regionFooter" in $$props)
      $$invalidate(8, regionFooter = $$new_props.regionFooter);
    if ("promptValue" in $$props)
      $$invalidate(9, promptValue = $$new_props.promptValue);
    if ("parent" in $$props)
      $$invalidate(10, parent = $$new_props.parent);
    if ("classesModal" in $$props)
      $$invalidate(11, classesModal = $$new_props.classesModal);
    if ("classesBackdrop" in $$props)
      $$invalidate(12, classesBackdrop = $$new_props.classesBackdrop);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(12, classesBackdrop = `${cBackdrop} ${regionBackdrop} ${$$props.class || ""}`);
    if ($$self.$$.dirty[0] & /*background, width, height, padding, spacing, rounded, shadow*/
    66584576) {
      $:
        $$invalidate(11, classesModal = `${cModal} ${background} ${width} ${height} ${padding} ${spacing} ${rounded} ${shadow}`);
    }
    if ($$self.$$.dirty[0] & /*background, width, height, padding, spacing, rounded, shadow, buttonNeutral, buttonPositive, buttonTextCancel, buttonTextConfirm, buttonTextSubmit, regionBackdrop, regionHeader, regionBody, regionFooter*/
    133693943) {
      $:
        $$invalidate(10, parent = {
          background,
          width,
          height,
          padding,
          spacing,
          rounded,
          shadow,
          buttonNeutral,
          buttonPositive,
          buttonTextCancel,
          buttonTextConfirm,
          buttonTextSubmit,
          regionBackdrop,
          regionHeader,
          regionBody,
          regionFooter,
          onClose
        });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    buttonTextCancel,
    buttonTextConfirm,
    buttonTextSubmit,
    duration,
    buttonNeutral,
    buttonPositive,
    regionHeader,
    regionBody,
    regionFooter,
    promptValue,
    parent,
    classesModal,
    classesBackdrop,
    $modalStore,
    onBackdropInteraction,
    onClose,
    onConfirm,
    onPromptSubmit,
    onKeyDown,
    background,
    width,
    height,
    padding,
    spacing,
    rounded,
    shadow,
    regionBackdrop,
    input_input_handler
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance28,
      create_fragment28,
      safe_not_equal,
      {
        duration: 3,
        background: 19,
        width: 20,
        height: 21,
        padding: 22,
        spacing: 23,
        rounded: 24,
        shadow: 25,
        buttonNeutral: 4,
        buttonPositive: 5,
        buttonTextCancel: 0,
        buttonTextConfirm: 1,
        buttonTextSubmit: 2,
        regionBackdrop: 26,
        regionHeader: 6,
        regionBody: 7,
        regionFooter: 8
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment28.name
    });
  }
  get duration() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNeutral() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNeutral(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonPositive() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonPositive(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextCancel() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextCancel(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextConfirm() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextConfirm(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextSubmit() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextSubmit(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBackdrop() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBackdrop(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHeader() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHeader(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBody() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBody(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionFooter() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionFooter(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/@skeletonlabs/skeleton/utilities/Drawer/Drawer.svelte
var { window: window_1 } = globals;
var file29 = "node_modules/@skeletonlabs/skeleton/utilities/Drawer/Drawer.svelte";
function create_if_block20(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div0_transition;
  let div1_class_value;
  let focusTrap_action;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-modal": true,
        "aria-labelledby": true,
        "aria-describedby": true
      });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "drawer " + /*classesDrawer*/
      ctx[5]);
      attr_dev(div0, "data-testid", "drawer");
      attr_dev(div0, "role", "dialog");
      attr_dev(div0, "aria-modal", "true");
      attr_dev(
        div0,
        "aria-labelledby",
        /*labelledby*/
        ctx[1]
      );
      attr_dev(
        div0,
        "aria-describedby",
        /*describedby*/
        ctx[2]
      );
      add_location(div0, file29, 120, 2, 3931);
      attr_dev(div1, "class", div1_class_value = "drawer-backdrop " + /*classesBackdrop*/
      ctx[6]);
      attr_dev(div1, "data-testid", "drawer-backdrop");
      add_location(div1, file29, 109, 1, 3645);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[25](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "mousedown",
            /*onBackdropInteraction*/
            ctx[8],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchstart",
            /*onBackdropInteraction*/
            ctx[8],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[24],
            false,
            false,
            false
          ),
          action_destroyer(focusTrap_action = focusTrap.call(null, div1, true))
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[22],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesDrawer*/
      32 && div0_class_value !== (div0_class_value = "drawer " + /*classesDrawer*/
      ctx[5])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*labelledby*/
      2) {
        attr_dev(
          div0,
          "aria-labelledby",
          /*labelledby*/
          ctx[1]
        );
      }
      if (!current || dirty[0] & /*describedby*/
      4) {
        attr_dev(
          div0,
          "aria-describedby",
          /*describedby*/
          ctx[2]
        );
      }
      if (!current || dirty[0] & /*classesBackdrop*/
      64 && div1_class_value !== (div1_class_value = "drawer-backdrop " + /*classesBackdrop*/
      ctx[6])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!div0_transition)
            div0_transition = create_bidirectional_transition(
              div0,
              fly,
              {
                x: (
                  /*animSettings*/
                  ctx[4].x
                ),
                y: (
                  /*animSettings*/
                  ctx[4].y
                ),
                duration: (
                  /*duration*/
                  ctx[0]
                )
              },
              true
            );
          div0_transition.run(1);
        });
      }
      if (local) {
        add_render_callback(() => {
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(div1, fade, { duration: (
              /*duration*/
              ctx[0]
            ) }, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div0_transition)
          div0_transition = create_bidirectional_transition(
            div0,
            fly,
            {
              x: (
                /*animSettings*/
                ctx[4].x
              ),
              y: (
                /*animSettings*/
                ctx[4].y
              ),
              duration: (
                /*duration*/
                ctx[0]
              )
            },
            false
          );
        div0_transition.run(0);
      }
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, { duration: (
            /*duration*/
            ctx[0]
          ) }, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div0_transition)
        div0_transition.end();
      ctx[25](null);
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(108:0) {#if $drawerStore.open === true}",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$drawerStore*/
    ctx[7].open === true && create_if_block20(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window_1,
          "keydown",
          /*onKeydownWindow*/
          ctx[9],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$drawerStore*/
        ctx2[7].open === true
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$drawerStore*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBaseBackdrop = "fixed top-0 left-0 right-0 bottom-0 z-40 flex";
var cBaseDrawer = "shadow-xl overflow-y-auto";
function percentage(percent, amount) {
  return amount / 100 * percent;
}
function instance29($$self, $$props, $$invalidate) {
  let classesWidth;
  let classesHeight;
  let classesBackdrop;
  let classesDrawer;
  let $drawerStore;
  validate_store(drawerStore, "drawerStore");
  component_subscribe($$self, drawerStore, ($$value) => $$invalidate(7, $drawerStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Drawer", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { position = "left" } = $$props;
  let { duration = 150 } = $$props;
  let { bgBackdrop = "bg-surface-backdrop-token" } = $$props;
  let { blur = "backdrop-blur-xs" } = $$props;
  let { bgDrawer = "bg-surface-100-800-token" } = $$props;
  let { border = "" } = $$props;
  let { rounded = "" } = $$props;
  let { width = "" } = $$props;
  let { height = "" } = $$props;
  let { margin = "" } = $$props;
  let { labelledby = "" } = $$props;
  let { describedby = "" } = $$props;
  let elemBackdrop;
  let windowSettings = { width: 1920, height: 1080 };
  let styleSettings = { backdrop: "", width: "", height: "" };
  let animSettings = { x: 0, y: 0 };
  const propDefaults = {
    position,
    duration,
    bgBackdrop,
    blur,
    bgDrawer,
    border,
    rounded,
    width,
    height,
    margin,
    labelledby,
    describedby
  };
  drawerStore.subscribe((settings) => {
    if (settings.open === false)
      return;
    applySettings(settings);
    setPosition();
  });
  function applySettings(settings) {
    $$invalidate(18, position = settings.position || propDefaults.position);
    $$invalidate(0, duration = settings.duration || propDefaults.duration);
    $$invalidate(10, bgBackdrop = settings.bgBackdrop || propDefaults.bgBackdrop);
    $$invalidate(11, blur = settings.blur || propDefaults.blur);
    $$invalidate(12, bgDrawer = settings.bgDrawer || propDefaults.bgDrawer);
    $$invalidate(13, border = settings.border || propDefaults.border);
    $$invalidate(14, rounded = settings.rounded || propDefaults.rounded);
    $$invalidate(15, width = settings.width || propDefaults.width);
    $$invalidate(16, height = settings.height || propDefaults.height);
    $$invalidate(17, margin = settings.margin || propDefaults.margin);
    $$invalidate(1, labelledby = settings.labelledby || propDefaults.labelledby);
    $$invalidate(2, describedby = settings.describedby || propDefaults.describedby);
  }
  function setPosition() {
    switch (position) {
      case "top":
        $$invalidate(19, styleSettings = {
          backdrop: "flex-col justify-start",
          width: "w-full",
          height: "h-[40%]"
        });
        $$invalidate(4, animSettings = {
          x: 0,
          y: -percentage(40, windowSettings.height)
        });
        break;
      case "bottom":
        $$invalidate(19, styleSettings = {
          backdrop: "flex-col justify-end",
          width: "w-full",
          height: "h-[40%]"
        });
        $$invalidate(4, animSettings = {
          x: 0,
          y: percentage(40, windowSettings.height)
        });
        break;
      case "right":
        $$invalidate(19, styleSettings = {
          backdrop: "justify-end",
          width: "w-[90%]",
          height: "h-full"
        });
        $$invalidate(4, animSettings = {
          x: percentage(90, windowSettings.width),
          y: 0
        });
        break;
      default:
        $$invalidate(19, styleSettings = {
          backdrop: "justify-start",
          width: "w-[90%]",
          height: "h-full"
        });
        $$invalidate(4, animSettings = {
          x: -percentage(90, windowSettings.width),
          y: 0
        });
        break;
    }
  }
  function onBackdropInteraction(event) {
    if (event.target === elemBackdrop)
      drawerStore.close();
    dispatch("backdrop", event);
  }
  function onKeydownWindow(event) {
    if (!$drawerStore)
      return;
    if (event.code === "Escape")
      drawerStore.close();
  }
  onMount(() => {
    windowSettings.width = window.innerWidth;
    windowSettings.height = window.innerHeight;
  });
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemBackdrop = $$value;
      $$invalidate(3, elemBackdrop);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("position" in $$new_props)
      $$invalidate(18, position = $$new_props.position);
    if ("duration" in $$new_props)
      $$invalidate(0, duration = $$new_props.duration);
    if ("bgBackdrop" in $$new_props)
      $$invalidate(10, bgBackdrop = $$new_props.bgBackdrop);
    if ("blur" in $$new_props)
      $$invalidate(11, blur = $$new_props.blur);
    if ("bgDrawer" in $$new_props)
      $$invalidate(12, bgDrawer = $$new_props.bgDrawer);
    if ("border" in $$new_props)
      $$invalidate(13, border = $$new_props.border);
    if ("rounded" in $$new_props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("width" in $$new_props)
      $$invalidate(15, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(16, height = $$new_props.height);
    if ("margin" in $$new_props)
      $$invalidate(17, margin = $$new_props.margin);
    if ("labelledby" in $$new_props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("describedby" in $$new_props)
      $$invalidate(2, describedby = $$new_props.describedby);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fade,
    fly,
    createEventDispatcher,
    onMount,
    dispatch,
    focusTrap,
    drawerStore,
    position,
    duration,
    bgBackdrop,
    blur,
    bgDrawer,
    border,
    rounded,
    width,
    height,
    margin,
    labelledby,
    describedby,
    cBaseBackdrop,
    cBaseDrawer,
    elemBackdrop,
    windowSettings,
    styleSettings,
    animSettings,
    propDefaults,
    applySettings,
    setPosition,
    percentage,
    onBackdropInteraction,
    onKeydownWindow,
    classesHeight,
    classesWidth,
    classesDrawer,
    classesBackdrop,
    $drawerStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), $$new_props));
    if ("position" in $$props)
      $$invalidate(18, position = $$new_props.position);
    if ("duration" in $$props)
      $$invalidate(0, duration = $$new_props.duration);
    if ("bgBackdrop" in $$props)
      $$invalidate(10, bgBackdrop = $$new_props.bgBackdrop);
    if ("blur" in $$props)
      $$invalidate(11, blur = $$new_props.blur);
    if ("bgDrawer" in $$props)
      $$invalidate(12, bgDrawer = $$new_props.bgDrawer);
    if ("border" in $$props)
      $$invalidate(13, border = $$new_props.border);
    if ("rounded" in $$props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("width" in $$props)
      $$invalidate(15, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(16, height = $$new_props.height);
    if ("margin" in $$props)
      $$invalidate(17, margin = $$new_props.margin);
    if ("labelledby" in $$props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("describedby" in $$props)
      $$invalidate(2, describedby = $$new_props.describedby);
    if ("elemBackdrop" in $$props)
      $$invalidate(3, elemBackdrop = $$new_props.elemBackdrop);
    if ("windowSettings" in $$props)
      windowSettings = $$new_props.windowSettings;
    if ("styleSettings" in $$props)
      $$invalidate(19, styleSettings = $$new_props.styleSettings);
    if ("animSettings" in $$props)
      $$invalidate(4, animSettings = $$new_props.animSettings);
    if ("classesHeight" in $$props)
      $$invalidate(20, classesHeight = $$new_props.classesHeight);
    if ("classesWidth" in $$props)
      $$invalidate(21, classesWidth = $$new_props.classesWidth);
    if ("classesDrawer" in $$props)
      $$invalidate(5, classesDrawer = $$new_props.classesDrawer);
    if ("classesBackdrop" in $$props)
      $$invalidate(6, classesBackdrop = $$new_props.classesBackdrop);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*width, styleSettings*/
    557056) {
      $:
        $$invalidate(21, classesWidth = width ? width : styleSettings.width);
    }
    if ($$self.$$.dirty[0] & /*height, styleSettings*/
    589824) {
      $:
        $$invalidate(20, classesHeight = height ? height : styleSettings.height);
    }
    $:
      $$invalidate(6, classesBackdrop = `${cBaseBackdrop} ${styleSettings.backdrop} ${bgBackdrop} ${blur} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*classesWidth, classesHeight, bgDrawer, border, margin, rounded*/
    3305472) {
      $:
        $$invalidate(5, classesDrawer = `${cBaseDrawer} ${classesWidth} ${classesHeight} ${bgDrawer} ${border} ${margin} ${rounded}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    duration,
    labelledby,
    describedby,
    elemBackdrop,
    animSettings,
    classesDrawer,
    classesBackdrop,
    $drawerStore,
    onBackdropInteraction,
    onKeydownWindow,
    bgBackdrop,
    blur,
    bgDrawer,
    border,
    rounded,
    width,
    height,
    margin,
    position,
    styleSettings,
    classesHeight,
    classesWidth,
    $$scope,
    slots,
    keypress_handler,
    div1_binding
  ];
}
var Drawer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance29,
      create_fragment29,
      safe_not_equal,
      {
        position: 18,
        duration: 0,
        bgBackdrop: 10,
        blur: 11,
        bgDrawer: 12,
        border: 13,
        rounded: 14,
        width: 15,
        height: 16,
        margin: 17,
        labelledby: 1,
        describedby: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Drawer",
      options,
      id: create_fragment29.name
    });
  }
  get position() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgBackdrop() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgBackdrop(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blur(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgDrawer() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgDrawer(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get margin() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set margin(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedby() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedby(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Drawer_default = Drawer;

// node_modules/@skeletonlabs/skeleton/utilities/LightSwitch/LightSwitch.svelte
var { document: document_1 } = globals;
var file30 = "node_modules/@skeletonlabs/skeleton/utilities/LightSwitch/LightSwitch.svelte";
function create_else_block5(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z");
      add_location(path, file30, 75, 4, 3370);
      attr_dev(svg, "class", svg_class_value = "lightswitch-icon fill-white " + cIcon);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 384 512");
      add_location(svg, file30, 74, 3, 3259);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(73:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM352 256c0 53-43 96-96 96s-96-43-96-96s43-96 96-96s96 43 96 96zm32 0c0-70.7-57.3-128-128-128s-128 57.3-128 128s57.3 128 128 128s128-57.3 128-128z");
      add_location(path, file30, 70, 4, 2539);
      attr_dev(svg, "class", svg_class_value = "lightswitch-icon fill-black " + cIcon);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 512 512");
      add_location(svg, file30, 69, 3, 2428);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(68:2) {#if $storeLightSwitch === false}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let html_tag;
  let raw_value = `<script>${setColorScheme.toString()} setColorScheme();<\/script>`;
  let html_anchor;
  let t;
  let div1;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let div1_title_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*$storeLightSwitch*/
      ctx2[0] === false
    )
      return create_if_block21;
    return create_else_block5;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      t = space();
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-1b2q2h6", document_1.head);
      html_tag = claim_html_tag(head_nodes, false);
      html_anchor = empty();
      head_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-label": true,
        "aria-checked": true,
        title: true,
        tabindex: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
      attr_dev(div0, "class", div0_class_value = "lightswitch-thumb " + /*classesThumb*/
      ctx[1]);
      add_location(div0, file30, 66, 1, 2319);
      attr_dev(div1, "class", div1_class_value = "lightswitch " + /*classesBase*/
      ctx[2]);
      attr_dev(div1, "role", "switch");
      attr_dev(div1, "aria-label", "Light Switch");
      attr_dev(
        div1,
        "aria-checked",
        /*$storeLightSwitch*/
        ctx[0]
      );
      attr_dev(div1, "title", div1_title_value = "Toggle " + /*$storeLightSwitch*/
      (ctx[0] ? "Light" : "Dark") + " Mode");
      attr_dev(div1, "tabindex", "0");
      add_location(div1, file30, 53, 0, 2043);
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, document_1.head);
      append_hydration_dev(document_1.head, html_anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if_block.m(div0, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*onClick*/
            ctx[3],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*onKeyDown*/
            ctx[4],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keyup",
            /*keyup_handler*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[7],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
      if (dirty & /*classesThumb*/
      2 && div0_class_value !== (div0_class_value = "lightswitch-thumb " + /*classesThumb*/
      ctx2[1])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*classesBase*/
      4 && div1_class_value !== (div1_class_value = "lightswitch " + /*classesBase*/
      ctx2[2])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (dirty & /*$storeLightSwitch*/
      1) {
        attr_dev(
          div1,
          "aria-checked",
          /*$storeLightSwitch*/
          ctx2[0]
        );
      }
      if (dirty & /*$storeLightSwitch*/
      1 && div1_title_value !== (div1_title_value = "Toggle " + /*$storeLightSwitch*/
      (ctx2[0] ? "Light" : "Dark") + " Mode")) {
        attr_dev(div1, "title", div1_title_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div1);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cTrack2 = "inline-block bg-surface-200-700-token ring-[1px] ring-surface-300-600-token ring-inset w-12 h-6 rounded-full cursor-pointer transition-all duration-[100ms]";
var cThumb2 = "bg-white dark:bg-black fill-white dark:fill-black w-6 h-6 flex justify-center items-center rounded-full shadow-lg transition-all duration-[100ms] scale-90";
var cIcon = "block w-4 h-4";
function setColorScheme() {
  if (localStorage.getItem("storeLightSwitch") === "true" || !("storeLightSwitch" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) {
    document.documentElement.classList.add("dark");
  } else {
    document.documentElement.classList.remove("dark");
  }
}
function instance30($$self, $$props, $$invalidate) {
  let classesPosition;
  let classesBase;
  let classesThumb;
  let $storeLightSwitch;
  let $storePrefersDarkScheme;
  validate_store(storeLightSwitch, "storeLightSwitch");
  component_subscribe($$self, storeLightSwitch, ($$value) => $$invalidate(0, $storeLightSwitch = $$value));
  validate_store(storePrefersDarkScheme, "storePrefersDarkScheme");
  component_subscribe($$self, storePrefersDarkScheme, ($$value) => $$invalidate(8, $storePrefersDarkScheme = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LightSwitch", slots, []);
  const dispatch = createEventDispatcher();
  function setPrefersDarkScheme() {
    const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    storePrefersDarkScheme.set(prefersDark);
    if ($storeLightSwitch === void 0) {
      set_store_value(storeLightSwitch, $storeLightSwitch = $storePrefersDarkScheme, $storeLightSwitch);
    }
  }
  function setElemHtmlClass() {
    const elemHtmlClassList = document.documentElement.classList;
    $storeLightSwitch ? elemHtmlClassList.add("dark") : elemHtmlClassList.remove("dark");
  }
  function onClick(event) {
    storeLightSwitch.set(set_store_value(storeLightSwitch, $storeLightSwitch = !$storeLightSwitch, $storeLightSwitch));
    setElemHtmlClass();
    dispatch("click", event);
  }
  function onKeyDown(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      event.currentTarget.click();
    }
    dispatch("keydown", event);
  }
  onMount(() => {
    setPrefersDarkScheme();
  });
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    dispatch,
    storePrefersDarkScheme,
    storeLightSwitch,
    cTrack: cTrack2,
    cThumb: cThumb2,
    cIcon,
    setPrefersDarkScheme,
    setElemHtmlClass,
    setColorScheme,
    onClick,
    onKeyDown,
    classesPosition,
    classesThumb,
    classesBase,
    $storeLightSwitch,
    $storePrefersDarkScheme
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
    if ("classesPosition" in $$props)
      $$invalidate(5, classesPosition = $$new_props.classesPosition);
    if ("classesThumb" in $$props)
      $$invalidate(1, classesThumb = $$new_props.classesThumb);
    if ("classesBase" in $$props)
      $$invalidate(2, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$storeLightSwitch*/
    1) {
      $:
        $$invalidate(5, classesPosition = $storeLightSwitch ? "translate-x-full" : "translate-x-0");
    }
    $:
      $$invalidate(2, classesBase = `${cTrack2} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*classesPosition*/
    32) {
      $:
        $$invalidate(1, classesThumb = `${cThumb2} ${classesPosition}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    $storeLightSwitch,
    classesThumb,
    classesBase,
    onClick,
    onKeyDown,
    classesPosition,
    keyup_handler,
    keypress_handler
  ];
}
var LightSwitch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LightSwitch",
      options,
      id: create_fragment30.name
    });
  }
};
var LightSwitch_default = LightSwitch;

// node_modules/@skeletonlabs/skeleton/utilities/Toast/Toast.svelte
var file31 = "node_modules/@skeletonlabs/skeleton/utilities/Toast/Toast.svelte";
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  child_ctx[25] = i;
  return child_ctx;
}
function create_if_block22(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div0_transition;
  let div1_class_value;
  let current;
  let each_value = (
    /*$toastStore*/
    ctx[8]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "snackbar " + /*classesSnackbar*/
      ctx[6]);
      add_location(div0, file31, 78, 2, 2340);
      attr_dev(div1, "class", div1_class_value = "snackbar-wrapper " + /*classesWrapper*/
      ctx[7]);
      attr_dev(div1, "data-testid", "snackbar-wrapper");
      add_location(div1, file31, 76, 1, 2243);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*classesBase, $toastStore, buttonDismiss, toastStore, buttonAction, onAction, max*/
      813) {
        each_value = /*$toastStore*/
        ctx[8];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*classesSnackbar*/
      64 && div0_class_value !== (div0_class_value = "snackbar " + /*classesSnackbar*/
      ctx[6])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*classesWrapper*/
      128 && div1_class_value !== (div1_class_value = "snackbar-wrapper " + /*classesWrapper*/
      ctx[7])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div0_transition)
          div0_transition = create_bidirectional_transition(
            div0,
            fly,
            {
              x: (
                /*animAxis*/
                ctx[4].x
              ),
              y: (
                /*animAxis*/
                ctx[4].y
              ),
              duration: (
                /*duration*/
                ctx[1]
              )
            },
            true
          );
        div0_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      if (!div0_transition)
        div0_transition = create_bidirectional_transition(
          div0,
          fly,
          {
            x: (
              /*animAxis*/
              ctx[4].x
            ),
            y: (
              /*animAxis*/
              ctx[4].y
            ),
            duration: (
              /*duration*/
              ctx[1]
            )
          },
          false
        );
      div0_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
      if (detaching && div0_transition)
        div0_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(75:0) {#if $toastStore.length}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let div2;
  let div0;
  let raw_value = (
    /*t*/
    ctx[23].message + ""
  );
  let t0;
  let div1;
  let t1;
  let button;
  let t2;
  let button_class_value;
  let t3;
  let div2_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*t*/
    ctx[23].action && create_if_block_26(ctx)
  );
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[21](
        /*t*/
        ctx[23]
      )
    );
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      button = element("button");
      t2 = text("");
      t3 = space();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-live": true,
        "data-testid": true
      });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      button = claim_element(div1_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t2 = claim_text(button_nodes, "");
      button_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "text-base");
      add_location(div0, file31, 83, 6, 2623);
      attr_dev(button, "class", button_class_value = "btn-icon " + /*buttonDismiss*/
      ctx[3]);
      add_location(button, file31, 87, 7, 2878);
      attr_dev(div1, "class", "flex items-center space-x-2");
      add_location(div1, file31, 85, 6, 2707);
      attr_dev(div2, "class", div2_class_value = "toast " + /*classesBase*/
      ctx[5] + " " + /*t*/
      ctx[23].classes);
      attr_dev(div2, "role", "alert");
      attr_dev(div2, "aria-live", "polite");
      attr_dev(div2, "data-testid", "toast");
      add_location(div2, file31, 82, 5, 2519);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      div0.innerHTML = raw_value;
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, button);
      append_hydration_dev(button, t2);
      append_hydration_dev(div2, t3);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler_1, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$toastStore*/
      256 && raw_value !== (raw_value = /*t*/
      ctx[23].message + ""))
        div0.innerHTML = raw_value;
      ;
      if (
        /*t*/
        ctx[23].action
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_26(ctx);
          if_block.c();
          if_block.m(div1, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*buttonDismiss*/
      8 && button_class_value !== (button_class_value = "btn-icon " + /*buttonDismiss*/
      ctx[3])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & /*classesBase, $toastStore*/
      288 && div2_class_value !== (div2_class_value = "toast " + /*classesBase*/
      ctx[5] + " " + /*t*/
      ctx[23].classes)) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(81:4) {#if i < max + 1}",
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let button;
  let raw_value = (
    /*t*/
    ctx[23].action.label + ""
  );
  let button_class_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[20](
        /*i*/
        ctx[25]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "btn " + /*buttonAction*/
      ctx[2]);
      add_location(button, file31, 86, 21, 2770);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$toastStore*/
      256 && raw_value !== (raw_value = /*t*/
      ctx[23].action.label + ""))
        button.innerHTML = raw_value;
      ;
      if (dirty & /*buttonAction*/
      4 && button_class_value !== (button_class_value = "btn " + /*buttonAction*/
      ctx[2])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(87:7) {#if t.action}",
    ctx
  });
  return block;
}
function create_each_block7(ctx) {
  let if_block_anchor;
  let if_block = (
    /*i*/
    ctx[25] < /*max*/
    ctx[0] + 1 && create_if_block_111(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*i*/
        ctx2[25] < /*max*/
        ctx2[0] + 1
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_111(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(80:3) {#each $toastStore as t, i}",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$toastStore*/
    ctx[8].length && create_if_block22(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$toastStore*/
        ctx2[8].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$toastStore*/
          256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cWrapper = "flex fixed top-0 left-0 right-0 bottom-0 z-[888] pointer-events-none";
var cSnackbar = "flex flex-col space-y-2";
var cToast = "flex justify-between items-center pointer-events-auto";
function instance31($$self, $$props, $$invalidate) {
  let classesWrapper;
  let classesSnackbar;
  let classesBase;
  let $toastStore;
  validate_store(toastStore, "toastStore");
  component_subscribe($$self, toastStore, ($$value) => $$invalidate(8, $toastStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toast", slots, []);
  let { position = "b" } = $$props;
  let { max = 3 } = $$props;
  let { duration = 150 } = $$props;
  let { background = "bg-secondary-500" } = $$props;
  let { width = "max-w-[640px]" } = $$props;
  let { color = "text-on-secondary-token" } = $$props;
  let { padding = "p-4" } = $$props;
  let { spacing = "space-x-4" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { shadow = "shadow-lg" } = $$props;
  let { buttonAction = "variant-filled" } = $$props;
  let { buttonDismiss = "variant-filled" } = $$props;
  let cPosition;
  let cAlign;
  let animAxis = { x: 0, y: 0 };
  switch (position) {
    case "t":
      cPosition = "justify-center items-start";
      cAlign = "items-center";
      animAxis = { x: 0, y: -100 };
      break;
    case "b":
      cPosition = "justify-center items-end";
      cAlign = "items-center";
      animAxis = { x: 0, y: 100 };
      break;
    case "l":
      cPosition = "justify-start items-center";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "r":
      cPosition = "justify-end items-center";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
    case "tl":
      cPosition = "justify-start items-start";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "tr":
      cPosition = "justify-end items-start";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
    case "bl":
      cPosition = "justify-start items-end";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "br":
      cPosition = "justify-end items-end";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
  }
  function onAction(index) {
    var _a, _b;
    (_b = (_a = $toastStore[index]) == null ? void 0 : _a.action) == null ? void 0 : _b.response();
    toastStore.close($toastStore[index].id);
  }
  const click_handler = (i) => onAction(i);
  const click_handler_1 = (t) => {
    toastStore.close(t.id);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("position" in $$new_props)
      $$invalidate(10, position = $$new_props.position);
    if ("max" in $$new_props)
      $$invalidate(0, max = $$new_props.max);
    if ("duration" in $$new_props)
      $$invalidate(1, duration = $$new_props.duration);
    if ("background" in $$new_props)
      $$invalidate(11, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(12, width = $$new_props.width);
    if ("color" in $$new_props)
      $$invalidate(13, color = $$new_props.color);
    if ("padding" in $$new_props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("spacing" in $$new_props)
      $$invalidate(15, spacing = $$new_props.spacing);
    if ("rounded" in $$new_props)
      $$invalidate(16, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(17, shadow = $$new_props.shadow);
    if ("buttonAction" in $$new_props)
      $$invalidate(2, buttonAction = $$new_props.buttonAction);
    if ("buttonDismiss" in $$new_props)
      $$invalidate(3, buttonDismiss = $$new_props.buttonDismiss);
  };
  $$self.$capture_state = () => ({
    fly,
    toastStore,
    position,
    max,
    duration,
    background,
    width,
    color,
    padding,
    spacing,
    rounded,
    shadow,
    buttonAction,
    buttonDismiss,
    cWrapper,
    cSnackbar,
    cToast,
    cPosition,
    cAlign,
    animAxis,
    onAction,
    classesBase,
    classesSnackbar,
    classesWrapper,
    $toastStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("position" in $$props)
      $$invalidate(10, position = $$new_props.position);
    if ("max" in $$props)
      $$invalidate(0, max = $$new_props.max);
    if ("duration" in $$props)
      $$invalidate(1, duration = $$new_props.duration);
    if ("background" in $$props)
      $$invalidate(11, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(12, width = $$new_props.width);
    if ("color" in $$props)
      $$invalidate(13, color = $$new_props.color);
    if ("padding" in $$props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("spacing" in $$props)
      $$invalidate(15, spacing = $$new_props.spacing);
    if ("rounded" in $$props)
      $$invalidate(16, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(17, shadow = $$new_props.shadow);
    if ("buttonAction" in $$props)
      $$invalidate(2, buttonAction = $$new_props.buttonAction);
    if ("buttonDismiss" in $$props)
      $$invalidate(3, buttonDismiss = $$new_props.buttonDismiss);
    if ("cPosition" in $$props)
      $$invalidate(18, cPosition = $$new_props.cPosition);
    if ("cAlign" in $$props)
      $$invalidate(19, cAlign = $$new_props.cAlign);
    if ("animAxis" in $$props)
      $$invalidate(4, animAxis = $$new_props.animAxis);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
    if ("classesSnackbar" in $$props)
      $$invalidate(6, classesSnackbar = $$new_props.classesSnackbar);
    if ("classesWrapper" in $$props)
      $$invalidate(7, classesWrapper = $$new_props.classesWrapper);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, classesWrapper = `${cWrapper} ${cPosition} ${$$props.class || ""}`);
    if ($$self.$$.dirty & /*cAlign, padding*/
    540672) {
      $:
        $$invalidate(6, classesSnackbar = `${cSnackbar} ${cAlign} ${padding}`);
    }
    if ($$self.$$.dirty & /*background, width, color, padding, spacing, rounded, shadow*/
    260096) {
      $:
        $$invalidate(5, classesBase = `${cToast} ${background} ${width} ${color} ${padding} ${spacing} ${rounded} ${shadow}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    max,
    duration,
    buttonAction,
    buttonDismiss,
    animAxis,
    classesBase,
    classesSnackbar,
    classesWrapper,
    $toastStore,
    onAction,
    position,
    background,
    width,
    color,
    padding,
    spacing,
    rounded,
    shadow,
    cPosition,
    cAlign,
    click_handler,
    click_handler_1
  ];
}
var Toast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      position: 10,
      max: 0,
      duration: 1,
      background: 11,
      width: 12,
      color: 13,
      padding: 14,
      spacing: 15,
      rounded: 16,
      shadow: 17,
      buttonAction: 2,
      buttonDismiss: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toast",
      options,
      id: create_fragment31.name
    });
  }
  get position() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonAction() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonAction(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonDismiss() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonDismiss(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toast_default = Toast;

// node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Apollo.svelte
var file32 = "node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Apollo.svelte";
function create_fragment32(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { values: true, result: true, in: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "values", "0.8 0.6 -0.4 0.1 0,\n					0 1.2 0.05 0 0,\n					0 -1 3 0.02 0,\n					0 0 0 50 0");
      attr_dev(feColorMatrix, "result", "final");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      add_location(feColorMatrix, file32, 3, 2, 207);
      attr_dev(filter2, "id", "Apollo");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file32, 2, 1, 85);
      attr_dev(svg, "id", "svg-filter-apollo");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file32, 1, 0, 40);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Apollo", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Apollo> was created with unknown prop '${key}'`);
  });
  return [];
}
var Apollo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Apollo",
      options,
      id: create_fragment32.name
    });
  }
};
var Apollo_default = Apollo;

// node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/BlueNight.svelte
var file33 = "node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/BlueNight.svelte";
function create_fragment33(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.000 0.000 0.000 0.000 0.000 \n                    0.000 1.000 0.000 0.000 0.05 \n                    0.000 0.000 1.000 0.000 0.400 \n                    0.000 0.000 0.000 1.000 0.000");
      add_location(feColorMatrix, file33, 3, 2, 219);
      attr_dev(filter2, "id", "BlueNight");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file33, 2, 1, 94);
      attr_dev(svg, "id", "svg-filter-bluenight");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file33, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BlueNight", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BlueNight> was created with unknown prop '${key}'`);
  });
  return [];
}
var BlueNight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BlueNight",
      options,
      id: create_fragment33.name
    });
  }
};
var BlueNight_default = BlueNight;

// node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Emerald.svelte
var file34 = "node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Emerald.svelte";
function create_fragment34(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  let feComponentTransfer;
  let feFuncR;
  let feFuncG;
  let feFuncB;
  let feFuncA;
  let feBlend;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      feComponentTransfer = svg_element("feComponentTransfer");
      feFuncR = svg_element("feFuncR");
      feFuncG = svg_element("feFuncG");
      feFuncB = svg_element("feFuncB");
      feFuncA = svg_element("feFuncA");
      feBlend = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        in: true,
        result: true,
        values: true
      });
      children(feColorMatrix).forEach(detach_dev);
      feComponentTransfer = claim_svg_element(filter_nodes, "feComponentTransfer", { in: true, result: true });
      var feComponentTransfer_nodes = children(feComponentTransfer);
      feFuncR = claim_svg_element(feComponentTransfer_nodes, "feFuncR", { type: true, tableValues: true });
      children(feFuncR).forEach(detach_dev);
      feFuncG = claim_svg_element(feComponentTransfer_nodes, "feFuncG", { type: true, tableValues: true });
      children(feFuncG).forEach(detach_dev);
      feFuncB = claim_svg_element(feComponentTransfer_nodes, "feFuncB", { type: true, tableValues: true });
      children(feFuncB).forEach(detach_dev);
      feFuncA = claim_svg_element(feComponentTransfer_nodes, "feFuncA", { type: true, tableValues: true });
      children(feFuncA).forEach(detach_dev);
      feComponentTransfer_nodes.forEach(detach_dev);
      feBlend = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      attr_dev(feColorMatrix, "values", "\n            .16 .185 .129 0 0\n            .16 .185 .129 0 0\n            .16 .185 .129 0 0\n            0 0 0 0.33 0");
      add_location(feColorMatrix, file34, 4, 2, 245);
      attr_dev(feFuncR, "type", "table");
      attr_dev(feFuncR, "tableValues", "0.03 0.9");
      add_location(feFuncR, file34, 15, 3, 527);
      attr_dev(feFuncG, "type", "table");
      attr_dev(feFuncG, "tableValues", "0.57 1");
      add_location(feFuncG, file34, 16, 3, 578);
      attr_dev(feFuncB, "type", "table");
      attr_dev(feFuncB, "tableValues", "0.49 0.53");
      add_location(feFuncB, file34, 17, 3, 627);
      attr_dev(feFuncA, "type", "table");
      attr_dev(feFuncA, "tableValues", "0 1");
      add_location(feFuncA, file34, 18, 3, 679);
      attr_dev(feComponentTransfer, "in", "colormatrix");
      attr_dev(feComponentTransfer, "result", "componentTransfer");
      add_location(feComponentTransfer, file34, 14, 2, 458);
      attr_dev(feBlend, "mode", "normal");
      attr_dev(feBlend, "in", "componentTransfer");
      attr_dev(feBlend, "in2", "SourceGraphic");
      attr_dev(feBlend, "result", "blend");
      add_location(feBlend, file34, 20, 2, 749);
      attr_dev(filter2, "id", "Emerald");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file34, 2, 1, 88);
      attr_dev(svg, "id", "svg-filter-emerald");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file34, 1, 0, 42);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
      append_hydration_dev(filter2, feComponentTransfer);
      append_hydration_dev(feComponentTransfer, feFuncR);
      append_hydration_dev(feComponentTransfer, feFuncG);
      append_hydration_dev(feComponentTransfer, feFuncB);
      append_hydration_dev(feComponentTransfer, feFuncA);
      append_hydration_dev(filter2, feBlend);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Emerald", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Emerald> was created with unknown prop '${key}'`);
  });
  return [];
}
var Emerald = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Emerald",
      options,
      id: create_fragment34.name
    });
  }
};
var Emerald_default = Emerald;

// node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/GreenFall.svelte
var file35 = "node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/GreenFall.svelte";
function create_fragment35(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "0.5 -0.4 0.3332 0 0\n					0 0.4 0.3 0 0\n					0 0 0.5 0 0\n					0 0 0 500 -20");
      attr_dev(feColorMatrix, "x", "0%");
      attr_dev(feColorMatrix, "y", "0%");
      attr_dev(feColorMatrix, "width", "100%");
      attr_dev(feColorMatrix, "height", "100%");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      add_location(feColorMatrix, file35, 12, 2, 294);
      attr_dev(filter2, "id", "GreenFall");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file35, 2, 1, 101);
      attr_dev(svg, "id", "svg-filter-greenfall");
      attr_dev(svg, "class", "filter hidden");
      add_location(svg, file35, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GreenFall", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GreenFall> was created with unknown prop '${key}'`);
  });
  return [];
}
var GreenFall = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GreenFall",
      options,
      id: create_fragment35.name
    });
  }
};
var GreenFall_default = GreenFall;

// node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Noir.svelte
var file36 = "node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Noir.svelte";
function create_fragment36(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  let feBlend0;
  let feDiffuseLighting;
  let fePointLight;
  let feBlend1;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      feBlend0 = svg_element("feBlend");
      feDiffuseLighting = svg_element("feDiffuseLighting");
      fePointLight = svg_element("fePointLight");
      feBlend1 = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix).forEach(detach_dev);
      feBlend0 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend0).forEach(detach_dev);
      feDiffuseLighting = claim_svg_element(filter_nodes, "feDiffuseLighting", {
        surfaceScale: true,
        diffuseConstant: true,
        "lighting-color": true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      var feDiffuseLighting_nodes = children(feDiffuseLighting);
      fePointLight = claim_svg_element(feDiffuseLighting_nodes, "fePointLight", { x: true, y: true, z: true });
      children(fePointLight).forEach(detach_dev);
      feDiffuseLighting_nodes.forEach(detach_dev);
      feBlend1 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend1).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "saturate");
      attr_dev(feColorMatrix, "values", "0");
      attr_dev(feColorMatrix, "x", "0%");
      attr_dev(feColorMatrix, "y", "0%");
      attr_dev(feColorMatrix, "width", "100%");
      attr_dev(feColorMatrix, "height", "100%");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix1");
      add_location(feColorMatrix, file36, 12, 2, 267);
      attr_dev(feBlend0, "mode", "lighten");
      attr_dev(feBlend0, "x", "0%");
      attr_dev(feBlend0, "y", "0%");
      attr_dev(feBlend0, "width", "100%");
      attr_dev(feBlend0, "height", "100%");
      attr_dev(feBlend0, "in", "colormatrix1");
      attr_dev(feBlend0, "in2", "colormatrix1");
      attr_dev(feBlend0, "result", "blend");
      add_location(feBlend0, file36, 13, 2, 396);
      attr_dev(fePointLight, "x", "200");
      attr_dev(fePointLight, "y", "157");
      attr_dev(fePointLight, "z", "200");
      add_location(fePointLight, file36, 25, 3, 714);
      attr_dev(feDiffuseLighting, "surfaceScale", "7.7");
      attr_dev(feDiffuseLighting, "diffuseConstant", "7.3");
      attr_dev(feDiffuseLighting, "lighting-color", "#707070");
      attr_dev(feDiffuseLighting, "x", "0%");
      attr_dev(feDiffuseLighting, "y", "0%");
      attr_dev(feDiffuseLighting, "width", "100%");
      attr_dev(feDiffuseLighting, "height", "100%");
      attr_dev(feDiffuseLighting, "in", "blend");
      attr_dev(feDiffuseLighting, "result", "diffuseLighting");
      add_location(feDiffuseLighting, file36, 14, 2, 518);
      attr_dev(feBlend1, "mode", "multiply");
      attr_dev(feBlend1, "x", "0%");
      attr_dev(feBlend1, "y", "0%");
      attr_dev(feBlend1, "width", "100%");
      attr_dev(feBlend1, "height", "100%");
      attr_dev(feBlend1, "in", "colormatrix1");
      attr_dev(feBlend1, "in2", "diffuseLighting");
      attr_dev(feBlend1, "result", "blend1");
      add_location(feBlend1, file36, 27, 2, 780);
      attr_dev(filter2, "id", "Noir");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file36, 2, 1, 79);
      attr_dev(svg, "id", "svg-filter-noir");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file36, 1, 0, 36);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
      append_hydration_dev(filter2, feBlend0);
      append_hydration_dev(filter2, feDiffuseLighting);
      append_hydration_dev(feDiffuseLighting, fePointLight);
      append_hydration_dev(filter2, feBlend1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Noir", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Noir> was created with unknown prop '${key}'`);
  });
  return [];
}
var Noir = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Noir",
      options,
      id: create_fragment36.name
    });
  }
};
var Noir_default = Noir;

// node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/NoirLight.svelte
var file37 = "node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/NoirLight.svelte";
function create_fragment37(ctx) {
  let svg;
  let filter2;
  let feColorMatrix0;
  let feBlend0;
  let feBlend1;
  let feColorMatrix1;
  let feBlend2;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix0 = svg_element("feColorMatrix");
      feBlend0 = svg_element("feBlend");
      feBlend1 = svg_element("feBlend");
      feColorMatrix1 = svg_element("feColorMatrix");
      feBlend2 = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix0 = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix0).forEach(detach_dev);
      feBlend0 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend0).forEach(detach_dev);
      feBlend1 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend1).forEach(detach_dev);
      feColorMatrix1 = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix1).forEach(detach_dev);
      feBlend2 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend2).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix0, "type", "saturate");
      attr_dev(feColorMatrix0, "values", "0");
      attr_dev(feColorMatrix0, "x", "0%");
      attr_dev(feColorMatrix0, "y", "0%");
      attr_dev(feColorMatrix0, "width", "100%");
      attr_dev(feColorMatrix0, "height", "100%");
      attr_dev(feColorMatrix0, "in", "SourceGraphic");
      attr_dev(feColorMatrix0, "result", "colormatrix2");
      add_location(feColorMatrix0, file37, 12, 2, 287);
      attr_dev(feBlend0, "mode", "saturation");
      attr_dev(feBlend0, "x", "0%");
      attr_dev(feBlend0, "y", "0%");
      attr_dev(feBlend0, "width", "100%");
      attr_dev(feBlend0, "height", "100%");
      attr_dev(feBlend0, "in", "SourceGraphic");
      attr_dev(feBlend0, "in2", "colormatrix2");
      attr_dev(feBlend0, "result", "blend2");
      add_location(feBlend0, file37, 13, 2, 416);
      attr_dev(feBlend1, "mode", "screen");
      attr_dev(feBlend1, "x", "0%");
      attr_dev(feBlend1, "y", "0%");
      attr_dev(feBlend1, "width", "100%");
      attr_dev(feBlend1, "height", "100%");
      attr_dev(feBlend1, "in", "colormatrix2");
      attr_dev(feBlend1, "in2", "blend2");
      attr_dev(feBlend1, "result", "blend3");
      add_location(feBlend1, file37, 14, 2, 543);
      attr_dev(feColorMatrix1, "type", "luminanceToAlpha");
      attr_dev(feColorMatrix1, "x", "0%");
      attr_dev(feColorMatrix1, "y", "0%");
      attr_dev(feColorMatrix1, "width", "100%");
      attr_dev(feColorMatrix1, "height", "100%");
      attr_dev(feColorMatrix1, "in", "blend3");
      attr_dev(feColorMatrix1, "result", "colormatrix3");
      add_location(feColorMatrix1, file37, 15, 2, 659);
      attr_dev(feBlend2, "mode", "exclusion");
      attr_dev(feBlend2, "x", "0%");
      attr_dev(feBlend2, "y", "0%");
      attr_dev(feBlend2, "width", "100%");
      attr_dev(feBlend2, "height", "100%");
      attr_dev(feBlend2, "in", "blend3");
      attr_dev(feBlend2, "in2", "colormatrix3");
      attr_dev(feBlend2, "result", "blend5");
      add_location(feBlend2, file37, 16, 2, 778);
      attr_dev(filter2, "id", "NoirLight");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file37, 2, 1, 94);
      attr_dev(svg, "id", "svg-filter-noirlight");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file37, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix0);
      append_hydration_dev(filter2, feBlend0);
      append_hydration_dev(filter2, feBlend1);
      append_hydration_dev(filter2, feColorMatrix1);
      append_hydration_dev(filter2, feBlend2);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NoirLight", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NoirLight> was created with unknown prop '${key}'`);
  });
  return [];
}
var NoirLight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NoirLight",
      options,
      id: create_fragment37.name
    });
  }
};
var NoirLight_default = NoirLight;

// node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Rustic.svelte
var file38 = "node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Rustic.svelte";
function create_fragment38(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        in: true,
        result: true,
        values: true
      });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      attr_dev(feColorMatrix, "values", "0.39215686274509803 0.39215686274509803 0.39215686274509803  0 0 \n					0.3333333333333333 0.3333333333333333 0.3333333333333333  0 0 \n					0.30980392156862746 0.30980392156862746 0.30980392156862746  0 0  \n					0 0 0 1 0");
      add_location(feColorMatrix, file38, 3, 2, 207);
      attr_dev(filter2, "id", "Rustic");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file38, 2, 1, 85);
      attr_dev(svg, "id", "svg-filter-rustic");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file38, 1, 0, 40);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Rustic", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Rustic> was created with unknown prop '${key}'`);
  });
  return [];
}
var Rustic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Rustic",
      options,
      id: create_fragment38.name
    });
  }
};
var Rustic_default = Rustic;

// node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Summer84.svelte
var file39 = "node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Summer84.svelte";
function create_fragment39(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.300 0.200 0.000 0.000 0.000 \n					0.300 0.600 0.200 0.000 0.000 \n					0.200 1.000 0.200 0.000 0.000 \n					0.000 0.000 0.000 1.000 0.000");
      add_location(feColorMatrix, file39, 3, 2, 215);
      attr_dev(filter2, "id", "Summer84");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file39, 2, 1, 91);
      attr_dev(svg, "id", "svg-filter-summer84");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file39, 1, 0, 44);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Summer84", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Summer84> was created with unknown prop '${key}'`);
  });
  return [];
}
var Summer84 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Summer84",
      options,
      id: create_fragment39.name
    });
  }
};
var Summer84_default = Summer84;

// node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/XPro.svelte
var file40 = "node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/XPro.svelte";
function create_fragment40(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.70 -0.20 0.00 0.00 0.00 \n                    0.10 0.800 0.30 0.00 0.00 \n                    0.20 0.300 0.50 0.00 0.00 \n                    0.00 0.00 0.00 1.00 0.00");
      add_location(feColorMatrix, file40, 3, 2, 199);
      attr_dev(filter2, "id", "XPro");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file40, 2, 1, 79);
      attr_dev(svg, "id", "svg-filter-xpro");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file40, 1, 0, 36);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("XPro", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<XPro> was created with unknown prop '${key}'`);
  });
  return [];
}
var XPro = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XPro",
      options,
      id: create_fragment40.name
    });
  }
};
var XPro_default = XPro;
export {
  AccordionGroup_default as AccordionGroup,
  AccordionItem_default as AccordionItem,
  Apollo_default as Apollo,
  AppBar_default as AppBar,
  AppRail_default as AppRail,
  AppRailTile_default as AppRailTile,
  AppShell_default as AppShell,
  Avatar_default as Avatar,
  BlueNight_default as BlueNight,
  CodeBlock_default as CodeBlock,
  ConicGradient_default as ConicGradient,
  Drawer_default as Drawer,
  Emerald_default as Emerald,
  FileButton_default as FileButton,
  FileDropzone_default as FileDropzone,
  GreenFall_default as GreenFall,
  InputChip_default as InputChip,
  LightSwitch_default as LightSwitch,
  ListBox_default as ListBox,
  ListBoxItem_default as ListBoxItem,
  Modal_default as Modal,
  Noir_default as Noir,
  NoirLight_default as NoirLight,
  Paginator_default as Paginator,
  ProgressBar_default as ProgressBar,
  ProgressRadial_default as ProgressRadial,
  RadioGroup_default as RadioGroup,
  RadioItem_default as RadioItem,
  RangeSlider_default as RangeSlider,
  Rustic_default as Rustic,
  SlideToggle_default as SlideToggle,
  Step_default as Step,
  Stepper_default as Stepper,
  Summer84_default as Summer84,
  Tab_default as Tab,
  TabGroup_default as TabGroup,
  Table_default as Table,
  TableOfContents_default as TableOfContents,
  Toast_default as Toast,
  XPro_default as XPro,
  clipboard,
  createDataTableStore,
  dataTableHandler,
  drawerStore,
  filter,
  focusTrap,
  localStorageStore,
  menu,
  modalStore,
  storeHighlightJs,
  storeLightSwitch,
  storePrefersDarkScheme,
  tableA11y,
  tableInteraction,
  tableMapperValues,
  tableSourceMapper,
  tableSourceValues,
  toastStore,
  tooltip
};
//# sourceMappingURL=@skeletonlabs_skeleton.js.map
